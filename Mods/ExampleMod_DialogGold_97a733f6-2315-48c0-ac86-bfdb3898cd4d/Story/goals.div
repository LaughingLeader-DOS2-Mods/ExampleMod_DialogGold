version "1.6"
Goal(1).Title("__Combat");
Goal(1)
{
	INIT
	{
		
	}
	KB
	{
		PROC
		ProcClearPreviousCombat((GUIDSTRING)_Char)
		AND
		DB_WasInCombat(_Char,(INTEGER)_Combat)
		THEN
		NOT DB_WasInCombat(_Char,_Combat);
		
		PROC
		ProcAddToCharacterCombatList((GUIDSTRING)_Char,(INTEGER)_Combat)
		AND
		DB_CombatCharacters((CHARACTERGUID)_Char,(INTEGER)_Old)
		THEN
		NOT DB_CombatCharacters((CHARACTERGUID)_Char,_Old);
		
		PROC
		ProcAddToCharacterCombatList((GUIDSTRING)_Char,(INTEGER)_Combat)
		AND
		ObjectIsCharacter(_Char,1)
		THEN
		DB_CombatCharacters((CHARACTERGUID)_Char,_Combat);
		
		IF
		ObjectEnteredCombat(_Character,_Combat)
		THEN
		ProcClearPreviousCombat((GUIDSTRING)_Character);
		DB_CombatObjects(_Character,_Combat);
		ProcAddToCharacterCombatList(_Character,_Combat);
		
		IF
		ObjectSwitchedCombat(_Character,_Old,_New)
		THEN
		NOT DB_CombatObjects(_Character,_Old);
		DB_CombatObjects(_Character,_New);
		ProcAddToCharacterCombatList(_Character,_New);
		
		PROC
		Proc_ObjectLeftCombat((GUIDSTRING)_Char,(INTEGER)_Combat)
		THEN
		DB_NOOP(1);
		
		IF
		ObjectLeftCombat(_Character,_Combat)
		THEN
		DB_WasInCombat(_Character,_Combat);
		NOT DB_CombatObjects(_Character,_Combat);
		NOT DB_CombatCharacters((CHARACTERGUID)_Character,_Combat);
		Proc_ObjectLeftCombat(_Character,_Combat);
		
		IF
		FleeCombat(_Player)
		AND
		DB_IsPlayer(_Player)
		AND
		NOT DB_BlockWaypointUsage(_Player)
		THEN
		OpenWaypointUIForFlee(_Player);
		
	}
	EXIT
	{
		
	}
}
Goal(2).Title("__GLO_Shovel");
Goal(2)
{
	INIT
	{
		DB_LizardFirstShovelUses(0);
		
	}
	KB
	{
		//REGION CHECK FOR TREASURE
		IF
		DB_ShovelArea((TRIGGERGUID)_Trigger,(STRING)_,(ITEMGUID)_)
		THEN
		ProcTriggerRegisterForPlayers(_Trigger);
		
		IF
		DB_ShovelRewardItemAppear(_,_Item,_)
		THEN
		SetOnStage(_Item,0);
		
		IF
		DB_ShovelRewardItemScatter(_,_Item)
		THEN
		SetOnStage(_Item,0);
		
		IF
		DB_ShovelRewardItemSpawn(_,_Item)
		THEN
		SetOnStage(_Item,0);
		
		IF
		DB_ShovelRewardCharacterAppear(_,_Character)
		THEN
		SetOnStage(_Character,0);
		
		//Dig while in a trigger
		IF
		CharacterUsedItem(_Player, _Shovel)
		AND
		ObjectExists(_Shovel,1)	//ignore consumables that were destroyed
		AND
		IsTagged(_Shovel, "SHOVEL", 1)
		AND
		DB_ShovelArea(_Trigger,_,_DirtPile)
		AND
		DB_InRegion(_Player,_Trigger)
		AND
		NOT DB_Shovelling_Mound(_,_DirtPile)
		AND
		CharacterIsInFightMode(_Player,_WasInFightMode)
		THEN
		DB_Shovelling_Mound(_Player,_DirtPile);
		CharacterSetFightMode(_Player,0,1);
		PlayAnimation(_Player,"use_dig","digmound");
		DB_Shovel_PlayerHadWeaponDrawn(_Player,_WasInFightMode);
		
		//Dig outside a trigger
		IF
		CharacterUsedItem(_Player, _Shovel)
		AND
		ObjectExists(_Shovel,1)	//ignore consumables that were destroyed
		AND
		IsTagged(_Shovel, "SHOVEL", 1)
		AND
		NOT DB_Shovelling_Mound(_Player,_)
		AND
		CharacterIsInFightMode(_Player,_WasInFightMode)
		THEN
		CharacterSetFightMode(_Player,0,1);
		PlayAnimation(_Player,"use_dig","digmound");
		DB_Shovel_PlayerHadWeaponDrawn(_Player,_WasInFightMode);
		
		//Dig by interacting with pile without a shovel
		
		IF
		CharacterUsedItem(_Player,_DirtPile)
		AND
		DB_ShovelArea(_,_,_DirtPile)
		AND
		NOT PartyFindTaggedItem(_Player, "SHOVEL", 0, _)
		AND
		IsTagged(_Player,"LIZARD",0)
		THEN
		Proc_StartDialog(1,"GLO_AD_ShovelRequired", _Player);
		
		IF
		CharacterUsedItem(_Player,_DirtPile)
		AND
		DB_ShovelArea(_,_,_DirtPile)
		AND
		NOT DB_Shovelling_Mound(_,_DirtPile)
		AND
		IsTagged(_Player,"LIZARD",1)
		AND
		CharacterIsInFightMode(_Player,_WasInFightMode)
		THEN
		DB_Shovelling_Mound(_Player,_DirtPile);
		CharacterSetFightMode(_Player,0,1);
		PlayAnimation(_Player,"use_dig","digmound");
		DB_Shovel_PlayerHadWeaponDrawn(_Player,_WasInFightMode);
		proc_LizardFirstShovelUse((CHARACTERGUID)_Player);
		
		//Dig by interacting with pile with a shovel
		IF
		CharacterUsedItem(_Player,_DirtPile)
		AND
		DB_ShovelArea(_,_,_DirtPile)
		AND
		NOT DB_Shovelling_Mound(_,_DirtPile)
		AND
		PartyFindTaggedItem(_Player, "SHOVEL", 1, _)
		AND
		CharacterIsInFightMode(_Player,_WasInFightMode)
		THEN
		DB_Shovelling_Mound(_Player,_DirtPile);
		CharacterSetFightMode(_Player,0,1);
		PlayAnimation(_Player,"use_dig","digmound");
		DB_Shovel_PlayerHadWeaponDrawn(_Player,_WasInFightMode);
		
		//After Dig
		IF
		StoryEvent(_Player,"digmound")
		AND
		NOT DB_Shovelling_Mound((CHARACTERGUID)_Player,_)
		THEN
		Proc_StartDialog(1,"GLO_AD_ShovelFailed", _Player);
		
		IF
		StoryEvent(_Player,"digmound")
		AND
		DB_Shovelling_Mound((CHARACTERGUID)_Player,_DirtMound)
		AND
		DB_ShovelArea(_Trigger,_Reward,_DirtMound)
		THEN
		NOT DB_ShovelArea(_Trigger,_Reward,_DirtMound);
		NOT DB_Shovelling_Mound(_Player,_DirtMound);
		SetOnStage(_DirtMound,0);
		ProcShovelRewards(_Player,_Reward);
		CharacterItemSetEvent(_Player,_DirtMound,"clearedMound");
		
		IF
		StoryEvent(_Player,"digmound")
		AND
		DB_Shovel_PlayerHadWeaponDrawn((CHARACTERGUID)_Player,1)
		THEN
		CharacterSetFightMode(_Player,1,0);
		
		IF
		StoryEvent(_Player,"digmound")
		AND
		DB_Shovel_PlayerHadWeaponDrawn((CHARACTERGUID)_Player,_Value)
		THEN
		NOT DB_Shovel_PlayerHadWeaponDrawn(_Player,_Value);
		
		//END_REGION
		
		//REGION Lizard Dig AD
		
		PROC
		proc_LizardFirstShovelUse((CHARACTERGUID)_Lizrd)
		AND
		IsTagged(_Lizrd,"LIZARD",1)
		AND
		DB_LizardFirstShovelUses(_Int)
		AND
		_Int < 3
		AND
		IntegerSum(_Int,1,_NewInt)
		THEN
		DB_LizardFirstShovelUses(_NewInt);
		NOT DB_LizardFirstShovelUses(_Int);
		Proc_StartDialog(1,"GEN_AD_Lizrd_Dig",_Lizrd);
		
		
		
		//END_REGION
		
		//REGION SHOVEL REWARDS
		PROC
		ProcShovelRewards((CHARACTERGUID)_Player,(STRING)_Reward)
		AND
		DB_ShovelRewardItemAdd(_Reward,(ITEMGUID)_Item)
		THEN
		ItemToInventory(_Item,_Player,-1);
		
		PROC
		ProcShovelRewards((CHARACTERGUID)_Player,(STRING)_Reward)
		AND
		DB_ShovelRewardItemAppear(_Reward,(ITEMGUID)_Item,(TRIGGERGUID)_Trigger)
		THEN
		SetOnStage(_Item,1);
		ItemDragToTrigger(_Item,_Trigger);
		
		PROC
		ProcShovelRewards((CHARACTERGUID)_Player,(STRING)_Reward)
		AND
		DB_ShovelRewardCharacterAppear(_Reward,(CHARACTERGUID)_Character)
		THEN
		CharacterAppear(_Character,1,"");
		
		PROC
		ProcShovelRewards((CHARACTERGUID)_Player,(STRING)_Reward)
		AND
		DB_ShovelRewardItemSpawn(_Reward,(ITEMGUID)_Item)
		THEN
		SetOnStage(_Item,1);
		
		PROC
		ProcShovelRewards((CHARACTERGUID)_Player,(STRING)_Reward)
		AND
		DB_ShovelRewardItemTemplate(_Reward,(STRING)_ItemTemplate,(INTEGER)_Amount)
		THEN
		ItemTemplateAddTo(_ItemTemplate,_Player,_Amount);
		
		PROC
		ProcShovelRewards((CHARACTERGUID)_Player,(STRING)_Reward)
		AND
		DB_ShovelRewardEvent(_Reward,(STRING)_Event)
		THEN
		GlobalSetFlag(_Event);
		
		PROC
		ProcShovelRewards((CHARACTERGUID)_Player,(STRING)_Reward)
		AND
		DB_ShovelRewardVoiceBark(_Reward, (STRING)_VoiceBark)
		THEN
		StartVoiceBark(_VoiceBark, _Player);
		
		PROC
		ProcShovelRewards((CHARACTERGUID)_Player,(STRING)_Reward)
		AND
		DB_ShovelRewardSurface(_Reward,(TRIGGERGUID)_Trigger, (STRING)_Type, (REAL)_Radius, (REAL)_Lifetime)
		THEN
		CreateSurface(_Trigger, _Type, _Radius, _Lifetime);
		
		PROC
		ProcShovelRewards((CHARACTERGUID)_Player,(STRING)_Reward)
		AND
		DB_ShovelRewardItemScatter(_Reward,(ITEMGUID)_Item)
		AND
		GetPosition(_Item, _X, _Y, _Z)
		THEN
		SetOnStage(_Item, 1);
		ItemScatterAt(_Item, _X, _Y, _Z);
		
		//END_REGION
		
		//REGION Tombstone AD
		
		IF
		CharacterItemEvent(_Player,_Tombstone,"GEN_UsedTombstone")
		AND
		GetVarFixedString(_Tombstone,"Dialog",_Dialog)
		AND
		_Dialog != ""
		THEN
		Proc_StartDialog(1,_Dialog,_Tombstone,_Player);
		
		//END_REGION
		
	}
	EXIT
	{
		
	}
}
Goal(3).Title("__GLOBAL_Dialogs");
Goal(3)
{
	INIT
	{
		// To intercept a dialog request, define one of these:
		//   PROC_GLOBAL_DialogStartRequested((GUIDSTRING)_Target,(GUIDSTRING)_Source)
		//   PROC_GLOBAL_DialogStartRequested_AfterGenerics((GUIDSTRING)_Target,(GUIDSTRING)_Source)
		// The former is called before any generics (low attitude etc) are checked, but still after
		// speaker availability checks are confirmed (not dead, not in combat).
		// Start your own dialog in one of those PROCs if the conditions are right, and set
		// DB_FoundDialog(_Target,_Source) if you want to prevent the default dialog to be searched/started
		//
		
		DB_AnimalFoodVars("FoodTemplate1");
		DB_AnimalFoodVars("FoodTemplate2");
		DB_AnimalFoodVars("FoodTemplate3");
		DB_AnimalFoodVars("FoodTemplate4");
		DB_AnimalFoodVars("FoodTemplate5");
		DB_AnimalFoodVars("FoodTemplate6");
		
	}
	KB
	{
		//REGION HasMet
		IF
		DB_HasMetCharactersToCheck(_NPC,_PC)
		THEN
		ProcSetHasMetTag(_Npc,_PC);
		
		IF
		DB_HasMetCharactersToCheck(_NPC,_PC)
		THEN
		NOT DB_HasMetCharactersToCheck(_NPC,_PC);
		
		PROC
		Proc_Dialogs_CharactersHaveMetInThisShape((GUIDSTRING)_Npc,(CHARACTERGUID)_Player)
		THEN
		SetTag(_NPC,"HasMet");
		
		PROC
		ProcSetHasMetTag((GUIDSTRING)_Npc,(CHARACTERGUID)_Player)
		AND
		DB_CharacterPolymorphedInto(_Player,(STRING)_Race)
		AND
		DB_HasMet(_Npc,_Player,(STRING)_Race)
		THEN
		Proc_Dialogs_CharactersHaveMetInThisShape(_Npc,_Player);
		
		PROC
		ProcSetHasMetTag((GUIDSTRING)_Npc,(CHARACTERGUID)_Player)
		AND
		NOT DB_CharacterPolymorphedInto(_Player,_)
		AND
		DB_HasMet(_Npc,_Player,"")
		THEN
		Proc_Dialogs_CharactersHaveMetInThisShape(_Npc,_Player);
		
		IF
		DialogEnded(_Diag,_Inst)
		AND
		DB_DialogNPCs(_Inst,_Npc,_)
		AND
		DB_DialogPlayers(_Inst,_Player,_)
		THEN
		ProcSetHasMetDBEntry(_Diag,(GUIDSTRING)_Npc,(CHARACTERGUID)_Player);
		
		PROC
		ProcSetHasMetDBEntry((STRING)_Diag,(GUIDSTRING)_Npc,(CHARACTERGUID)_Player)
		AND
		DB_CharacterPolymorphedInto(_Player,_Race)
		THEN
		DB_HasMet(_Npc,_Player,_Race);
		
		PROC
		ProcSetHasMetDBEntry((STRING)_Diag,(GUIDSTRING)_Npc,(CHARACTERGUID)_Player)
		AND
		NOT DB_CharacterPolymorphedInto(_Player,_)
		THEN
		DB_HasMet(_Npc,_Player,"");
		
		
		IF
		DialogEnded(_Diag,_Inst)
		AND
		DB_DialogNPCs(_Inst,_Npc,_)
		THEN
		ClearTag(_Npc,"HasMet");
		//END_REGION
		
		//REGION The Only Allowed Dialog Starting
		PROC
		Proc_StartDialog((INTEGER)_Automated,(STRING)_Dialog,(GUIDSTRING)_Speaker1)
		AND
		QRY_StartDialog(_Automated,_Dialog,_Speaker1)
		THEN
		DB_NOOP(1);
		
		PROC
		Proc_StartDialog((INTEGER)_Automated,(STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2)
		AND
		NOT DB_OriginMomentTag(_Dialog,(STRING)_,(STRING)_)
		AND
		NOT DB_OriginMomentTag_HighPriority(_Dialog,(STRING)_,(STRING)_)
		AND
		NOT DB_OriginRecruitmentDialog((CHARACTERGUID)_,_Dialog)
		AND
		QRY_StartDialog(_Automated,_Dialog,_Speaker1,_Speaker2)
		THEN
		DB_NOOP(1);
		
		PROC
		Proc_StartDialog((INTEGER)_Automated,(STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2,(GUIDSTRING)_Speaker3)
		AND
		NOT DB_OriginMomentTag_3SP(_Dialog,(STRING)_,(STRING)_)
		AND
		NOT DB_OriginMomentTag_HighPriority_3SP(_Dialog,(STRING)_,(STRING)_)
		AND
		QRY_StartDialog(_Automated,_Dialog,_Speaker1,_Speaker2,_Speaker3)
		THEN
		DB_NOOP(1);
		
		PROC
		Proc_StartDialog((INTEGER)_Automated,(STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2,(GUIDSTRING)_Speaker3,(GUIDSTRING)_Speaker4)
		AND
		QRY_StartDialog(_Automated,_Dialog,_Speaker1,_Speaker2,_Speaker3,_Speaker4)
		THEN
		DB_NOOP(1);
		
		PROC
		Proc_StartDialog((INTEGER)_Automated,(STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2,(GUIDSTRING)_Speaker3,(GUIDSTRING)_Speaker4,(GUIDSTRING)_Speaker5)
		AND
		QRY_StartDialog(_Automated,_Dialog,_Speaker1,_Speaker2,_Speaker3,_Speaker4,_Speaker5)
		THEN
		DB_NOOP(1);
		
		PROC
		Proc_StartDialog((INTEGER)_Automated,(STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2,(GUIDSTRING)_Speaker3,(GUIDSTRING)_Speaker4,(GUIDSTRING)_Speaker5,(GUIDSTRING)_Speaker6)
		AND
		QRY_StartDialog(_Automated,_Dialog,_Speaker1,_Speaker2,_Speaker3,_Speaker4,_Speaker5,_Speaker6)
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_StartDialog(1,(STRING)_Dialog,(GUIDSTRING)_Speaker1)
		AND
		QRY_SpeakerIsAvailable(_Speaker1,1)
		AND
		StartDialog_Internal(_Dialog,0,_Speaker1,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,1)
		THEN
		Proc_DialogFlagSetup((STRING)_Dialog,(GUIDSTRING)_Speaker1);
		
		QRY
		QRY_StartDialog(1,(STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2)
		AND
		QRY_SpeakerIsAvailable(_Speaker1,1)
		AND
		QRY_SpeakerIsAvailable(_Speaker2,1)
		AND
		StartDialog_Internal(_Dialog,0,_Speaker1,_Speaker2,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,1)
		THEN
		Proc_DialogFlagSetup((STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2);
		
		QRY
		QRY_StartDialog(1,(STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2,(GUIDSTRING)_Speaker3)
		AND
		QRY_SpeakerIsAvailable(_Speaker1,1)
		AND
		QRY_SpeakerIsAvailable(_Speaker2,1)
		AND
		QRY_SpeakerIsAvailable(_Speaker3,1)
		AND
		StartDialog_Internal(_Dialog,0,_Speaker1,_Speaker2,_Speaker3,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,1)
		THEN
		Proc_DialogFlagSetup((STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2, (GUIDSTRING)_Speaker3);
		
		QRY
		QRY_StartDialog(1,(STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2,(GUIDSTRING)_Speaker3,(GUIDSTRING)_Speaker4)
		AND
		QRY_SpeakerIsAvailable(_Speaker1,1)
		AND
		QRY_SpeakerIsAvailable(_Speaker2,1)
		AND
		QRY_SpeakerIsAvailable(_Speaker3,1)
		AND
		QRY_SpeakerIsAvailable(_Speaker4,1)
		AND
		StartDialog_Internal(_Dialog,0,_Speaker1,_Speaker2,_Speaker3,_Speaker4,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,1)
		THEN
		Proc_DialogFlagSetup((STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2, (GUIDSTRING)_Speaker3, (GUIDSTRING)_Speaker4);
		
		QRY
		QRY_StartDialog(1,(STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2,(GUIDSTRING)_Speaker3,(GUIDSTRING)_Speaker4,(GUIDSTRING)_Speaker5)
		AND
		QRY_SpeakerIsAvailable(_Speaker1,1)
		AND
		QRY_SpeakerIsAvailable(_Speaker2,1)
		AND
		QRY_SpeakerIsAvailable(_Speaker3,1)
		AND
		QRY_SpeakerIsAvailable(_Speaker4,1)
		AND
		QRY_SpeakerIsAvailable(_Speaker5,1)
		AND
		StartDialog_Internal(_Dialog,0,_Speaker1,_Speaker2,_Speaker3,_Speaker4,_Speaker5,NULL_00000000-0000-0000-0000-000000000000,1)
		THEN
		Proc_DialogFlagSetup((STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2, (GUIDSTRING)_Speaker3, (GUIDSTRING)_Speaker4, (GUIDSTRING)_Speaker5,NULL_00000000-0000-0000-0000-000000000000);
		
		QRY
		QRY_StartDialog(1,(STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2,(GUIDSTRING)_Speaker3,(GUIDSTRING)_Speaker4,(GUIDSTRING)_Speaker5,(GUIDSTRING)_Speaker6)
		AND
		QRY_SpeakerIsAvailable(_Speaker1,1)
		AND
		QRY_SpeakerIsAvailable(_Speaker2,1)
		AND
		QRY_SpeakerIsAvailable(_Speaker3,1)
		AND
		QRY_SpeakerIsAvailable(_Speaker4,1)
		AND
		QRY_SpeakerIsAvailable(_Speaker5,1)
		AND
		QRY_SpeakerIsAvailable(_Speaker6,1)
		AND
		StartDialog_Internal(_Dialog,0,_Speaker1,_Speaker2,_Speaker3,_Speaker4,_Speaker5,_Speaker6,1)
		THEN
		Proc_DialogFlagSetup((STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2, (GUIDSTRING)_Speaker3, (GUIDSTRING)_Speaker4, (GUIDSTRING)_Speaker5, (GUIDSTRING)_Speaker6);
		
		QRY
		QRY_StartDialog(0,(STRING)_Dialog,(GUIDSTRING)_Speaker1)
		AND
		QRY_SpeakerIsAvailable(_Speaker1)
		AND
		QRY_PrepForInteractiveDialog(_Speaker1)
		AND
		StartDialog_Internal(_Dialog,1,_Speaker1,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,1)
		THEN
		Proc_DialogFlagSetup((STRING)_Dialog,(GUIDSTRING)_Speaker1);
		CharacterMakeStoryNpc((CHARACTERGUID)_Speaker1,1);
		ProcItemSetInvulnerableForDialog(_Speaker1);
		
		QRY
		QRY_StartDialog(0,(STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2)
		AND
		QRY_SpeakerIsAvailable(_Speaker1)
		AND
		QRY_SpeakerIsAvailable(_Speaker2)
		AND
		QRY_PrepForInteractiveDialog(_Speaker1)
		AND
		QRY_PrepForInteractiveDialog(_Speaker2)
		AND
		StartDialog_Internal(_Dialog,1,_Speaker1,_Speaker2,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,1)
		THEN
		Proc_DialogFlagSetup((STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2);
		ProcFaceCharacter(_Speaker1,_Speaker2);
		ProcFaceCharacter(_Speaker2,_Speaker1);
		ProcItemSetInvulnerableForDialog(_Speaker1);
		ProcItemSetInvulnerableForDialog(_Speaker2);
		CharacterMakeStoryNpc((CHARACTERGUID)_Speaker1,1);
		CharacterMakeStoryNpc((CHARACTERGUID)_Speaker2,1);
		DB_HasMetCharactersToCheck(_Speaker1,_Speaker2);
		
		QRY
		QRY_StartDialog(0,(STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2,(GUIDSTRING)_Speaker3)
		AND
		QRY_SpeakerIsAvailable(_Speaker1)
		AND
		QRY_SpeakerIsAvailable(_Speaker2)
		AND
		QRY_SpeakerIsAvailable(_Speaker3)
		AND
		QRY_PrepForInteractiveDialog(_Speaker1)
		AND
		QRY_PrepForInteractiveDialog(_Speaker2)
		AND
		QRY_PrepForInteractiveDialog(_Speaker3)
		AND
		StartDialog_Internal(_Dialog,1,_Speaker1,_Speaker2,_Speaker3,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,1)
		THEN
		Proc_DialogFlagSetup((STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2, (GUIDSTRING)_Speaker3);
		ProcFaceCharacter(_Speaker1,_Speaker3);
		ProcFaceCharacter(_Speaker2,_Speaker3);
		ProcFaceCharacter(_Speaker3,_Speaker1);
		ProcItemSetInvulnerableForDialog(_Speaker1);
		ProcItemSetInvulnerableForDialog(_Speaker2);
		ProcItemSetInvulnerableForDialog(_Speaker3);
		CharacterMakeStoryNpc((CHARACTERGUID)_Speaker1,1);
		CharacterMakeStoryNpc((CHARACTERGUID)_Speaker2,1);
		CharacterMakeStoryNpc((CHARACTERGUID)_Speaker3,1);
		DB_HasMetCharactersToCheck(_Speaker1,_Speaker2);
		DB_HasMetCharactersToCheck(_Speaker1,_Speaker3);
		
		
		QRY
		QRY_StartDialog(0,(STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2,(GUIDSTRING)_Speaker3,(GUIDSTRING)_Speaker4)
		AND
		QRY_SpeakerIsAvailable(_Speaker1)
		AND
		QRY_SpeakerIsAvailable(_Speaker2)
		AND
		QRY_SpeakerIsAvailable(_Speaker3)
		AND
		QRY_SpeakerIsAvailable(_Speaker4)
		AND
		QRY_PrepForInteractiveDialog(_Speaker1)
		AND
		QRY_PrepForInteractiveDialog(_Speaker2)
		AND
		QRY_PrepForInteractiveDialog(_Speaker3)
		AND
		QRY_PrepForInteractiveDialog(_Speaker4)
		AND
		StartDialog_Internal(_Dialog,1,_Speaker1,_Speaker2,_Speaker3,_Speaker4,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,1)
		THEN
		Proc_DialogFlagSetup((STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2, (GUIDSTRING)_Speaker3, (GUIDSTRING)_Speaker4);
		ProcFaceCharacter(_Speaker1,_Speaker4);
		ProcFaceCharacter(_Speaker2,_Speaker4);
		ProcFaceCharacter(_Speaker3,_Speaker4);
		ProcFaceCharacter(_Speaker4,_Speaker1);
		ProcItemSetInvulnerableForDialog(_Speaker1);
		ProcItemSetInvulnerableForDialog(_Speaker2);
		ProcItemSetInvulnerableForDialog(_Speaker3);
		ProcItemSetInvulnerableForDialog(_Speaker4);
		CharacterMakeStoryNpc((CHARACTERGUID)_Speaker1,1);
		CharacterMakeStoryNpc((CHARACTERGUID)_Speaker2,1);
		CharacterMakeStoryNpc((CHARACTERGUID)_Speaker3,1);
		CharacterMakeStoryNpc((CHARACTERGUID)_Speaker4,1);
		DB_HasMetCharactersToCheck(_Speaker1,_Speaker2);
		DB_HasMetCharactersToCheck(_Speaker1,_Speaker3);
		DB_HasMetCharactersToCheck(_Speaker1,_Speaker4);
		
		
		QRY
		QRY_StartDialog(0,(STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2,(GUIDSTRING)_Speaker3,(GUIDSTRING)_Speaker4,(GUIDSTRING)_Speaker5)
		AND
		QRY_SpeakerIsAvailable(_Speaker1)
		AND
		QRY_SpeakerIsAvailable(_Speaker2)
		AND
		QRY_SpeakerIsAvailable(_Speaker3)
		AND
		QRY_SpeakerIsAvailable(_Speaker4)
		AND
		QRY_SpeakerIsAvailable(_Speaker5)
		AND
		QRY_PrepForInteractiveDialog(_Speaker1)
		AND
		QRY_PrepForInteractiveDialog(_Speaker2)
		AND
		QRY_PrepForInteractiveDialog(_Speaker3)
		AND
		QRY_PrepForInteractiveDialog(_Speaker4)
		AND
		QRY_PrepForInteractiveDialog(_Speaker5)
		AND
		StartDialog_Internal(_Dialog,1,_Speaker1,_Speaker2,_Speaker3,_Speaker4,_Speaker5,NULL_00000000-0000-0000-0000-000000000000,1)
		THEN
		Proc_DialogFlagSetup((STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2, (GUIDSTRING)_Speaker3, (GUIDSTRING)_Speaker4, (GUIDSTRING)_Speaker5);
		ProcFaceCharacter(_Speaker1,_Speaker5);
		ProcFaceCharacter(_Speaker2,_Speaker5);
		ProcFaceCharacter(_Speaker3,_Speaker5);
		ProcFaceCharacter(_Speaker4,_Speaker5);
		ProcFaceCharacter(_Speaker5,_Speaker1);
		ProcItemSetInvulnerableForDialog(_Speaker1);
		ProcItemSetInvulnerableForDialog(_Speaker2);
		ProcItemSetInvulnerableForDialog(_Speaker3);
		ProcItemSetInvulnerableForDialog(_Speaker4);
		ProcItemSetInvulnerableForDialog(_Speaker5);
		CharacterMakeStoryNpc((CHARACTERGUID)_Speaker1,1);
		CharacterMakeStoryNpc((CHARACTERGUID)_Speaker2,1);
		CharacterMakeStoryNpc((CHARACTERGUID)_Speaker3,1);
		CharacterMakeStoryNpc((CHARACTERGUID)_Speaker4,1);
		CharacterMakeStoryNpc((CHARACTERGUID)_Speaker5,1);
		DB_HasMetCharactersToCheck(_Speaker1,_Speaker2);
		DB_HasMetCharactersToCheck(_Speaker1,_Speaker3);
		DB_HasMetCharactersToCheck(_Speaker1,_Speaker4);
		DB_HasMetCharactersToCheck(_Speaker1,_Speaker5);
		
		QRY
		QRY_StartDialog(0,(STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2,(GUIDSTRING)_Speaker3,(GUIDSTRING)_Speaker4,(GUIDSTRING)_Speaker5,(GUIDSTRING)_Speaker6)
		AND
		QRY_SpeakerIsAvailable(_Speaker1)
		AND
		QRY_SpeakerIsAvailable(_Speaker2)
		AND
		QRY_SpeakerIsAvailable(_Speaker3)
		AND
		QRY_SpeakerIsAvailable(_Speaker4)
		AND
		QRY_SpeakerIsAvailable(_Speaker5)
		AND
		QRY_SpeakerIsAvailable(_Speaker6)
		AND
		QRY_PrepForInteractiveDialog(_Speaker1)
		AND
		QRY_PrepForInteractiveDialog(_Speaker2)
		AND
		QRY_PrepForInteractiveDialog(_Speaker3)
		AND
		QRY_PrepForInteractiveDialog(_Speaker4)
		AND
		QRY_PrepForInteractiveDialog(_Speaker5)
		AND
		QRY_PrepForInteractiveDialog(_Speaker6)
		AND
		StartDialog_Internal(_Dialog,1,_Speaker1,_Speaker2,_Speaker3,_Speaker4,_Speaker5,_Speaker6,1)
		THEN
		Proc_DialogFlagSetup((STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2, (GUIDSTRING)_Speaker3, (GUIDSTRING)_Speaker4, (GUIDSTRING)_Speaker5, (GUIDSTRING)_Speaker6);
		ProcFaceCharacter(_Speaker1,_Speaker6);
		ProcFaceCharacter(_Speaker2,_Speaker6);
		ProcFaceCharacter(_Speaker3,_Speaker6);
		ProcFaceCharacter(_Speaker4,_Speaker6);
		ProcFaceCharacter(_Speaker5,_Speaker6);
		ProcFaceCharacter(_Speaker6,_Speaker1);
		ProcItemSetInvulnerableForDialog(_Speaker1);
		ProcItemSetInvulnerableForDialog(_Speaker2);
		ProcItemSetInvulnerableForDialog(_Speaker3);
		ProcItemSetInvulnerableForDialog(_Speaker4);
		ProcItemSetInvulnerableForDialog(_Speaker5);
		ProcItemSetInvulnerableForDialog(_Speaker6);
		CharacterMakeStoryNpc((CHARACTERGUID)_Speaker1,1);
		CharacterMakeStoryNpc((CHARACTERGUID)_Speaker2,1);
		CharacterMakeStoryNpc((CHARACTERGUID)_Speaker3,1);
		CharacterMakeStoryNpc((CHARACTERGUID)_Speaker4,1);
		CharacterMakeStoryNpc((CHARACTERGUID)_Speaker5,1);
		CharacterMakeStoryNpc((CHARACTERGUID)_Speaker6,1);
		DB_HasMetCharactersToCheck(_Speaker1,_Speaker2);
		DB_HasMetCharactersToCheck(_Speaker1,_Speaker3);
		DB_HasMetCharactersToCheck(_Speaker1,_Speaker4);
		DB_HasMetCharactersToCheck(_Speaker1,_Speaker5);
		DB_HasMetCharactersToCheck(_Speaker1,_Speaker6);
		
		QRY
		QRY_PrepForInteractiveDialog((GUIDSTRING)_Speaker)
		THEN
		DialogRequestStop(_Speaker);
		//END_REGION
		
		//REGION Setting Items in Dialog Invulnerable 
		PROC
		ProcItemSetInvulnerableForDialog((GUIDSTRING)_Speaker)
		AND
		ObjectIsItem(_Speaker,1)
		THEN
		SetInvulnerable_UseProcSetInvulnerable(_Speaker,1);
		//END_REGION
		
		//REGION Flags Set Up The Start Of Dialog
		PROC
		Proc_DialogFlagSetup((STRING)_Dialog,(GUIDSTRING)_Speaker1)
		THEN
		DB_NOOP(1);
		
		PROC
		Proc_DialogFlagSetup((STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2)
		THEN
		DB_NOOP(1);
		
		PROC
		Proc_DialogFlagSetup((STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2,(GUIDSTRING)_Speaker3)
		THEN
		DB_NOOP(1);
		
		PROC
		Proc_DialogFlagSetup((STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2,(GUIDSTRING)_Speaker3,(GUIDSTRING)_Speaker4)
		THEN
		DB_NOOP(1);
		
		PROC
		Proc_DialogFlagSetup((STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2,(GUIDSTRING)_Speaker3,(GUIDSTRING)_Speaker4,(GUIDSTRING)_Speaker5)
		THEN
		DB_NOOP(1);
		
		PROC
		Proc_DialogFlagSetup((STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2,(GUIDSTRING)_Speaker3,(GUIDSTRING)_Speaker4,(GUIDSTRING)_Speaker5,(GUIDSTRING)_Speaker6)
		THEN
		DB_NOOP(1);
		//END_REGION
		
		IF	
		DialogEnded(_,_Inst)
		THEN
		DB_MarkedForDelete(_Inst);
		ProcClearDialogFlagsForPlayers(_Inst);
		ProcClearDialogFlagsForNPCs(_Inst);
		
		//REGION Animal Food Dialogs
		PROC
		ProcSetAnimalFoodEvents((CHARACTERGUID)_Player,_)
		THEN
		SetVarInteger(_Player,"GEN_HasAnimalFood",0);
		
		PROC
		ProcSetAnimalFoodEvents((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc)
		AND
		DB_AnimalFoodVars(_Var)
		AND
		GetVarFixedString(_Npc,_Var,_TempVal)
		AND
		_TempVal!="DONTEAT"
		AND
		QryItemTemplateInMagicPockets(_Player,_tempVal)
		THEN
		SetVarInteger(_Player,"GEN_HasAnimalFood",1);
		
		PROC
		ProcGiveAnimalFood((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc)
		AND
		DB_AnimalFoodVars(_Var)
		AND
		GetVarFixedString(_Npc,_Var,_TempVal)
		AND
		_TempVal!="DONTEAT"
		AND
		NOT DB_FoodGiven(_Player)
		AND
		QryRemoveItemTemplateFromMagicPockets(_Player,_TempVal,1)
		THEN
		DB_FoodGiven(_Player);
		CharacterAddAttitudeTowardsPlayer(_Npc,_Player,5);
		
		PROC
		ProcGiveAnimalFood(_Player,_Npc)
		THEN
		NOT DB_FoodGiven(_Player);
		
		IF
		ObjectFlagSet("GEN_PlayerGivesFood",_Player,_Inst)
		AND
		DB_DialogNPCs(_Inst,_Npc,1)
		THEN
		ProcGiveAnimalFood((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc);
		//END_REGION
		
		//REGION Dialogs that must not be interceptable by custom scripts
		//END_REGION
		
		//REGION Custom global overrides
		PROC
		PROC_GLOBAL_DialogCustomOverride((GUIDSTRING)_Npc,(GUIDSTRING)_Player)
		THEN
		DB_NOOP(1);
		
		PROC
		SelectAndStartDialog((GUIDSTRING)_Player,(GUIDSTRING)_Npc) 
		THEN
		PROC_GLOBAL_DialogCustomOverride(_Npc,_Player);
		
		//END_REGION
		
		//REGION Custom script dialog Intercepts
		PROC
		PROC_GLOBAL_DialogStartRequested((GUIDSTRING)_Npc,(GUIDSTRING)_Player)
		THEN
		DB_NOOP(1);
		
		PROC
		SelectAndStartDialog((GUIDSTRING)_Player,(GUIDSTRING)_Npc) 
		AND
		NOT DB_FoundDialog(_Npc,_Player)
		THEN
		// Reverse order of parameters to be consisted with DialogStartRequested()
		PROC_GLOBAL_DialogStartRequested(_Npc,_Player);
		//END_REGION
		
		//REGION Hostile Dialog
		PROC
		StartHostileDialog((GUIDSTRING)_Player,(GUIDSTRING)_Npc)
		AND
		IsTagged(_Npc,"ANIMAL",1)
		THEN
		DB_FoundDialog(_Npc,_Player);
		ProcSetAnimalFoodEvents((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc);
		Proc_StartDialog(0,"GEB_Default_AnimalHostile",_Npc,_Player); //TODO Change this Dialog to a new Style Dialog
		
		PROC
		StartHostileDialog((GUIDSTRING)_Player,(GUIDSTRING)_Npc)
		AND
		IsTagged(_Npc,"ANIMAL",0)
		THEN
		StartHostileDialog_1(_Player,_Npc);
		
		PROC
		StartHostileDialog_1((GUIDSTRING)_Player,(GUIDSTRING)_Npc)
		AND
		DB_HostileDialog(_Npc,(STRING)_Dialog)
		THEN
		DB_FoundDialog(_Npc,_Player);
		Proc_StartDialog(0,_Dialog,_Npc,_Player);
		
		PROC
		StartHostileDialog_1((GUIDSTRING)_Player,(GUIDSTRING)_Npc)
		AND
		NOT DB_FoundDialog(_Npc,_Player)
		THEN
		DB_FoundDialog(_Npc,_Player);
		Proc_StartDialog(0,"GEB_Default_Hostile",_Npc,_Player);
		//END_REGION
		
		//REGION Companion Redirects & ADs
		PROC
		SelectAndStartDialog((GUIDSTRING)_Player,(GUIDSTRING)_OtherPlayer) 
		AND
		NOT DB_FoundDialog(_OtherPlayer,_Player)
		AND
		DB_IsPlayer((CHARACTERGUID)_Player)
		AND
		DB_IsPlayer((CHARACTERGUID)_OtherPlayer)
		AND
		CharacterGetReservedUserID(_Player,_PID)
		AND
		CharacterGetReservedUserID(_OtherPlayer,_OPID)
		AND
		_PID != _OPID
		THEN
		Proc_StartDialog(1,"GLO_AD_CompanionCantTalk",_OtherPlayer);
		DB_FoundDialog(_OtherPlayer,_Player);
		
		PROC
		SelectAndStartDialog((GUIDSTRING)_Player,(GUIDSTRING)_OtherPlayer) 
		AND
		NOT DB_FoundDialog(_OtherPlayer,_Player)
		AND
		DB_IsPlayer((CHARACTERGUID)_Player)
		AND
		DB_IsPlayer((CHARACTERGUID)_OtherPlayer)
		AND
		IsTagged(_Player,"AVATAR",0)
		AND
		IsTagged(_OtherPlayer,"AVATAR",0)
		AND
		DB_CompanionAvatarBond(_OtherPlayer,_Avatar)
		AND
		IsTagged(_Avatar,"AVATAR",1)
		AND
		CharacterGetReservedUserID(_Avatar,_PID)
		AND
		CharacterGetReservedUserID(_OtherPlayer,_PID)
		AND
		QRY_SpeakerIsAvailableAndInDialogRange(_Avatar,_OtherPlayer)
		THEN
		SelectAndStartDialog(_Avatar,_OtherPlayer);
		MakePlayerActive(_Avatar);
		DB_FoundDialog(_OtherPlayer,_Player);
		
		PROC
		SelectAndStartDialog((GUIDSTRING)_Player,(GUIDSTRING)_OtherPlayer) 
		AND
		NOT DB_FoundDialog(_OtherPlayer,_Player)
		AND
		DB_IsPlayer((CHARACTERGUID)_Player)
		AND
		DB_IsPlayer((CHARACTERGUID)_OtherPlayer)
		AND
		IsTagged(_Player,"AVATAR",0)
		AND
		IsTagged(_OtherPlayer,"AVATAR",0)
		THEN
		Proc_StartDialog(1,"GLO_AD_CompanionCantTalk",_OtherPlayer);
		DB_FoundDialog(_OtherPlayer,_Player);
		
		PROC
		SelectAndStartDialog((GUIDSTRING)_Player,(GUIDSTRING)_OtherPlayer) 
		AND
		NOT DB_FoundDialog(_OtherPlayer,_Player)
		AND
		DB_IsPlayer((CHARACTERGUID)_Player)
		AND
		DB_IsPlayer((CHARACTERGUID)_OtherPlayer)
		AND
		ObjectGetFlag(_OtherPlayer,"GLO_Polymorphed",1)
		THEN
		Proc_StartDialog(1,"GLO_AD_CompanionCantTalk",_OtherPlayer);
		DB_FoundDialog(_OtherPlayer,_Player);
		
		PROC
		SelectAndStartDialog((GUIDSTRING)_Player,(GUIDSTRING)_Companion) 
		AND
		NOT DB_FoundDialog(_Companion,_Player)
		AND
		DB_GLO_PartyMembers_RecruiteeAvatarBond((CHARACTERGUID)_Companion,(CHARACTERGUID)_Player2)
		AND
		_Player != _Player2
		THEN
		Proc_StartDialog(0,"GLO_NonBondedCompanionDialog",_Companion,_Player);
		DB_FoundDialog(_Companion,_Player);
		
		PROC
		SelectAndStartDialog((GUIDSTRING)_Player,(GUIDSTRING)_Companion) 
		AND
		NOT DB_FoundDialog(_Companion,_Player)
		AND
		DB_RelationshipDialogs((CHARACTERGUID)_Companion,_Dialog)
		AND
		DB_CompanionAvatarBond((CHARACTERGUID)_Companion,(CHARACTERGUID)_Player)
		AND
		QRY_StartDialog(0,_Dialog,_Companion,_Player)
		THEN
		NOT DB_RelationshipDialogs(_Companion,_Dialog);
		DB_FoundDialog(_Companion,_Player);
		
		PROC
		SelectAndStartDialog((GUIDSTRING)_Player,(GUIDSTRING)_Npc) 
		AND
		IsTagged(_NPC,"ANIMAL",0)
		AND
		NOT DB_FoundDialog(_Npc,_Player)
		AND
		CharacterGetAttitudeTowardsPlayer((CHARACTERGUID)_Npc,(CHARACTERGUID)_Player,_Att)
		AND
		_Att <= -45
		AND
		NOT _Npc.DB_IsPlayer()
		AND
		NOT DB_NoLowAttitudeDialog(_Npc)
		THEN
		StartHostileDialog(_Player,_Npc);
		DB_FoundDialog(_Npc,_Player);
		//END_REGION
		
		//REGION Threatened Dialog
		PROC
		SelectAndStartDialog((GUIDSTRING)_Player,(GUIDSTRING)_NPC)
		AND
		NOT DB_FoundDialog(_NPC,_Player)
		AND
		CharacterIsInFightMode((CHARACTERGUID)_Player,1)
		AND
		NOT DB_IsPlayer((CHARACTERGUID)_NPC)
		AND
		NOT DB_BlockThreatenedDialog(_NPC)
		AND
		IsTagged(_NPC,"ANIMAL",0)
		AND
		NOT DB_CombatCharacters(_Player,_)
		THEN
		StartThreatenedDialog(_NPC,_Player);
		
		PROC 
		StartThreatenedDialog((GUIDSTRING)_NPC,(GUIDSTRING)_Player)
		AND
		CharacterCanTrade((CHARACTERGUID)_NPC,_CanTrade)
		THEN
		DB_FoundDialog(_NPC,_Player);
		Proc_StartDialog(0,"GEB_Warning_Weapons_StartDialog",_NPC,_Player);
		CharacterSetCanTrade(_NPC,0);
		DB_CouldTrade(_NPC,_CanTrade);
		
		IF
		DialogEnded("GEB_Warning_Weapons_StartDialog",_Inst)
		AND
		DB_DialogNPCs(_Inst,_NPC,1)
		AND
		DB_CouldTrade((CHARACTERGUID)_NPC,_CanTrade)
		THEN
		NOT DB_CouldTrade(_NPC,_CanTrade);
		CharacterSetCanTrade((CHARACTERGUID)_NPC,_CanTrade);
		
		//END_REGION
		
		//REGION Script intercept after generics
		PROC
		PROC_GLOBAL_DialogStartRequested_AfterGenerics((GUIDSTRING)_Npc,(GUIDSTRING)_Player)
		THEN
		DB_NOOP(1);
		
		PROC
		SelectAndStartDialog((GUIDSTRING)_Player,(GUIDSTRING)_Npc) 
		AND 
		NOT DB_FoundDialog(_Npc,_Player) 
		THEN
		PROC_GLOBAL_DialogStartRequested_AfterGenerics(_Npc,_Player);
		//END_REGION
		
		//REGION Dialog Start by clicking on NPC
		PROC	
		SelectAndStartDialog((GUIDSTRING)_Player,(GUIDSTRING)_Npc) 
		AND 
		NOT DB_FoundDialog(_Npc,_Player) 
		THEN
		DB_FoundDialog(_Npc,_Player);
		NPCDialogStartRequested(_Npc,_Player);// start the default dialog
		
		PROC
		SelectAndStartDialog((GUIDSTRING)_Player,(GUIDSTRING)_Npc) 
		THEN
		NOT DB_FoundDialog(_Npc,_Player);
		
		IF	
		DialogStartRequested(_Npc2,_Npc1)
		AND
		QRY_SpeakerIsAvailable(_Npc1)
		AND
		QRY_SpeakerIsAvailable(_Npc2)
		THEN
		SelectAndStartDialog(_Npc1,_Npc2);
		
		//END_REGION
		
		IF
		CharacterDying(_Char)
		THEN
		DialogRequestStop(_Char);
		
		IF
		CharacterUnlockedTalent(_Char,"AnimalEmpathy")
		THEN
		SetTag(_char,"PETPAL");
		
		IF
		CharacterLockedTalent(_Char,"AnimalEmpathy")
		THEN
		ClearTag(_char,"PETPAL");
		
		IF
		DB_IsPlayer(_Char)
		AND
		CharacterHasTalent(_Char,"AnimalEmpathy",1)
		THEN
		SetTag(_char,"PETPAL");
		
		IF
		CharacterCreationFinished(_Char)
		AND
		_Char != NULL_00000000-0000-0000-0000-000000000000
		AND
		CharacterHasTalent(_Char,"AnimalEmpathy",0)
		THEN
		ClearTag(_char,"PETPAL");
		
		//REGION Child dialogs
		IF
		ChildDialogRequested(_ChildDialog,_ParentInstance,_TargetInstance)
		AND
		DB_DialogPlayers(_ParentInstance,_Player,1)
		THEN
		ProcStartChildDialog(_ChildDialog,_ParentInstance,_TargetInstance);
		
		PROC
		ProcStartChildDialog((STRING)_ChildDialog,(INTEGER)_ParentInstance,(INTEGER)_TargetInstance)
		THEN
		DB_TargetInstancespeakers(_TargetInstance,1,(CHARACTERGUID)NULL_00000000-0000-0000-0000-000000000000);
		DB_TargetInstancespeakers(_TargetInstance,2,(CHARACTERGUID)NULL_00000000-0000-0000-0000-000000000000);
		DB_TargetInstancespeakers(_TargetInstance,3,(CHARACTERGUID)NULL_00000000-0000-0000-0000-000000000000);
		DB_TargetInstancespeakers(_TargetInstance,4,(CHARACTERGUID)NULL_00000000-0000-0000-0000-000000000000);
		
		PROC
		ProcStartChildDialog((STRING)_ChildDialog,(INTEGER)_ParentInstance,(INTEGER)_TargetInstance)
		AND
		DB_DialogNumPlayers(_ParentInstance,_NumPlayers)
		AND
		DB_DialogNumNPCs(_ParentInstance,_NumNPCs)
		AND
		IntegerSum(_NumPlayers,_NumNPCs,_Total)
		AND
		_Total > 4
		THEN
		DebugBreak("too many speakers to fit in the child dialog! Need custom scripting and/or extension on speaker limit");
		
		PROC
		ProcStartChildDialog(_,(INTEGER)_ParentInstance,(INTEGER)_TargetInstance)
		AND
		DB_DialogNPCs(_ParentInstance,_NPC,_Index)
		THEN
		NOT DB_TargetInstancespeakers(_TargetInstance,_Index,NULL_00000000-0000-0000-0000-000000000000);
		DB_TargetInstancespeakers(_TargetInstance,_Index,(CHARACTERGUID)_NPC);
		
		PROC
		ProcStartChildDialog(_,(INTEGER)_ParentInstance,(INTEGER)_TargetInstance)
		AND
		DB_DialogPlayers(_ParentInstance,_Player,_Index)
		AND
		DB_DialogNumNPCs(_ParentInstance,_NumNPCs)
		AND
		IntegerSum(_NumNPCs,_Index,_PlayerIndex)
		THEN
		NOT DB_TargetInstancespeakers(_TargetInstance,_PlayerIndex,NULL_00000000-0000-0000-0000-000000000000);
		DB_TargetInstancespeakers(_TargetInstance,_PlayerIndex,(CHARACTERGUID)_Player);
		
		PROC
		ProcStartChildDialog(_ChildDialog,(INTEGER)_ParentInstance,(INTEGER)_TargetInstance)
		AND
		DB_TargetInstancespeakers(_TargetInstance,1,_Speaker1)
		AND
		DB_TargetInstancespeakers(_TargetInstance,2,_Speaker2)
		AND
		DB_TargetInstancespeakers(_TargetInstance,3,_Speaker3)
		AND
		DB_TargetInstancespeakers(_TargetInstance,4,_Speaker4)
		AND
		DialogStartChildDialog(_ChildDialog,_ParentInstance,_TargetInstance,_Speaker1,_Speaker2,_Speaker3,_Speaker4,_)
		THEN
		DB_NOOP(1);
		
		PROC
		ProcStartChildDialog(_ChildDialog,(INTEGER)_ParentInstance,(INTEGER)_TargetInstance)
		AND
		DB_TargetInstancespeakers(_TargetInstance,_Index,_Speaker)
		THEN
		NOT DB_TargetInstancespeakers(_TargetInstance,_Index,_Speaker);
		//END_REGION
		
	}
	EXIT
	{
		
	}
}
Goal(4).Title("__GLOBAL_ExplorationBonus");
Goal(4)
{
	INIT
	{
		
	}
	KB
	{
		IF
		DB_ExplorationZones((TRIGGERGUID)_Trigger,(INTEGER)_Act,(INTEGER)_ActPArt,(INTEGER)_Gain)
		AND
		NOT DB_Subregion(_Trigger,_,_) //Subregions can give XP without being Oneshot
		THEN
		ProcTriggerRegisterForPlayers(_Trigger);
		
		IF
		CharacterEnteredTrigger((CHARACTERGUID)_Player,(TRIGGERGUID)_Trigger)
		AND
		DB_ExplorationZones(_Trigger,(INTEGER)_Act,(INTEGER)_ActPart,(INTEGER)_Gain)
		THEN
		ProcAddXPToParty(_Player,_Trigger);
		ProcCheckRemoveExplorationZone(_Trigger);
		
		
		PROC
		ProcAddXPToParty((CHARACTERGUID)_Player,(TRIGGERGUID)_Trigger)
		AND
		DB_ExplorationZones(_Trigger,_Act,_ActPart,_Gain)
		AND
		DB_IsPlayer(_OtherPlayer)
		AND
		NOT DB_ExplorationXPGiven(_OtherPlayer,_Trigger)
		AND
		CharacterIsInPartyWith(_OtherPlayer,_Player,1)
		THEN
		DB_ExplorationXPGiven(_OtherPlayer,_Trigger);
		CharacterAddExplorationExperience(_OtherPlayer,_Act,_ActPart,_Gain);
		
		//Dont unregister if also a Subregion
		IF
		DB_ExplorationXPGiven(_OtherPlayer,_Trigger)
		AND
		NOT DB_Subregion(_Trigger,_,_)
		THEN
		TriggerUnregisterForCharacter(_Trigger,_OtherPlayer);
		
		PROC
		ProcCheckRemoveExplorationZone((TRIGGERGUID)_Trigger)
		AND
		DB_IsPlayer(_Player)
		AND
		NOT DB_ExplorationXPGiven(_Player,_Trigger)
		THEN
		DB_ExplorationZoneStillOpen(1);
		
		PROC
		ProcCheckRemoveExplorationZone(_Trigger)
		AND
		NOT DB_ExplorationZoneStillOpen(1)
		AND
		DB_ExplorationZones(_Trigger,_Act,_ActPart,_Gain)
		THEN
		NOT DB_ExplorationZones(_Trigger,_Act,_ActPart,_Gain);
		
		PROC
		ProcCheckRemoveExplorationZone(_Trigger)
		THEN
		NOT DB_ExplorationZoneStillOpen(1);
		
		IF
		CharacterJoinedParty(_Char)
		AND
		DB_ExplorationZones(_Trigger,_Act,_ActPart,_Gain)
		AND
		DB_ExplorationXPGiven(_Player,_Trigger)
		AND
		CharacterIsInPartyWith(_Player,_Char,1)
		THEN
		DB_ExplorationXPGiven(_Char,_Trigger);
		ProcCheckRemoveExplorationZone(_Trigger);
		
	}
	EXIT
	{
		
	}
}
Goal(5).Title("__GLOBAL_HiddenWalls");
Goal(5)
{
	INIT
	{
		DB_HiddenWallCount(0);
		
	}
	KB
	{
		//REGION Use event to open hidden wall
		
		IF
		GlobalFlagSet(_flag)
		AND
		DB_HiddenWallEvent((STRING)_flag, (INTEGER)_wallIndex)
		THEN
		PROC_OpenWall(_WallIndex);
		
		//END_REGION
		
		//REGION Action When Player Uses Item To Open Wall
		
		IF
		CharacterUsedItem(_Player, _Item)
		AND
		_Player.DB_IsPlayer()
		AND
		DB_HiddenWallItem((ITEMGUID)_Item, (INTEGER)_WallIndex)
		THEN
		PROC_CommentHiddenEffect(_Player);
		PROC_OpenWall(_WallIndex);
		
		//END_REGION
		
		//REGION Action When Player Uses Trigger To Open Wall
		
		IF
		DB_HiddenWallTrigger(_trigger, _)
		THEN
		DB_HW_CharCountInTrigger(_trigger, 0);
		
		IF
		CharacterEnteredTrigger(_, _trigger)
		AND
		DB_HiddenWallTrigger((TRIGGERGUID)_trigger, (INTEGER)_wallIndex)
		AND
		DB_HW_CharCountInTrigger(_trigger, _current)
		AND
		IntegerSum(_current, 1, _new)
		THEN
		NOT DB_HW_CharCountInTrigger(_trigger, _current);
		DB_HW_CharCountInTrigger(_trigger, _new);
		
		IF
		CharacterLeftTrigger(_, _trigger)
		AND
		DB_HiddenWallTrigger((TRIGGERGUID)_trigger, (INTEGER)_wallIndex)
		AND
		DB_HW_CharCountInTrigger(_trigger, _current)
		AND
		IntegerSubtract(_current, 1, _new)
		THEN
		NOT DB_HW_CharCountInTrigger(_trigger, _current);
		DB_HW_CharCountInTrigger(_trigger, _new);
		
		IF
		DB_HW_CharCountInTrigger(_trigger, _current)
		AND
		_current < 0
		THEN
		NOT DB_HW_CharCountInTrigger(_trigger, _current);
		DB_HW_CharCountInTrigger(_trigger, 0);
		
		IF
		DB_HW_CharCountInTrigger(_trigger, _current)
		AND
		_current > 0
		AND
		DB_HiddenWallTrigger(_trigger, _wallIndex)
		THEN
		PROC_OpenWall(_wallIndex);
		
		IF
		DB_HW_CharCountInTrigger(_trigger, _current)
		AND
		_current == 0
		AND
		DB_HiddenWallTrigger(_trigger, _wallIndex)
		THEN
		PROC_CloseWall(_wallIndex);
		
		
		//END_REGION
		
		//REGION Action When Player Uses Skills To Open Wall
		
		IF
		StoryEvent(_Wall, "Open")
		AND
		DB_HiddenWall(_WallIndex, (ITEMGUID)_Wall)
		THEN
		PROC_OpenWall(_WallIndex);
		
		//END_REGION
		
		//REGION Registering all the hidden walls 
		
		PROC
		PROC_Register_HiddenWall((ITEMGUID)_Wall)
		AND
		NOT DB_HiddenWall(_, (ITEMGUID)_Wall)
		AND
		DB_HiddenWallCount(_Current)
		AND
		IntegerSum(_Current, 1, _New)
		THEN
		NOT DB_HiddenWallCount(_Current);
		DB_HiddenWallCount(_New);
		DB_HiddenWall((INTEGER)_New, (ITEMGUID)_Wall);
		DB_HW_ClosedWalls(_New);
		
		//END_REGION
		
		//REGION Open/Close Hidden walls
		
		PROC
		PROC_OpenWall((INTEGER)_WallIndex)
		AND
		DB_HW_ClosedWalls(_WallIndex)
		AND
		DB_HiddenWall(_WallIndex, _Wall)
		THEN
		NOT DB_HW_ClosedWalls(_WallIndex);
		PlayEffect(_Wall, "RS3_FX_GP_ScriptedEvent_Teleport_GenericSmoke_01");
		SetOnStage(_Wall, 0);
		
		PROC
		PROC_CloseWall((INTEGER)_WallIndex)
		AND
		NOT DB_HW_ClosedWalls(_WallIndex)
		AND
		DB_HiddenWall(_WallIndex, _Wall)
		THEN
		DB_HW_ClosedWalls(_WallIndex);
		PlayEffect(_Wall, "RS3_FX_GP_ScriptedEvent_Teleport_GenericSmoke_01");
		SetOnStage(_Wall, 1);
		
		//END_REGION
		
	}
	EXIT
	{
		
	}
}
Goal(6).Title("__GLOBAL_ItemInteraction");
Goal(6)
{
	INIT
	{
		
	}
	KB
	{
		IF
		CharacterUsedItemTemplate(_Player, _Template, _)
		AND
		_Player.DB_IsPlayer()
		AND
		DB_RecipeBook(_Template, (STRING)_ID)
		THEN
		UnlockJournalRecipe(_ID);
		NOT DB_RecipeBook(_Template, _ID);
		
		PROC
		Proc_ItemRotateYduration((ITEMGUID)_Item,(REAL)_Angle,(INTEGER)_DurationMS)
		AND
		RealProduct(_Angle,1000.0,_AngleProd)
		AND
		Real(_DurationMS,_DurationReal)
		AND
		RealDivide(_AngleProd,_DurationReal,_Speed)
		THEN
		ItemRotateY(_Item,_Angle,_Speed);
		
		PROC
		Proc_ItemRotateToAngleYduration((ITEMGUID)_Item,(REAL)_Angle,(INTEGER)_DurationMS)
		AND
		RealProduct(_Angle,1000.0,_AngleProd)
		AND
		Real(_DurationMS,_DurationReal)
		AND
		RealDivide(_AngleProd,_DurationReal,_Speed)
		THEN
		ItemRotateY(_Item,_Angle,_Speed);
		
	}
	EXIT
	{
		
	}
}
Goal(7).Title("__GLOBAL_ItemRotationPuzzles");
Goal(7)
{
	INIT
	{
		DB_IRP_Internal_IndexCount(0);
		
	}
	KB
	{
		//REGION Initialization of databases
		
		PROC
		PROC_Puzzle_RegisterRotatingItem((STRING)_puzzleName, (ITEMGUID)_item, (INTEGER)_solution)
		AND
		DB_IRP_Internal_IndexCount(_index)
		THEN
		DB_IRP_IncreaseInternalCount();
		DB_IRP_Internal_Items((INTEGER)_index, (ITEMGUID)_item, 0);
		DB_IRP_Internal_Solutions((INTEGER)_index, (INTEGER)_solution);
		DB_IRP_Internal_Puzzles((STRING)_puzzleName, (INTEGER)_index, 0);
		PROC_IRP_Internal_IncreasePuzzleItemcount(_puzzleName);
		
		PROC
		DB_IRP_IncreaseInternalCount()
		AND
		DB_IRP_Internal_IndexCount(_indexCount)
		AND
		IntegerSum(_indexCount, 1, _newIndex)
		THEN
		NOT DB_IRP_Internal_IndexCount(_indexCount);
		DB_IRP_Internal_IndexCount(_newIndex);
		
		PROC
		PROC_ItemRotatePuzzle_AddItemToHandle((ITEMGUID)_handle, (ITEMGUID)_item)
		AND
		DB_IRP_Internal_Items(_index, _item, _)
		THEN
		DB_IRP_Internal_Handles(_handle, _index);
		
		PROC
		PROC_IRP_Internal_IncreasePuzzleItemcount((STRING)_puzzleName)
		AND
		NOT DB_IRP_Internal_PuzzlesTotalItemCount(_puzzleName, _)
		THEN
		DB_IRP_Internal_PuzzlesTotalItemCount(_puzzleName, 0);
		DB_IRP_Internal_PuzzlesItemsSolved(_puzzleName, 0);
		
		PROC
		PROC_IRP_Internal_IncreasePuzzleItemcount((STRING)_puzzleName)
		AND
		DB_IRP_Internal_PuzzlesTotalItemCount(_puzzleName, _count)
		AND
		IntegerSum(_count, 1, _newTotal)
		THEN
		NOT DB_IRP_Internal_PuzzlesTotalItemCount(_puzzleName, _count);
		DB_IRP_Internal_PuzzlesTotalItemCount(_puzzleName, _newTotal);
		
		//END_REGION
		
		
		//REGION Rotate items
		
		IF
		CharacterUsedItem(_player, _handle)
		AND
		_player.DB_IsPlayer()
		AND
		DB_IRP_Internal_Handles(_handle, _index)
		AND
		DB_IRP_Internal_Items(_index, _item, _)
		THEN
		PROC_IRP_RotateItem(_item);
		
		IF
		CharacterUsedItem(_player, _item)
		AND
		_player.DB_IsPlayer()
		AND
		DB_IRP_Internal_Items(_index, _item, _)
		THEN
		PROC_IRP_RotateItem(_item);
		
		PROC
		PROC_IRP_RotateItem((ITEMGUID)_item)
		AND
		DB_IRP_Internal_Items(_index, _item, _turnCount)
		AND
		DB_IRP_Internal_Puzzles(_puzzleName, _index, _)
		AND
		IntegerSum(_turnCount, 1, _newTurnCount)
		THEN
		NOT DB_IRP_Internal_Items(_index, _item, _turnCount);
		DB_IRP_Internal_Items(_index, _item, _newTurnCount);
		ItemRotateY(_item, 90.0, 135.0);
		PROC_IRP_CheckItemState(_item);
		PROC_IRP_CheckPuzzleState(_puzzleName);
		
		IF
		DB_IRP_Internal_Items(_index, _item, 4)
		THEN
		NOT DB_IRP_Internal_Items(_index, _item, 4);
		DB_IRP_Internal_Items(_index, _item, 0);
		
		//END_REGION
		
		//REGION Check for item solution
		
		PROC
		PROC_IRP_CheckItemState((ITEMGUID)_item)
		AND
		DB_IRP_Internal_Items(_index, _item, _turnCount)
		AND
		DB_IRP_Internal_Puzzles(_puzzleName, _index, 0)
		AND
		DB_IRP_Internal_Solutions(_index, _solution)
		AND
		_turnCount == _solution
		THEN 
		NOT DB_IRP_Internal_Puzzles(_puzzleName, _index, 0);
		DB_IRP_Internal_Puzzles(_puzzleName, _index, 1);
		
		PROC
		PROC_IRP_CheckItemState((ITEMGUID)_item)
		AND
		DB_IRP_Internal_Items(_index, _item, _turnCount)
		AND
		DB_IRP_Internal_Puzzles(_puzzleName, _index, 1)
		AND
		DB_IRP_Internal_Solutions(_index, _solution)
		AND
		NOT _turnCount == _solution
		THEN 
		NOT DB_IRP_Internal_Puzzles(_puzzleName, _index, 1);
		DB_IRP_Internal_Puzzles(_puzzleName, _index, 0);
		
		//END_REGION
		
		//REGION Check for puzzle solution
		
		PROC
		PROC_IRP_CheckPuzzleState((STRING)_puzzleName)
		AND
		DB_IRP_Internal_Puzzles(_puzzleName, _, 1)
		AND
		DB_IRP_Internal_PuzzlesItemsSolved(_puzzleName, _count)
		AND
		IntegerSum(_count, 1, _new)
		THEN
		NOT DB_IRP_Internal_PuzzlesItemsSolved(_puzzleName, _count);
		DB_IRP_Internal_PuzzlesItemsSolved(_puzzleName, _new);
		
		PROC
		PROC_IRP_CheckPuzzleState((STRING)_puzzleName)
		AND
		DB_IRP_Internal_PuzzlesItemsSolved(_puzzleName, _itemsSolved)
		AND
		NOT DB_IRP_Internal_PuzzlesTotalItemCount(_puzzleName, _itemsSolved)
		THEN
		NOT DB_IRP_Internal_PuzzlesItemsSolved(_puzzleName, _itemsSolved);
		DB_IRP_Internal_PuzzlesItemsSolved(_puzzleName, 0);
		GlobalClearFlag(_puzzleName);
		
		PROC
		PROC_IRP_CheckPuzzleState((STRING)_puzzleName)
		AND
		DB_IRP_Internal_PuzzlesItemsSolved(_puzzleName, _itemsSolved)
		AND
		DB_IRP_Internal_PuzzlesTotalItemCount(_puzzleName, _itemsSolved)
		THEN
		NOT DB_IRP_Internal_PuzzlesItemsSolved(_puzzleName, _itemsSolved);
		DB_IRP_Internal_PuzzlesItemsSolved(_puzzleName, 0);
		GlobalSetFlag(_puzzleName);
		
		//END_REGION
		
		
	}
	EXIT
	{
		
	}
}
Goal(8).Title("__OneshotDialogs");
Goal(8)
{
	INIT
	{
		
	}
	KB
	{
		//REGION One Shot Normal Dialogs
		IF
		DB_OneShot_PlayerOnlyDialogTrigger((TRIGGERGUID)_Trigger,(STRING)_Dialog,(CHARACTERGUID)_NPC)
		THEN
		DB_OneShotPlayerOnlyTrigger(_Trigger);
		DB_OneShot_DialogSpeakerCount(_Trigger,_Dialog,1);
		DB_OneShot_DialogSpeakers(_Trigger,_Npc,1);
		
		IF
		DB_OneShot_DialogTrigger((TRIGGERGUID)_Trigger,(STRING)_Dialog,(CHARACTERGUID)_NPC)
		THEN
		DB_OneShotPlayerTrigger(_Trigger);
		DB_OneShot_DialogSpeakerCount(_Trigger,_Dialog,1);
		DB_OneShot_DialogSpeakers(_Trigger,_Npc,1);
		
		IF
		DB_OneShot_DialogTrigger((TRIGGERGUID)_Trigger,(STRING)_Dialog,(CHARACTERGUID)_NPC,(CHARACTERGUID)_NPC2)
		THEN
		DB_OneShotPlayerTrigger(_Trigger);
		DB_OneShot_DialogSpeakerCount(_Trigger,_Dialog,2);
		DB_OneShot_DialogSpeakers(_Trigger,_Npc,1);
		DB_OneShot_DialogSpeakers(_Trigger,_Npc2,2);
		
		IF
		DB_OneShot_DialogTrigger((TRIGGERGUID)_Trigger,(STRING)_Dialog,(CHARACTERGUID)_NPC,(CHARACTERGUID)_NPC2,(CHARACTERGUID)_NPC3)
		THEN
		DB_OneShotPlayerTrigger(_Trigger);
		DB_OneShot_DialogSpeakerCount(_Trigger,_Dialog,3);
		DB_OneShot_DialogSpeakers(_Trigger,_Npc,1);
		DB_OneShot_DialogSpeakers(_Trigger,_Npc2,2);
		DB_OneShot_DialogSpeakers(_Trigger,_Npc3,3);
		
		IF
		DB_OneShot_DialogTrigger((TRIGGERGUID)_Trigger,(STRING)_Dialog,(CHARACTERGUID)_NPC,(CHARACTERGUID)_NPC2,(CHARACTERGUID)_NPC3,(CHARACTERGUID)_NPC4)
		THEN
		DB_OneShotPlayerTrigger(_Trigger);
		DB_OneShot_DialogSpeakerCount(_Trigger,_Dialog,4);
		DB_OneShot_DialogSpeakers(_Trigger,_Npc,1);
		DB_OneShot_DialogSpeakers(_Trigger,_Npc2,2);
		DB_OneShot_DialogSpeakers(_Trigger,_Npc3,3);
		DB_OneShot_DialogSpeakers(_Trigger,_Npc4,4);
		
		PROC
		ProcCheckIfNPCsBusy((TRIGGERGUID)_Trigger)
		AND
		DB_OneShot_DialogSpeakers(_Trigger,_Npc,_)
		AND
		NOT QRY_SpeakerIsAvailable(_Npc,1)
		THEN
		DB_OneShot_BusyNPC(_Trigger);
		
		PROC
		ProcDoStartOneShotDialog((CHARACTERGUID)_Player,(TRIGGERGUID)_Trigger)
		AND
		DB_OneShot_DialogSpeakerCount(_Trigger,_Dialog,1)
		AND
		DB_OneShot_DialogSpeakers(_Trigger,_Npc,1)
		THEN
		Proc_StartDialog(0,_Dialog,_Npc,_Player);
		
		PROC
		ProcDoStartOneShotDialog((CHARACTERGUID)_Player,(TRIGGERGUID)_Trigger)
		AND
		DB_OneShot_DialogSpeakerCount(_Trigger,_Dialog,2)
		AND
		DB_OneShot_DialogSpeakers(_Trigger,_Npc,1)
		AND
		DB_OneShot_DialogSpeakers(_Trigger,_Npc2,2)
		THEN
		Proc_StartDialog(0,_Dialog,_Npc,_Npc2,_Player);
		
		PROC
		ProcDoStartOneShotDialog((CHARACTERGUID)_Player,(TRIGGERGUID)_Trigger)
		AND
		DB_OneShot_DialogSpeakerCount(_Trigger,_Dialog,3)
		AND
		DB_OneShot_DialogSpeakers(_Trigger,_Npc,1)
		AND
		DB_OneShot_DialogSpeakers(_Trigger,_Npc2,2)
		AND
		DB_OneShot_DialogSpeakers(_Trigger,_Npc3,3)
		THEN
		Proc_StartDialog(0,_Dialog,_Npc,_Npc2,_Npc3,_Player);
		
		PROC
		ProcStartOneShotDialog((CHARACTERGUID)_Player,(TRIGGERGUID)_Trigger)
		AND
		NOT DB_OneShot_BusyNPC(_Trigger)
		THEN
		ProcDoStartOneShotDialog(_Player,_Trigger);
		
		PROC
		ProcClearOneShotCount((TRIGGERGUID)_Trigger)
		AND
		DB_OneShot_DialogSpeakerCount(_Trigger,_Dialog,1)
		AND
		DB_OneShot_DialogTrigger((TRIGGERGUID)_Trigger,(STRING)_Dialog,(CHARACTERGUID)_NPC)
		THEN
		NOT DB_OneShot_DialogTrigger(_Trigger,_Dialog,_NPC);
		
		PROC
		ProcClearOneShotCount((TRIGGERGUID)_Trigger)
		AND
		DB_OneShot_DialogSpeakerCount(_Trigger,_Dialog,2)
		AND
		DB_OneShot_DialogTrigger((TRIGGERGUID)_Trigger,(STRING)_Dialog,(CHARACTERGUID)_NPC,(CHARACTERGUID)_NPC2)
		THEN
		NOT DB_OneShot_DialogTrigger(_Trigger,_Dialog,_NPC,_NPC2);
		
		PROC
		ProcClearOneShotCount((TRIGGERGUID)_Trigger)
		AND
		DB_OneShot_DialogSpeakerCount(_Trigger,_Dialog,3)
		AND
		DB_OneShot_DialogTrigger((TRIGGERGUID)_Trigger,(STRING)_Dialog,(CHARACTERGUID)_NPC,(CHARACTERGUID)_NPC2,(CHARACTERGUID)_NPC3)
		THEN
		NOT DB_OneShot_DialogTrigger(_Trigger,_Dialog,_NPC,_NPC2,_NPC3);
		
		
		PROC
		ProcClearOneShotCount((TRIGGERGUID)_Trigger)
		AND
		DB_OneShot_DialogSpeakerCount(_Trigger,_Dialog,4)
		AND
		DB_OneShot_DialogTrigger((TRIGGERGUID)_Trigger,(STRING)_Dialog,(CHARACTERGUID)_NPC,(CHARACTERGUID)_NPC2,(CHARACTERGUID)_NPC3,(CHARACTERGUID)_NPC4)
		THEN
		NOT DB_OneShot_DialogTrigger(_Trigger,_Dialog,_NPC,_NPC2,_NPC3,_NPC4);
		
		PROC
		ProcClearOneShotCount((TRIGGERGUID)_Trigger)
		AND
		DB_OneShot_DialogSpeakerCount(_Trigger,_Dialog,_Count)
		THEN
		NOT DB_OneShot_DialogSpeakerCount(_Trigger,_Dialog,_Count);
		
		PROC
		ProcClearOneShotSpeakers((TRIGGERGUID)_Trigger)
		AND
		DB_OneShot_DialogSpeakers(_Trigger,_Npc,_Count)
		THEN
		NOT DB_OneShot_DialogSpeakers(_Trigger,_Npc,_Count);
		
		PROC
		ProcOneShotDialogCleanup((TRIGGERGUID)_Trigger)
		THEN
		ProcClearOneShotCount(_Trigger);
		ProcClearOneShotSpeakers(_Trigger);
		
		PROC
		RemoveOneShotDialog((TRIGGERGUID)_Trigger)
		THEN
		ProcOneShotDialogCleanup(_Trigger);
		ProcTriggerUnregisterForPlayers(_Trigger);
		NOT DB_OneShotPlayerTrigger(_Trigger);
		
		IF
		DB_Dead(_Npc)
		AND
		DB_OneShot_DialogSpeakers(_Trigger,_Npc,_)
		THEN
		RemoveOneShotDialog(_Trigger);
		
		PROC
		ProcOneShotTriggerEntered((CHARACTERGUID)_Player,(TRIGGERGUID)_Trigger)
		AND
		DB_OneShot_DialogSpeakerCount(_Trigger,_,_)
		AND
		QRY_SpeakerIsAvailable(_Player)
		THEN
		ProcCheckIfNPCsBusy(_Trigger); //TODO: do this busy check? Dialogs won't ever start if one of these NPCs is busy
		ProcStartOneShotDialog(_Player,_Trigger);
		
		PROC
		ProcStartOneShotDialog(_,(TRIGGERGUID)_Trigger)
		THEN
		NOT DB_OneShot_BusyNPC(_Trigger);
		
		PROC
		ProcStartOneShotDialog(_,(TRIGGERGUID)_Trigger)
		THEN
		ProcOneShotDialogCleanup(_Trigger);
		
		//if the dialog is started (manually), cleanup so this doesn't get started again
		IF
		DialogStarted(_Dialog,_)
		AND
		DB_OneShot_DialogSpeakerCount(_Trigger,_Dialog,_Count)
		THEN
		ProcOneShotDialogCleanup(_Trigger);
		ProcTriggerUnregisterForPlayers(_Trigger);
		NOT DB_OneShotPlayerTrigger(_Trigger); //because this might not have triggerd yet and we don't want to leave these around
		
		//END_REGION
		
		//REGION One Shot Automated Dialogs
		
		IF
		DB_OneShot_ADTrigger((TRIGGERGUID)_Trigger,(STRING)_Dialog,(CHARACTERGUID)_NPC)
		THEN
		DB_OneShotPlayerTrigger(_Trigger);
		DB_OneShot_ADSpeakerCount(_Trigger,_Dialog,1);
		DB_OneShot_ADSpeakers(_Trigger,_Npc,1);
		
		IF
		DB_OneShot_ADTrigger((TRIGGERGUID)_Trigger,(STRING)_Dialog,(CHARACTERGUID)_NPC,(CHARACTERGUID)_NPC2)
		THEN
		DB_OneShotPlayerTrigger(_Trigger);
		DB_OneShot_ADSpeakerCount(_Trigger,_Dialog,2);
		DB_OneShot_ADSpeakers(_Trigger,_Npc,1);
		DB_OneShot_ADSpeakers(_Trigger,_Npc2,2);
		
		PROC
		ProcDoStartOneShotAD((CHARACTERGUID)_Player,(TRIGGERGUID)_Trigger)
		AND
		DB_OneShot_ADSpeakerCount(_Trigger,_Dialog,1)
		AND
		DB_OneShot_ADSpeakers(_Trigger,_Npc,1)
		THEN
		Proc_StartDialog(1,_Dialog,_Npc);
		
		PROC
		ProcDoStartOneShotAD((CHARACTERGUID)_Player,(TRIGGERGUID)_Trigger)
		AND
		DB_OneShot_ADSpeakerCount(_Trigger,_Dialog,2)
		AND
		DB_OneShot_ADSpeakers(_Trigger,_Npc,1)
		AND
		DB_OneShot_ADSpeakers(_Trigger,_Npc2,2)
		THEN
		Proc_StartDialog(1,_Dialog,_Npc,_Npc2);
		
		PROC
		ProcClearOneShotADCount((TRIGGERGUID)_Trigger)
		AND
		DB_OneShot_ADSpeakerCount(_Trigger,_Dialog,1)
		AND
		DB_OneShot_ADTrigger((TRIGGERGUID)_Trigger,(STRING)_Dialog,(CHARACTERGUID)_NPC)
		THEN
		NOT DB_OneShot_ADTrigger(_Trigger,_Dialog,_NPC);
		
		PROC
		ProcClearOneShotADCount((TRIGGERGUID)_Trigger)
		AND
		DB_OneShot_ADSpeakerCount(_Trigger,_Dialog,2)
		AND
		DB_OneShot_ADTrigger((TRIGGERGUID)_Trigger,(STRING)_Dialog,(CHARACTERGUID)_NPC,(CHARACTERGUID)_NPC2)
		THEN
		NOT DB_OneShot_ADTrigger(_Trigger,_Dialog,_NPC,_NPC2);
		
		PROC
		ProcClearOneShotADSpeakers((TRIGGERGUID)_Trigger)
		AND
		DB_OneShot_ADSpeakers(_Trigger,_Npc,_Count)
		THEN
		NOT DB_OneShot_ADSpeakers(_Trigger,_Npc,_Count);
		
		PROC
		ProcOneShotADCleanup((TRIGGERGUID)_Trigger)
		THEN
		ProcClearOneShotADCount(_Trigger);
		ProcClearOneShotADSpeakers(_Trigger);
		
		PROC
		RemoveOneShotAD((TRIGGERGUID)_Trigger)
		THEN
		ProcOneShotADCleanup(_Trigger);
		ProcTriggerUnregisterForPlayers(_Trigger);
		NOT DB_OneShotPlayerTrigger(_Trigger);
		
		IF
		DB_Dead(_Npc)
		AND
		DB_OneShot_ADSpeakers(_Trigger,_Npc,_)
		THEN
		RemoveOneShotAD(_Trigger);
		
		PROC
		ProcOneShotTriggerEntered((CHARACTERGUID)_Player,(TRIGGERGUID)_Trigger)
		AND
		DB_OneShot_ADSpeakerCount(_Trigger,_,_)
		AND
		DB_OneShot_ADSpeakers(_Trigger,_Npc,1)
		AND
		QRY_SpeakerIsAvailable(_Player)
		AND
		QRY_SpeakerIsAvailable(_Npc)
		THEN
		ProcDoStartOneShotAD(_Player,_Trigger);
		ProcOneShotADCleanup(_Trigger);
		
		//if the dialog is started (manually), cleanup so this doesn't get started again
		IF
		AutomatedDialogStarted(_Dialog,_)
		AND
		DB_OneShot_ADSpeakerCount(_Trigger,_Dialog,_Count)
		THEN
		ProcOneShotADCleanup(_Trigger);
		ProcTriggerUnregisterForPlayers(_Trigger);
		
		//END_REGION
		
		//REGION One Shot Voice Bark
		
		IF
		DB_OneShot_VoiceBarkTrigger((TRIGGERGUID)_Trigger,(STRING)_VoiceBark)
		THEN
		DB_OneShotPlayerTrigger(_Trigger);
		
		PROC
		ProcOneShotTriggerEntered(_Player,_Trigger)
		AND
		DB_OneShot_VoiceBarkTrigger(_Trigger,_VoiceBark)
		AND
		QRY_SpeakerIsAvailable(_Player)
		THEN
		StartVoiceBark(_VoiceBark,_Player);
		
		IF
		VoiceBarkStarted(_VoiceBark,_)
		AND
		DB_OneShot_VoiceBarkTrigger(_Trigger,_VoiceBark)
		THEN
		NOT DB_OneShot_VoiceBarkTrigger(_Trigger,_VoiceBark);
		
		IF
		VoiceBarkFailed(_VoiceBark)
		AND
		DB_OneShot_VoiceBarkTrigger(_Trigger,_VoiceBark)
		THEN
		NOT DB_OneShot_VoiceBarkTrigger(_Trigger,_VoiceBark);
		
		//END_REGION
		
	}
	EXIT
	{
		
	}
}
Goal(9).Title("__PROC");
Goal(9)
{
	INIT
	{
		DB_InternalGroup_Count(0);
		
		
	}
	KB
	{
		PROC
		CharacterGiveReward((CHARACTERGUID)_Player,(STRING)_Reward)
		THEN
		CharacterGiveReward(_Player,_Reward,1);
		
		//REGION Defaults for item adding
		PROC
		ItemTemplateAddTo((STRING)_ItemTemplate, (GUIDSTRING)_Object, (INTEGER)_Count)
		THEN
		ItemTemplateAddTo(_ItemTemplate,_Object,_Count,1);
		
		PROC
		ItemToInventory((ITEMGUID)_Item,(GUIDSTRING)_Container)
		THEN
		ItemToInventory(_Item,_Container,1,1,1);
		
		PROC
		ItemToInventory((ITEMGUID)_Item, (GUIDSTRING)_TargetObject, (INTEGER)_Amount)
		THEN
		ItemToInventory(_Item, _TargetObject, _Amount, 1, 1);
		
		PROC
		ItemToInventory((ITEMGUID)_Item, (GUIDSTRING)_TargetObject, (INTEGER)_Amount, (INTEGER)_ShowNotification)
		THEN
		ItemToInventory(_Item, _TargetObject, _Amount, _ShowNotification, 1);
		
		//END_REGION
		
		//REGION Follow logic 
		PROC
		ProcCharacterFollowCharacter((CHARACTERGUID)_Char,(CHARACTERGUID)_Target)
		THEN
		ProcCharacterStopFollow(_Char);
		DB_Following(_Char,_Target);
		CharacterFollowCharacter(_Char,_Target);
		
		PROC
		ProcCharacterStopFollow((CHARACTERGUID)_Char)
		AND
		CharacterIsDead(_Char,0)
		THEN
		CharacterStopFollow(_Char);
		
		PROC
		ProcCharacterStopFollow((CHARACTERGUID)_Char)
		AND
		DB_Following(_Char,_Target)
		THEN
		NOT DB_Following(_Char,_Target);
		
		IF
		CharacterDying(_Char)
		THEN
		ProcCharacterStopFollow(_Char);
		
		IF
		ObjectEnteredCombat((CHARACTERGUID)_Obj,_)
		AND
		DB_Following(_Obj,_)
		THEN
		CharacterStopFollow(_Obj);
		
		IF
		ObjectLeftCombat((CHARACTERGUID)_Obj,_)
		AND
		DB_Following(_Obj,_Target)
		THEN
		CharacterFollowCharacter(_Obj,_Target);
		
		//END_REGION
		
		IF
		DB_DoNotFace((GUIDSTRING)_Char)
		THEN
		CharacterSetDoNotFaceFlag((CHARACTERGUID)_Char,1);
		DB_CheckDoNotFace(_Char);
		
		IF
		DB_CheckDoNotFace(_Char)
		AND
		NOT DB_DoNotFace(_Char)
		THEN
		CharacterSetDoNotFaceFlag((CHARACTERGUID)_Char,0);
		NOT DB_CheckDoNotFace(_Char);
		
		PROC
		ProcFaceCharacter((GUIDSTRING)_Char,(GUIDSTRING)_Target)
		AND
		NOT DB_DoNotFace(_Char)
		AND
		ObjectIsCharacter(_Char,1)
		AND
		CharacterIsIncapacitated((CHARACTERGUID)_Char,0)
		THEN
		CharacterLookAt((CHARACTERGUID)_Char,_Target,0);
		
		PROC
		ProcFaceEachother((GUIDSTRING)_Char,(GUIDSTRING)_Target)
		AND
		NOT DB_DoNotFace(_Char)
		AND
		ObjectIsCharacter(_Char,1)
		AND
		CharacterIsIncapacitated((CHARACTERGUID)_Char,0)
		THEN
		CharacterLookAt((CHARACTERGUID)_Char,_Target,0);
		
		PROC
		ProcFaceEachother((GUIDSTRING)_Char,(GUIDSTRING)_Target)
		AND
		NOT DB_DoNotFace(_Target)
		AND
		ObjectIsCharacter(_Target,1)
		AND
		CharacterIsIncapacitated((CHARACTERGUID)_Target,0)
		THEN
		CharacterLookAt((CHARACTERGUID)_Target,_Char,0);
		
		//REGION Internal Dialog Logic (Starting dialog by clicking on NPC)
		PROC
		ProcIncreaseInternalCount()
		AND
		DB_InternalGroup_Count(_Nr)
		AND
		IntegerSum(_Nr,1,_New)
		THEN
		NOT DB_InternalGroup_Count(_Nr);
		DB_InternalGroup_Count(_New);
		
		IF
		DB_Dialogs((GUIDSTRING)_Npc,(STRING)_Dialog)
		THEN
		SetHasDialog(_Npc,1);
		ProcIncreaseInternalCount();
		ProcInteralCounterEntry(_Npc,_Dialog);
		
		PROC
		ProcInteralCounterEntry((GUIDSTRING)_Npc,(STRING)_Dialog)
		AND
		DB_InternalGroup_Count(_New)
		THEN
		DB_InternalCounter(_New,_Dialog,1);
		DB_Internal_Dialogs(_Npc,_Dialog,_New,1);
		
		IF
		DB_Dialogs((GUIDSTRING)_Npc,(GUIDSTRING)_Npc2,(STRING)_Dialog)
		THEN
		SetHasDialog(_Npc,1);
		SetHasDialog(_Npc2,1);
		ProcIncreaseInternalCount();
		ProcInteralCounterEntry(_Npc,_Npc2,_Dialog);
		
		PROC
		ProcInteralCounterEntry((GUIDSTRING)_Npc,(GUIDSTRING)_Npc2,(STRING)_Dialog)
		AND
		DB_InternalGroup_Count(_Group)
		THEN
		DB_InternalCounter(_Group,_Dialog,2);
		DB_Internal_Dialogs(_Npc,_Dialog,_Group,1);
		DB_Internal_Dialogs(_Npc2,_Dialog,_Group,2);
		
		IF
		DB_Dialogs((GUIDSTRING)_Npc,(GUIDSTRING)_Npc2,(GUIDSTRING)_Npc3,(STRING)_Dialog)
		THEN
		SetHasDialog(_Npc,1);
		SetHasDialog(_Npc2,1);
		SetHasDialog(_Npc3,1);
		ProcIncreaseInternalCount();
		ProcInteralCounterEntry(_Npc,_Npc2,_Npc3,_Dialog);
		
		PROC
		ProcInteralCounterEntry((GUIDSTRING)_Npc,(GUIDSTRING)_Npc2,(GUIDSTRING)_Npc3,(STRING)_Dialog)
		AND
		DB_InternalGroup_Count(_Group)
		THEN
		DB_InternalCounter(_Group,_Dialog,3);
		DB_Internal_Dialogs(_Npc,_Dialog,_Group,1);
		DB_Internal_Dialogs(_Npc2,_Dialog,_Group,2);
		DB_Internal_Dialogs(_Npc3,_Dialog,_Group,3);
		
		IF
		DB_Dialogs((GUIDSTRING)_Npc,(GUIDSTRING)_Npc2,(GUIDSTRING)_Npc3,(GUIDSTRING)_Npc4,(STRING)_Dialog)
		THEN
		SetHasDialog(_Npc,1);
		SetHasDialog(_Npc2,1);
		SetHasDialog(_Npc3,1);
		SetHasDialog(_Npc4,1);
		ProcIncreaseInternalCount();
		ProcInteralCounterEntry(_Npc,_Npc2,_Npc3,_Npc4,_Dialog);
		
		PROC
		ProcInteralCounterEntry((GUIDSTRING)_Npc,(GUIDSTRING)_Npc2,(GUIDSTRING)_Npc3,(GUIDSTRING)_Npc4,(STRING)_Dialog)
		AND
		DB_InternalGroup_Count(_Group)
		THEN
		DB_InternalCounter(_Group,_Dialog,4);
		DB_Internal_Dialogs(_Npc,_Dialog,_Group,1);
		DB_Internal_Dialogs(_Npc2,_Dialog,_Group,2);
		DB_Internal_Dialogs(_Npc3,_Dialog,_Group,3);
		DB_Internal_Dialogs(_Npc4,_Dialog,_Group,4);
		
		PROC
		ProcStartNPCDialog((GUIDSTRING)_Player,(STRING)_Dialog,(INTEGER)_Group)
		AND
		DB_InternalCounter(_Group,_Dialog,1)
		AND
		DB_Internal_Dialogs(_Npc,_Dialog,_Group,1)
		THEN
		Proc_StartDialog(0,_Dialog,_Npc,_Player);
		
		PROC
		ProcStartNPCDialog((GUIDSTRING)_Player,(STRING)_Dialog,(INTEGER)_Group)
		AND
		DB_InternalCounter(_Group,_Dialog,2)
		AND
		DB_Internal_Dialogs(_Npc,_Dialog,_Group,1)
		AND
		DB_Internal_Dialogs(_Npc2,_Dialog,_Group,2)
		THEN
		Proc_StartDialog(0,_Dialog,_Npc,_Npc2,_Player);
		
		PROC
		ProcStartNPCDialog((GUIDSTRING)_Player,(STRING)_Dialog,(INTEGER)_Group)
		AND
		DB_InternalCounter(_Group,_Dialog,3)
		AND
		DB_Internal_Dialogs(_Npc,_Dialog,_Group,1)
		AND
		DB_Internal_Dialogs(_Npc2,_Dialog,_Group,2)
		AND
		DB_Internal_Dialogs(_Npc3,_Dialog,_Group,3)
		THEN
		Proc_StartDialog(0,_Dialog,_Npc,_Npc2,_Npc3,_Player);
		
		PROC
		ProcStartNPCDialog((GUIDSTRING)_Player,(STRING)_Dialog,(INTEGER)_Group)
		AND
		DB_InternalCounter(_Group,_Dialog,4)
		AND
		DB_Internal_Dialogs(_Npc,_Dialog,_Group,1)
		AND
		DB_Internal_Dialogs(_Npc2,_Dialog,_Group,2)
		AND
		DB_Internal_Dialogs(_Npc3,_Dialog,_Group,3)
		AND
		DB_Internal_Dialogs(_Npc4,_Dialog,_Group,4)
		THEN
		Proc_StartDialog(0,_Dialog,_Npc,_Npc2,_Npc3,_Npc4,_Player);
		
		
		PROC
		NPCDialogStartRequested((GUIDSTRING)_Npc,(GUIDSTRING)_Player)
		AND
		DB_Internal_Dialogs(_Npc,_Dialog,_Group,1)
		AND
		NOT DB_TempRequested(_NPC,_,_)
		THEN
		DB_TempRequested(_NPC,_Dialog,_Group);
		
		PROC
		NPCDialogStartRequested((GUIDSTRING)_Npc,(GUIDSTRING)_Player)
		AND
		DB_Internal_Dialogs(_Npc,_Dialog,_Group,_)
		AND
		NOT DB_TempRequested(_NPC,_,_)
		THEN
		DB_TempRequested(_NPC,_Dialog,_Group);
		
		PROC
		NPCDialogStartRequested((GUIDSTRING)_Npc,(GUIDSTRING)_Player)
		AND
		NOT DB_TempRequested(_NPC,_,_)
		AND
		QRY_SpeakerIsAvailable(_Npc)
		AND
		QRY_SpeakerIsAvailable(_Player)
		AND
		ObjectIsCharacter(_Npc,1)
		AND
		HasDefaultDialog((CHARACTERGUID)_Npc,1)
		THEN
		DialogRequestStop(_Npc);
		DialogRequestStop(_Player);
		ProcTryStartDefaultDialog(_Npc,(CHARACTERGUID)_Player);
		
		PROC
		NPCDialogStartRequested((GUIDSTRING)_Npc,(GUIDSTRING)_Player)
		AND
		DB_TempRequested(_NPC,_Dialog,_Group)
		THEN
		NOT DB_TempRequested(_NPC,_Dialog,_Group);
		ProcStartNPCDialog(_Player,_Dialog,_Group);
		
		PROC
		ProcTryStartDefaultDialog((CHARACTERGUID)_Npc,(CHARACTERGUID)_Player)
		AND
		StartDefaultDialog(_Npc,_Player,_Dialog,_Automated)
		THEN
		ProcHandleDefaultDialogSetting(_Npc,_Player,_Dialog,_Automated);
		
		PROC
		ProcHandleDefaultDialogSetting((CHARACTERGUID)_Npc,(CHARACTERGUID)_Player,(STRING)_Dialog,1)
		THEN
		ProcFaceCharacter(_Npc,_Player);
		Proc_DialogFlagSetup(_Dialog,_Npc,_Player);
		
		PROC
		ProcHandleDefaultDialogSetting((CHARACTERGUID)_Npc,(CHARACTERGUID)_Player,(STRING)_Dialog,0)
		THEN
		Proc_DialogFlagSetup(_Dialog,_Npc,_Player);
		ProcFaceCharacter(_Npc,_Player);
		ProcFaceCharacter(_Player,_Npc);
		ProcItemSetInvulnerableForDialog(_Npc);
		ProcItemSetInvulnerableForDialog(_Player);
		CharacterMakeStoryNpc(_Npc,1);
		CharacterMakeStoryNpc(_Player,1);
		DB_HasMetCharactersToCheck(_Npc,_Player);
		
		//END_REGION
		
		//REGION Internal Dialog Cleanup
		PROC
		ProcRemoveAllDialogEntriesForSpeaker((GUIDSTRING)_NPC)
		AND
		DB_Internal_Dialogs(_Npc,_Dialog,_Group,1)
		THEN
		ProcRemoveInternalDialogEntries(_Dialog,_Group);
		ProcRemoveExternalDialogEntry(_Npc,_Dialog,_Group);
		
		PROC
		ProcRemoveDialogEntryForSpeaker((GUIDSTRING)_NPC,(STRING)_Dialog)
		AND
		DB_Internal_Dialogs(_Npc,_Dialog,_Group,1)
		THEN
		ProcRemoveInternalDialogEntries(_Dialog,_Group);
		ProcRemoveExternalDialogEntry(_Npc,_Dialog,_Group);
		
		//remove dialogs when an NPC dies.
		IF
		DB_Dead((CHARACTERGUID)_Npc)
		AND
		NOT DB_KeepDialogsOnDeath(_Npc)
		AND
		DB_Internal_Dialogs(_Npc,_Dialog,_Group,_Nr)
		AND
		DB_Internal_Dialogs(_FirstSpeaker,_Dialog,_Group,1)
		THEN
		ProcRemoveDialogEntryForSpeaker(_FirstSpeaker,_Dialog);
		
		PROC
		ProcRemoveExternalDialogEntry((GUIDSTRING)_Npc,(STRING)_Dialog,(INTEGER)_Group)
		AND
		DB_InternalCounter(_Group,_Dialog,1)
		AND
		DB_Dialogs(_Npc,_Dialog)
		THEN
		NOT DB_Dialogs(_Npc,_Dialog);
		NOT DB_InternalCounter(_Group,_Dialog,1);
		
		PROC
		ProcRemoveExternalDialogEntry((GUIDSTRING)_Npc,(STRING)_Dialog,(INTEGER)_Group)
		AND
		DB_InternalCounter(_Group,_Dialog,2)
		AND
		DB_Dialogs(_Npc,_Npc2,_Dialog)
		THEN
		NOT DB_Dialogs(_Npc,_Npc2,_Dialog);
		NOT DB_InternalCounter(_Group,_Dialog,2);
		
		PROC
		ProcRemoveExternalDialogEntry((GUIDSTRING)_Npc,(STRING)_Dialog,(INTEGER)_Group)
		AND
		DB_InternalCounter(_Group,_Dialog,3)
		AND
		DB_Dialogs(_Npc,_Npc2,_Npc3,_Dialog)
		THEN
		NOT DB_Dialogs(_Npc,_Npc2,_Npc3,_Dialog);
		NOT DB_InternalCounter(_Group,_Dialog,3);
		
		PROC
		ProcRemoveExternalDialogEntry((GUIDSTRING)_Npc,(STRING)_Dialog,(INTEGER)_Group)
		AND
		DB_InternalCounter(_Group,_Dialog,4)
		AND
		DB_Dialogs(_Npc,_Npc2,_Npc3,_Npc4,_Dialog)
		THEN
		NOT DB_Dialogs(_Npc,_Npc2,_Npc3,_Npc4,_Dialog);
		NOT DB_InternalCounter(_Group,_Dialog,4);
		
		PROC
		ProcRemoveInternalDialogEntries((STRING)_Dialog,(INTEGER)_Group)
		AND
		DB_Internal_Dialogs(_Npc,_Dialog,_Group,_Nr)
		THEN
		NOT DB_Internal_Dialogs(_Npc,_Dialog,_Group,_Nr);
		//END_REGION
		
		//REGION Start Dialog with 1 Item 
		IF
		CharacterUsedItem(_Player,_Item)
		AND
		DB_Dialogs(_Item,_Dialog)
		AND
		DB_CombatCharacters(_Player, _)
		AND
		NOT DB_IgnoreCombatItems((ITEMGUID) _Item)
		THEN
		Proc_StartDialog(1,"GLO_AD_CannotUseNow", _Player);
		
		IF
		CharacterUsedItem(_Player,_Item)
		AND
		DB_Dialogs(_Item,_Dialog)
		AND
		NOT DB_CombatCharacters(_Player, _)
		THEN
		Proc_StartDialog(0,_Dialog,_Item,_Player);
		
		IF
		CharacterUsedItem(_Player,_Item)
		AND
		DB_Dialogs(_Item,_Dialog)
		AND
		DB_CombatCharacters(_Player, _)
		AND
		DB_IgnoreCombatItems((ITEMGUID) _Item)
		THEN
		Proc_StartDialog(0,_Dialog,_Item,_Player);
		
		// From item's GEN_ItemDialog behavior script we can start interactive dialogs (used for modders to start item dialogs without Osiris support)
		IF
		CharacterItemEvent(_Player,_Item,"GEN_StartItemDialog")
		AND
		NOT DB_Dialogs(_Item,_)
		AND
		DB_IsPlayer(_Player)
		AND
		NOT DB_CombatCharacters(_Player,_)
		AND
		GetVarString(_Item,"ItemDialog",_Dialog)
		THEN
		Proc_StartDialog(0,_Dialog,_Item,_Player);
		
		IF
		CharacterItemEvent(_Player,_Item,"GEN_StartItemDialog")
		AND
		NOT DB_Dialogs(_Item,_)
		AND
		DB_IsPlayer(_Player)
		AND
		DB_CombatCharacters(_Player,_)
		AND
		DB_IgnoreCombatItems((ITEMGUID)_Item)
		AND
		GetVarString(_Item,"ItemDialog",_Dialog)
		THEN
		Proc_StartDialog(0,_Dialog,_Item,_Player);
		//END_REGION
		
		
		//REGION Start Automated Dialog with 1 Item 
		IF
		CharacterUsedItem(_Char,_Item)
		AND
		DB_AD_Dialog(_Item,_Dialog)
		THEN
		Proc_StartDialog(1,_Dialog, _Item);
		//END_REGION
		
		//REGION Track Object Invulnerable (mainly used by itemdialogs setting items temporarily invulnerable)
		PROC
		ProcSetInvulnerable((GUIDSTRING)_Object,1)
		THEN
		DB_ObjectStoryInvulnerable(_Object);
		SetInvulnerable_UseProcSetInvulnerable(_Object,1);
		
		PROC
		ProcSetInvulnerable((GUIDSTRING)_Object,0)
		THEN
		NOT DB_ObjectStoryInvulnerable(_Object);
		SetInvulnerable_UseProcSetInvulnerable(_Object,0);
		//END_REGION
		
		//REGION Clear Involved NPCs in Dialog
		PROC
		ProcClearDialogFlagsForPlayers((INTEGER)_Instance)
		AND
		DB_DialogPlayers(_Instance,_Player,_Index)
		THEN
		ProcClearPlayerIfNotInOtherDialog(_Instance,_Player);
		
		PROC
		ProcClearPlayerIfNotInOtherDialog((INTEGER)_Inst,(GUIDSTRING)_Player)
		AND
		DB_DialogPlayers(_OtherInstance,_Player,_)
		AND
		_OtherInstance!=_Inst
		AND
		NOT DB_AutomatedDialog(_OtherInstance)
		AND
		NOT DB_MarkedForDelete(_OtherInstance)
		THEN
		DB_TempIsInOtherDialog(_Player,1);
		
		PROC
		ProcClearPlayerIfNotInOtherDialog((INTEGER)_Inst,(GUIDSTRING)_Player)
		AND
		NOT DB_TempIsInOtherDialog(_Player,1)
		THEN
		SetStoryNpcStatus((CHARACTERGUID)_Player);
		
		PROC
		ProcClearPlayerIfNotInOtherDialog((INTEGER)_Inst,(GUIDSTRING)_Player)
		AND
		NOT DB_TempIsInOtherDialog(_Player,1)
		AND
		NOT DB_ObjectStoryInvulnerable(_Player)
		THEN
		SetInvulnerable_UseProcSetInvulnerable(_Player,0);
		
		PROC
		ProcClearPlayerIfNotInOtherDialog((INTEGER)_Inst,(GUIDSTRING)_Player)
		THEN
		NOT DB_TempIsInOtherDialog(_Player,1);
		
		PROC
		ProcClearDialogFlagsForNPCs((INTEGER)_Instance)
		AND
		DB_DialogNPCs(_Instance,_Npc,_Index)
		THEN
		ProcClearNPCIfNotInOtherDialog(_Instance,_Npc);
		
		PROC
		ProcClearNPCIfNotInOtherDialog((INTEGER)_Inst,(GUIDSTRING)_Npc)
		AND
		DB_DialogNPCs(_OtherInstance,_Npc,_)
		AND
		_OtherInstance!=_Inst
		AND
		NOT DB_AutomatedDialog(_OtherInstance)
		AND
		NOT DB_MarkedForDelete(_OtherInstance)
		THEN
		DB_TempIsInOtherDialog(_Npc,1);
		
		PROC
		ProcClearNPCIfNotInOtherDialog((INTEGER)_Inst,(GUIDSTRING)_Npc)
		AND
		NOT DB_TempIsInOtherDialog(_Npc,1)
		THEN
		SetStoryNpcStatus((CHARACTERGUID)_Npc);
		
		PROC
		ProcClearNPCIfNotInOtherDialog((INTEGER)_Inst,(GUIDSTRING)_Npc)
		AND
		NOT DB_TempIsInOtherDialog(_Npc,1)
		AND
		NOT DB_ObjectStoryInvulnerable(_Npc)
		THEN
		SetInvulnerable_UseProcSetInvulnerable(_Npc,0);
		
		PROC
		ProcClearNPCIfNotInOtherDialog((INTEGER)_Inst,(GUIDSTRING)_Npc)
		THEN
		NOT DB_TempIsInOtherDialog(_Npc,1);
		
		//END_REGION
		
		//REGION Set Relation to Players
		PROC
		SetRelationFactionToPlayers((STRING)_Faction,(INTEGER)_Relation)
		THEN
		CharacterSetRelationFactionToFaction(_Faction,"Hero",_Relation);
		CharacterSetRelationFactionToFaction("Hero",_Faction,_Relation);
		CharacterSetRelationFactionToFaction(_Faction,"Companion",_Relation);
		CharacterSetRelationFactionToFaction("Companion",_Faction,_Relation);
		
		PROC
		SetRelationIndivFactionToPlayers((CHARACTERGUID)_Char,(INTEGER)_Relation)
		THEN
		CharacterSetRelationIndivFactionToFaction(_Char,"Hero",_Relation);
		CharacterSetRelationFactionToIndivFaction("Hero",_Char,_Relation);
		CharacterSetRelationIndivFactionToFaction(_Char,"Companion",_Relation);
		CharacterSetRelationFactionToIndivFaction("Companion",_Char,_Relation);
		
		PROC
		ProcSetRelationToPlayers((CHARACTERGUID)_Character,(INTEGER)_Relation)
		AND
		_Relation == 0
		AND
		GetFaction(_Character,_Faction)
		THEN
		SetFaction(_Character,"Evil NPC");
		DB_PreviousAlignment(_Character,_Faction);
		
		PROC
		ProcSetRelationToPlayers((CHARACTERGUID)_Character,(INTEGER)_Relation)
		AND
		_Relation == 100
		AND
		NOT DB_PreviousAlignment(_Character,_)
		AND
		GetFaction(_Character,_Faction)
		THEN
		CharacterSetRelationFactionToFaction(_Faction,"Hero",100);
		CharacterSetRelationFactionToFaction("Hero",_Faction,100);
		
		PROC
		ProcSetRelationToPlayers((CHARACTERGUID)_Character,(INTEGER)_Relation)
		AND
		DB_IsPlayer(_Player)
		AND
		_Relation == 100
		AND
		DB_PreviousAlignment(_Character,_Faction)
		THEN
		SetFaction(_Character,_Faction);
		CharacterSetRelationFactionToFaction(_Faction,"Hero",100);
		CharacterSetRelationFactionToFaction("Hero",_Faction,100);
		NOT DB_PreviousAlignment(_Character,_Faction);
		
		PROC
		ProcSetHostileToIndivPlayer((CHARACTERGUID)_Character,(CHARACTERGUID)_Player)
		THEN
		CharacterSetRelationIndivFactionToIndivFaction(_Character,_Player,0);
		CharacterSetRelationIndivFactionToIndivFaction(_Player,_Character,0);
		
		PROC
		ProcSetFactionHostileToIndivPlayer((STRING)_Faction,(CHARACTERGUID)_Player)
		THEN
		CharacterSetRelationFactionToIndivFaction(_Faction,_Player,0);
		CharacterSetRelationIndivFactionToFaction(_Player,_Faction,0);
		//END_REGION
		
		//REGION Change Attitude
		IF
		ObjectFlagSet("ChangeAttitude",_Player,_Instance)
		AND
		GetVarInteger(_Player,"ChangeAttitude",_Value)
		AND
		DB_DialogNPCs(_Instance,_Npc,1)
		THEN
		ObjectClearFlag(_Player,"ChangeAttitude",_Instance);
		CharacterAddAttitudeTowardsPlayer((CHARACTERGUID)_Npc,(CHARACTERGUID)_Player,_Value);
		
		PROC
		ChangeAttitude((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player,(INTEGER)_Value)
		THEN
		CharacterAddAttitudeTowardsPlayer(_Npc,_Player,_Value);
		//END_REGION
		
		//REGION Peace Timer
		PROC
		PROC_PeaceTimerLaunch((STRING)_TimerName,(INTEGER)_TimerLength)
		AND
		DB_CombatCharacters(_Player,_)
		AND
		DB_IsPlayer(_Player)
		AND
		NOT DB_PeaceTimer(_TimerName)
		THEN
		DB_PeaceTimer(_TimerName);
		DB_PeaceTimerStillToStart(_TimerName,_TimerLength);
		
		PROC
		PROC_PeaceTimerLaunch((STRING)_TimerName,(INTEGER)_TimerLength)
		AND
		NOT DB_PeaceTimer(_TimerName)
		THEN
		DB_PeaceTimer(_TimerName);
		TimerLaunch(_TimerName,_TimerLength);
		
		IF
		ObjectEnteredCombat((CHARACTERGUID)_Player,_)
		AND
		_Player.DB_IsPlayer()
		AND
		DB_PeaceTimer(_TimerName)
		THEN
		TimerPause(_TimerName);
		
		IF
		ObjectLeftCombat((CHARACTERGUID)_Player,_)
		AND
		_Player.DB_IsPlayer()
		AND
		DB_PeaceTimer(_TimerName)
		THEN
		ProcUnPausePeaceTimerIfNoPlayerInCombat(_TimerName);
		
		PROC
		ProcUnPausePeaceTimerIfNoPlayerInCombat((STRING)_TimerName)
		AND
		_Player.DB_IsPlayer()
		AND
		DB_CombatCharacters(_Player,_)
		THEN
		DB_PlayerInCombat(1);
		
		PROC
		ProcUnPausePeaceTimerIfNoPlayerInCombat((STRING)_TimerName)
		AND
		NOT DB_PlayerInCombat(1)
		AND
		NOT DB_PeaceTimerStillToStart(_TimerName,_)
		THEN
		TimerUnpause(_TimerName);
		
		PROC
		ProcUnPausePeaceTimerIfNoPlayerInCombat((STRING)_TimerName)
		AND
		NOT DB_PlayerInCombat(1)
		AND
		DB_PeaceTimerStillToStart(_TimerName,_TimerLength)
		THEN
		TimerLaunch(_TimerName,_TimerLength);
		NOT DB_PeaceTimerStillToStart(_TimerName,_TimerLength);
		
		PROC
		ProcUnPausePeaceTimerIfNoPlayerInCombat((STRING)_TimerName)
		THEN
		NOT DB_PlayerInCombat(1);
		IF
		TimerFinished(_TimerName)
		AND
		DB_PeaceTimer(_TimerName)
		THEN
		NOT DB_PeaceTimer(_TimerName);
		//END_REGION
		
		//REGION Doors
		PROC
		ItemCloseAndLock((ITEMGUID)_Item,(STRING)_Key)
		THEN
		ItemClose(_Item);
		ItemLock(_Item,_Key);
		
		PROC
		ItemUnlockAndOpen((ITEMGUID)_Item)
		THEN
		ItemUnLock(_Item);
		ItemOpen(_Item);
		//END_REGION
		
		//REGION  Automated dialogs
		IF
		DB_AD_Dialog((GUIDSTRING)_Char,(STRING)_)
		THEN
		SetHasDialog(_Char,1);
		
		IF
		DB_AD_Dialog((GUIDSTRING)_Char1,(GUIDSTRING)_Char2,(STRING)_)
		THEN
		SetHasDialog(_Char1,1);
		SetHasDialog(_Char2,1);
		
		PROC
		PROC_GLOBAL_DialogStartRequested((GUIDSTRING)_Char,(GUIDSTRING)_Player)
		AND
		DB_AD_Dialog(_Char,(STRING)_Dialog)
		AND
		NOT DB_ADRequested(_Char)
		AND
		QRY_StartDialog(1,_Dialog,_Char)
		THEN
		DB_ADRequested(_Char);
		DB_FoundDialog(_Char,_Player);
		
		PROC
		PROC_GLOBAL_DialogStartRequested((GUIDSTRING)_Char1,(GUIDSTRING)_Player)
		AND
		DB_AD_Dialog(_Char1,_Char2,(STRING)_Dialog)
		AND
		NOT DB_ADRequested(_Char1)
		AND
		NOT DB_ADRequested(_Char2)
		AND
		QRY_StartDialog(1,_Dialog,_Char1,_Char2)
		THEN
		DB_ADRequested(_Char1);
		DB_ADRequested(_Char2);
		DB_FoundDialog(_Char1,_Player);
		
		PROC
		PROC_GLOBAL_DialogStartRequested((GUIDSTRING)_Char2,(GUIDSTRING)_Player)
		AND
		DB_AD_Dialog(_Char1,_Char2,(STRING)_Dialog)
		AND
		NOT DB_ADRequested(_Char1)
		AND
		NOT DB_ADRequested(_Char2)
		AND
		QRY_StartDialog(1,_Dialog,_Char1,_Char2)
		THEN
		DB_ADRequested(_Char1);
		DB_ADRequested(_Char2);
		DB_FoundDialog(_Char2,_Player);
		
		IF
		AutomatedDialogEnded(_Dialog,_Inst)
		THEN
		ProcClearADRequests(_Dialog,_Inst);
		
		IF
		AutomatedDialogRequestFailed(_Dialog,_Inst)
		THEN
		ProcClearADRequests(_Dialog,_Inst);
		
		PROC
		ProcClearADRequests((STRING)_Dialog,(INTEGER)_Inst)
		AND
		DB_DialogNPCs(_Inst,_Npc,1)
		AND
		DB_AD_Dialog(_Npc,_Dialog)
		THEN
		NOT DB_ADRequested(_Npc);
		
		PROC
		ProcClearADRequests((STRING)_Dialog,(INTEGER)_Inst)
		AND
		DB_DialogPlayers(_Inst,_Player,1)
		AND
		DB_AD_Dialog(_Player,_Dialog)
		THEN
		NOT DB_ADRequested(_Player);
		
		PROC
		ProcClearADRequests((STRING)_Dialog,(INTEGER)_Inst)
		AND
		DB_DialogNPCs(_Inst,_Npc,_)
		AND
		DB_AD_Dialog(_,_,_Dialog)
		THEN
		NOT DB_ADRequested(_Npc);
		
		PROC
		ProcClearADRequests((STRING)_Dialog,(INTEGER)_Inst)
		AND
		DB_DialogPlayers(_Inst,_Player,1)
		AND
		DB_AD_Dialog(_,_,_Dialog)
		THEN
		NOT DB_ADRequested(_Player);
		
		PROC
		ProcRemoveNPCADs((GUIDSTRING)_Npc)
		AND
		DB_AD_Dialog(_Npc,_Dialog)
		THEN
		NOT DB_AD_Dialog(_Npc,_Dialog);
		NOT DB_ADRequested(_Npc);
		
		PROC
		ProcRemoveNPCADs((GUIDSTRING)_Npc)
		AND
		DB_AD_Dialog(_Npc,_Npc2,_Dialog)
		THEN
		NOT DB_AD_Dialog(_Npc,_Npc2,_Dialog);
		NOT DB_ADRequested(_Npc);
		NOT DB_ADRequested(_Npc2);
		
		PROC
		ProcRemoveNPCADs((GUIDSTRING)_Npc2)
		AND
		DB_AD_Dialog(_Npc,_Npc2,_Dialog)
		THEN
		NOT DB_AD_Dialog(_Npc,_Npc2,_Dialog);
		NOT DB_ADRequested(_Npc);
		NOT DB_ADRequested(_Npc2);
		
		PROC
		PROC_GLOBAL_DialogStartRequested((GUIDSTRING)_NPC,(GUIDSTRING)_Player)
		AND
		DB_AD_Dialog(_NPC,_)
		THEN
		ProcFaceEachother(_NPC,_Player);
		
		//END_REGION
		
		//REGION Object timer
		PROC
		ProcObjectTimer((GUIDSTRING)_Object,(STRING)_TimerName,(INTEGER)_Time)
		AND
		GetUUID(_Object,_UUID)
		AND
		StringConcatenate(_UUID,_TimerName,_ObjectTimerName)
		THEN
		DB_ObjectTimer(_Object,_ObjectTimerName,_TimerName);
		TimerLaunch(_ObjectTimerName,_Time);
		
		PROC
		ProcObjectTimerCancel((GUIDSTRING)_Object,(STRING)_TimerName)
		AND
		DB_ObjectTimer(_Object,_ObjectTimerName,_TimerName)
		THEN
		NOT DB_ObjectTimer(_Object,_ObjectTimerName,_TimerName);
		TimerCancel(_ObjectTimerName);
		
		IF
		TimerFinished(_ObjectTimerName)
		AND
		DB_ObjectTimer(_Object,_ObjectTimerName,_TimerName)
		THEN
		NOT DB_ObjectTimer(_Object,_ObjectTimerName,_TimerName);
		ProcObjectTimerFinished(_Object,_TimerName);
		
		PROC
		ProcObjectTimerFinished((GUIDSTRING)_Object,(STRING)_TimerName)
		THEN
		DB_NOOP(1);
		//END_REGION
		
		//REGION Tutorial Messages
		PROC
		PROC_CheckPlayTut((STRING)_Message)
		AND
		_Player.DB_IsPlayer()
		THEN
		PROC_CheckPlayTut(_Player,_Message);
		
		PROC
		PROC_CheckPlayTut((CHARACTERGUID)_Player,(STRING)_Message)
		AND
		DB_StartTutMessages(1)
		THEN
		ProcPlayTut(_Player,_Message);
		
		PROC
		PROC_CheckPlayTutWithDelay((STRING)_Message,(INTEGER)_Delay)
		AND
		_Player.DB_IsPlayer()
		THEN
		PROC_CheckPlayTutWithDelay(_Player,_Message,_Delay);
		
		PROC
		PROC_CheckPlayTutWithDelay((CHARACTERGUID)_Player,(STRING)_Message,(INTEGER)_Delay)
		AND
		NOT DB_TutorialMessage(_Player,_Message,_)
		AND
		GetUUID(_Player,_Timer)
		AND
		StringConcatenate(_Timer,"_Tut",_TimerMsg)
		THEN
		TimerLaunch(_TimerMsg,_Delay);
		DB_TutorialMessage(_Player,_Message,_TimerMsg);
		
		IF
		TimerFinished(_TimerMsg)
		AND
		DB_StartTutMessages(1)
		AND
		DB_TutorialMessage(_Player,_Message,_TimerMsg)
		THEN
		NOT DB_TutorialMessage(_Player,_Message,_TimerMsg);
		ProcPlayTut(_Player,_Message);
		//END_REGION
		
		//REGION Move to changes 
		PROC
		ProcSaveGenericBehaviourState((CHARACTERGUID)_Char)
		AND
		NOT DB_StoryMoving(_Char,1)
		AND
		DB_Internal_Dialogs(_Char,_,_,_)
		THEN
		DB_NPCHadDialog(_Char,1);
		
		PROC
		ProcSaveGenericBehaviourState((CHARACTERGUID)_Char)
		AND
		NOT DB_StoryMoving(_Char,1)
		AND
		DB_AD_Dialog(_Char,_)
		THEN
		DB_NPCHadDialog(_Char,1);
		
		PROC
		ProcInternalMoveDisableGenericBehaviours((CHARACTERGUID)_Char)
		AND
		NOT DB_AD_Dialog(_Char,_)
		THEN
		SetHasDialog(_Char,0);
		
		PROC
		ProcInternalMoveDisableGenericBehaviours((CHARACTERGUID)_Char)
		THEN
		CharacterDisableAllCrimes(_Char);
		
		PROC
		ProcRestoreGenericBehaviour((CHARACTERGUID)_Char)
		AND
		NOT DB_CharacterAllCrimesDisabled(_Char)
		THEN
		CharacterEnableAllCrimes(_Char);
		
		PROC
		ProcRestoreGenericBehaviour((CHARACTERGUID)_Char)
		AND
		DB_CharacterCrimeDisabled(_Char,_Crime)
		THEN
		CharacterDisableCrime(_Char,_Crime);
		
		PROC
		ProcRestoreGenericBehaviour((CHARACTERGUID)_Char)
		AND
		DB_CharacterCrimeEnabled(_Char,_Crime)
		THEN
		CharacterEnableCrime(_Char,_Crime);
		
		PROC
		ProcRestoreGenericBehaviour((CHARACTERGUID)_Char)
		AND
		DB_NPCHadDialog(_Char,1)
		THEN
		NOT DB_NPCHadDialog(_Char,1);
		SetHasDialog(_Char,1);
		
		PROC
		ProcSetMoveEvent((STRING)_Event)
		AND
		_Event!=""
		THEN
		DB_MoveEvent(_Event);
		
		PROC
		ProcSetMoveEvent("")
		THEN
		DB_MoveEvent("_ResetGenericBehaviours_");
		
		PROC
		ProcExecuteMove((CHARACTERGUID)_Char,(GUIDSTRING)_Point,(INTEGER)_Running)
		AND
		DB_MoveEvent(_Event)
		AND
		DB_CharMovementCommandID(_Char,_ID)
		THEN
		NOT DB_MoveEvent(_Event);
		CharacterMoveTo(_Char,_Point,_Running,_Event,0);
		DB_CharacterMovement(_Char,_Event,_ID);
		
		PROC
		ProcBumpOsirisMoveCommandID((CHARACTERGUID)_Char)
		AND
		NOT DB_CharMovementCommandID(_Char,_)
		THEN
		DB_CharMovementCommandID(_Char,0);
		
		PROC
		ProcBumpOsirisMoveCommandID((CHARACTERGUID)_Char)
		AND
		DB_CharMovementCommandID(_Char,_ID)
		AND
		IntegerSum(1,_ID,_New)
		THEN
		NOT DB_CharMovementCommandID(_Char,_ID);
		DB_CharMovementCommandID(_Char,_New);
		
		PROC
		ProcCharacterMoveTo((CHARACTERGUID)_Char,_,_,_)
		THEN
		SetStoryEvent(_Char,"ClearCrimeReturnPos");
		ProcBumpOsirisMoveCommandID(_Char);
		
		PROC
		ProcCharacterMoveTo((CHARACTERGUID)_Char,(GUIDSTRING)_Point,(INTEGER)_Running,(STRING)_Event)
		AND
		DB_CharMovementCommandID(_Char,_ID)
		THEN
		ProcSaveGenericBehaviourState(_Char);
		ProcInternalMoveDisableGenericBehaviours(_Char);
		ProcSetMoveEvent(_Event);
		ProcExecuteMove(_Char,_Point,_Running);
		DB_StoryMoving(_Char,1);
		DB_MovingTo(_Char,_Point,_Running,_ID);
		
		PROC
		ProcCharacterMoveTo((CHARACTERGUID)_Char,_,_,_)
		THEN
		ProcBumpOsirisMoveCommandID(_Char);
		
		PROC
		ProcResumeStoryMoving((CHARACTERGUID)_Char)
		AND
		DB_CharacterMovement(_Char,_Event,_ID)
		AND
		NOT DB_SelectedMove(_Char)
		THEN
		ProcSelectMove(_Char,_ID);
		
		PROC
		ProcSelectMove((CHARACTERGUID)_Char,(INTEGER)_ID)
		AND
		DB_MovingTo(_Char,_Point,_Running,_ID)
		AND
		DB_CharacterMovement(_Char,_Event,_ID)
		THEN
		DB_SelectedMove(_Char);
		CharacterMoveTo(_Char,_Point,_Running,_Event,0);
		
		PROC
		ProcResumeStoryMoving((CHARACTERGUID)_Char)
		THEN
		NOT DB_SelectedMove(_Char);
		
		PROC
		ProcClearMovingFacts((CHARACTERGUID)_Char)
		AND
		DB_CharacterMovement(_Char,_Event,_ID)
		THEN
		NOT DB_CharacterMovement(_Char,_Event,_ID);
		
		PROC
		ProcClearMovingFacts((CHARACTERGUID)_Char)
		AND
		DB_MovingTo(_Char,_Point,_Running,_ID)
		THEN
		NOT DB_MovingTo(_Char,_Point,_Running,_ID);
		
		PROC
		ProcClearMovingFacts((CHARACTERGUID)_Char)
		THEN
		ProcRestoreGenericBehaviour(_Char);
		
		IF
		StoryEvent((CHARACTERGUID)_Char,_Event)
		AND
		DB_CharacterMovement(_Char,_Event,_ID)
		THEN
		NOT DB_ClearedMoveEvent(_Char);
		
		IF
		StoryEvent((CHARACTERGUID)_Char,_Event)
		AND
		DB_CharacterMovement(_Char,_Event,_ID)
		AND
		DB_MovingTo(_Char,_Point,_Running,_ID)
		AND
		NOT DB_ClearedMoveEvent(_Char)
		THEN
		DB_ClearedMoveEvent(_Char);
		NOT DB_MovingTo(_Char,_Point,_Running,_ID);
		
		IF
		StoryEvent((CHARACTERGUID)_Char,_Event)
		AND
		DB_CharacterMovement(_Char,_Event,_ID)
		THEN
		NOT DB_HandledMoveEvent(_Char);
		
		IF
		StoryEvent((CHARACTERGUID)_Char,_Event)
		AND
		DB_CharacterMovement(_Char,_Event,_ID)
		AND
		NOT DB_HandledMoveEvent(_Char)
		THEN
		DB_HandledMoveEvent(_Char);
		NOT DB_CharacterMovement(_Char,_Event,_ID);
		SetStoryEvent(_Char,"ClearCrimeReturnPos");
		ProcCheckRestoreGenericBehaviours(_Char);
		
		
		PROC
		ProcCheckRestoreGenericBehaviours((CHARACTERGUID)_Char)
		AND
		NOT DB_CharacterMovement(_Char,_,_)
		THEN
		NOT DB_StoryMoving(_Char,1);
		ProcRestoreGenericBehaviour(_Char);
		
		IF
		AttackedByObject((CHARACTERGUID)_Char,(CHARACTERGUID)_Source,_,_,_DamageSource)
		AND
		DB_StoryMoving(_Char,1)
		AND
		NOT DB_CombatCharacters(_Char,_)
		AND
		NOT QryIgnoreDamageSource(_DamageSource)
		AND
		CharacterIsPlayer(_Source,1)
		THEN
		ProcMakeNPCHostile(_Source,_Char);
		
		IF
		DB_Dead(_Char)
		AND
		DB_StoryMoving(_Char,1)
		THEN
		NOT DB_StoryMoving(_Char,1);
		ProcRestoreGenericBehaviour(_Char);
		ProcClearMovingFacts(_Char);
		
		IF
		ObjectEnteredCombat((CHARACTERGUID)_Char,_)
		AND
		DB_StoryMoving(_Char,1)
		THEN
		CharacterPurgeQueue(_Char);
		
		IF
		ObjectLeftCombat((CHARACTERGUID)_Char,_)
		AND
		NOT DB_Dead(_Char)
		AND
		DB_StoryMoving(_Char,1)
		THEN
		ProcResumeStoryMoving(_Char);
		
		PROC
		ProcClearStoryMove((CHARACTERGUID)_Char)
		THEN
		NOT DB_StoryMoving(_Char,1);
		ProcRestoreGenericBehaviour(_Char);
		ProcClearMovingFacts(_Char);
		//END_REGION
		
		//REGION Movement via State_Manager_GoTo
		// The parameters are roughly the same as with ProcCharacterMoveTo. Additional parameters:
		//  - _MinDist: the minimal distance to which the character must have neared its destination before the event is triggered
		//  - _AfterArrivalState: the State_Manager state to go to once the character reaches its destination
		PROC
		ProcStateManagerCharacterMoveTo((CHARACTERGUID)_Char,(GUIDSTRING)_Destination,(INTEGER)_Running,(REAL)_MinDist,(STRING)_Event,(STRING)_AfterArrivalState)
		AND
		ObjectIsCharacter(_Destination,1)
		THEN
		DB_ProcStateManagerCharacterMoveTo_Handled(1);
		SetVarObject(_Char,"DestinationCharacter",_Destination);
		SetVarFixedString(_Char,"currentState","State_Manager_Go_To_Character");
		
		PROC
		ProcStateManagerCharacterMoveTo((CHARACTERGUID)_Char,(GUIDSTRING)_Destination,(INTEGER)_Running,(REAL)_MinDist,(STRING)_Event,(STRING)_AfterArrivalState)
		AND
		NOT DB_ProcStateManagerCharacterMoveTo_Handled(1)
		AND
		ObjectIsItem(_Destination,1)
		THEN
		DB_ProcStateManagerCharacterMoveTo_Handled(1);
		SetVarObject(_Char,"DestinationItem",_Destination);
		SetVarFixedString(_Char,"currentState","State_Manager_Go_To_Item");
		
		PROC
		ProcStateManagerCharacterMoveTo((CHARACTERGUID)_Char,(GUIDSTRING)_Destination,(INTEGER)_Running,(REAL)_MinDist,(STRING)_Event,(STRING)_AfterArrivalState)
		AND
		NOT DB_ProcStateManagerCharacterMoveTo_Handled(1)
		THEN
		SetVarObject(_Char,"Destination",_Destination);
		SetVarFixedString(_Char,"currentState","State_Manager_Go_To_Trigger");
		
		PROC
		ProcStateManagerCharacterMoveTo((CHARACTERGUID)_Char,(GUIDSTRING)_Destination,(INTEGER)_Running,(REAL)_MinDist,(STRING)_Event,(STRING)_AfterArrivalState)
		THEN
		NOT DB_ProcStateManagerCharacterMoveTo_Handled(1);
		SetVarInteger(_Char,"Running",_Running);
		SetVarFloat(_Char,"Distance",_MinDist);
		SetVarString(_Char,"ArriveEvent",_Event);
		SetVarFixedString(_Char,"AfterArriveState",_AfterArrivalState);
		//END_REGION
		
		PROC 
		ReactOnKillCounter((STRING)_Counter)
		THEN 
		DB_NOOP(1);
		
		PROC
		ProcStartMovie((STRING)_Movie)
		AND
		_Char.DB_IsPlayer()
		AND
		CharacterGetReservedUserID(_Char,_ID)
		AND
		GetUserProfileID(_ID,_UserProfile)
		AND
		NOT DB_MoviePlayed(_UserProfile,_Movie)
		THEN
		DB_MoviePlayed(_UserProfile,_Movie);
		MoviePlay(_Char,_Movie);
		
		
		//REGION check closest available character to object
		
		PROC
		ProcGetClosestAvailableCharacterTo((CHARACTERGUID)_Obj,(INTEGER)_SightCheck)
		THEN
		ProcGetClosestAvailableCharacterTo((CHARACTERGUID)_Obj,(INTEGER)_SightCheck,0,NULL_00000000-0000-0000-0000-000000000000);
		
		
		PROC
		ProcGetClosestAvailableCharacterTo((CHARACTERGUID)_Obj,(INTEGER)_SightCheck,(INTEGER)_PartyCheck,(CHARACTERGUID)_Player)
		THEN
		ProcGetClosestAvailableCharacterTo((CHARACTERGUID)_Obj,(INTEGER)_SightCheck,(INTEGER)_PartyCheck,(CHARACTERGUID)_Player,(CHARACTERGUID)NULL_00000000-0000-0000-0000-000000000000);
		
		PROC
		ProcGetClosestAvailableCharacterTo((CHARACTERGUID)_Obj,(INTEGER)_SightCheck,(INTEGER)_PartyCheck,(CHARACTERGUID)_Player,(CHARACTERGUID)_ExceptPlayer)
		AND 
		DB_ProcGetClosestAvailableCharacterTo_Dist(_Char,_Obj,_Dist)
		THEN
		NOT DB_ProcGetClosestAvailableCharacterTo_Dist(_Char,_Obj,_Dist);
		
		PROC
		ProcGetClosestAvailableCharacterTo((CHARACTERGUID)_Obj,(INTEGER)_SightCheck,(INTEGER)_PartyCheck,(CHARACTERGUID)_Player,(CHARACTERGUID)_ExceptPlayer)
		AND 
		DB_ClosestAvailablePlayer(_Char,_Obj)
		THEN
		NOT DB_ClosestAvailablePlayer(_Char,_Obj);
		
		PROC
		ProcGetClosestAvailableCharacterTo((CHARACTERGUID)_Obj,(INTEGER)_SightCheck,(INTEGER)_PartyCheck,(CHARACTERGUID)_Player,(CHARACTERGUID)_ExceptPlayer)
		AND
		DB_ClosestAvailablePlayer_NoAvailablePlayer(_Obj)
		THEN
		NOT DB_ClosestAvailablePlayer_NoAvailablePlayer(_Obj);
		
		PROC
		ProcGetClosestAvailableCharacterTo((CHARACTERGUID)_Obj,1,1,(CHARACTERGUID)_Player,(CHARACTERGUID)_ExceptPlayer)
		AND 
		DB_IsPlayer(_Char)
		AND
		_Char != _ExceptPlayer
		AND
		CharacterCanSee(_Obj,(CHARACTERGUID)_Char,1)
		AND
		QRY_SpeakerIsAvailable(_Char)
		AND
		CharacterIsInPartyWith(_Char,_Player,1)
		AND
		GetDistanceTo(_Char,_Obj,_Dist)
		THEN
		DB_ProcGetClosestAvailableCharacterTo_Dist(_Char,_Obj,_Dist);
		
		PROC
		ProcGetClosestAvailableCharacterTo((CHARACTERGUID)_Obj,0,1,(CHARACTERGUID)_Player,(CHARACTERGUID)_ExceptPlayer)
		AND 
		DB_IsPlayer(_Char)
		AND
		_Char != _ExceptPlayer
		AND
		QRY_SpeakerIsAvailable(_Char)
		AND
		CharacterIsInPartyWith(_Char,_Player,1)
		AND
		GetDistanceTo(_Char,_Obj,_Dist)
		THEN
		DB_ProcGetClosestAvailableCharacterTo_Dist(_Char,_Obj,_Dist);
		
		PROC
		ProcGetClosestAvailableCharacterTo((CHARACTERGUID)_Obj,1,0,(CHARACTERGUID)_Player,(CHARACTERGUID)_ExceptPlayer)
		AND 
		DB_IsPlayer(_Char)
		AND
		_Char != _ExceptPlayer
		AND
		CharacterCanSee(_Obj,(CHARACTERGUID)_Char,1)
		AND
		QRY_SpeakerIsAvailable(_Char)
		AND
		GetDistanceTo(_Char,_Obj,_Dist)
		THEN
		DB_ProcGetClosestAvailableCharacterTo_Dist(_Char,_Obj,_Dist);
		
		PROC
		ProcGetClosestAvailableCharacterTo((CHARACTERGUID)_Obj,0,0,(CHARACTERGUID)_Player,(CHARACTERGUID)_ExceptPlayer)
		AND 
		DB_IsPlayer(_Char)
		AND
		_Char != _ExceptPlayer
		AND
		QRY_SpeakerIsAvailable(_Char)
		AND
		GetDistanceTo(_Char,_Obj,_Dist)
		THEN
		DB_ProcGetClosestAvailableCharacterTo_Dist(_Char,_Obj,_Dist);
		
		PROC
		ProcGetClosestAvailableCharacterTo((CHARACTERGUID)_Obj,(INTEGER)_SightCheck,(INTEGER)_PartyCheck,(CHARACTERGUID)_Player,(CHARACTERGUID)_ExceptPlayer)
		AND
		DB_ProcGetClosestAvailableCharacterTo_Dist(_Char1,_Obj,_Dist1)
		AND
		DB_ProcGetClosestAvailableCharacterTo_Dist(_Char2,_Obj,_Dist2)
		AND
		_Dist1 < _Dist2
		THEN
		NOT DB_ProcGetClosestAvailableCharacterTo_Dist(_Char2,_Obj,_Dist2);
		
		PROC
		ProcGetClosestAvailableCharacterTo((CHARACTERGUID)_Obj,(INTEGER)_SightCheck,(INTEGER)_PartyCheck,(CHARACTERGUID)_Player,(CHARACTERGUID)_ExceptPlayer)
		AND
		NOT DB_ProcGetClosestAvailableCharacterTo_Dist(_,_Obj,_)
		THEN 
		DB_ClosestAvailablePlayer_NoAvailablePlayer(_Obj);
		
		PROC
		ProcGetClosestAvailableCharacterTo((CHARACTERGUID)_Obj,(INTEGER)_SightCheck,(INTEGER)_PartyCheck,(CHARACTERGUID)_Player,(CHARACTERGUID)_ExceptPlayer)
		AND
		DB_ProcGetClosestAvailableCharacterTo_Dist(_Char,_Obj,_Dist)
		THEN
		DB_ClosestAvailablePlayer(_Char,_Obj);
		NOT DB_ProcGetClosestAvailableCharacterTo_Dist(_Char,_Obj,_Dist);
		
		//END_REGION
		
		
		//REGION Disappear out of sight
		
		PROC
		ProcCharacterDisappearOutOfSight((CHARACTERGUID)_Character,(INTEGER)_Angle,(INTEGER)_Running,(STRING)_Event,(INTEGER)_IncreaseSpeed)
		THEN
		CharacterDisableAllCrimes(_Character);
		DB_CharacterDisappearedOutOfSight(_Character,_Event,1);
		CharacterDisappearOutOfSight(_Character,_Angle,_Running,_Event,_IncreaseSpeed);
		
		PROC
		ProcCharacterDisappearOutOfSightToObject((CHARACTERGUID)_Character,(GUIDSTRING)_Object,(INTEGER)_Running,(STRING)_Event,(INTEGER)_IncreaseSpeed)
		THEN
		CharacterDisableAllCrimes(_Character);
		DB_CharacterDisappearedOutOfSight(_Character,_Event,1);
		CharacterDisappearOutOfSightToObject(_Character,_Object,_Running,_Event,_IncreaseSpeed);
		
		QRY
		QryCanSeeAttackers((CHARACTERGUID)_Char,(CHARACTERGUID)_Src,(CHARACTERGUID)_SrcSummon)
		AND
		_SrcSummon != NULL_00000000-0000-0000-0000-000000000000
		AND
		_SrcSummon != _Src
		AND
		CharacterCanSee(_Char,_SrcSummon,1)
		THEN
		DB_SawAttacker(_SrcSummon);
		
		QRY
		QryCanSeeAttackers((CHARACTERGUID)_Char,(CHARACTERGUID)_Src,(CHARACTERGUID)_SrcSummon)
		AND
		NOT DB_SawAttacker(_)
		AND
		CharacterCanSee(_Char,_Src,1)
		THEN
		DB_SawAttacker(_Src);
		
		IF
		AttackedByObject((CHARACTERGUID)_Char,(CHARACTERGUID)_Src,_SrcSummon,_,_)
		AND
		_Src != _Char
		AND
		ObjectIsOnStage(_Char,1)
		AND
		DB_CharacterDisappearedOutOfSight(_Char,_,1)
		AND
		IsTagged(_Char,"ANIMAL",0)
		AND
		CharacterCanFight(_Char,1)
		AND
		ObjectIsCharacter(_Src,1)
		AND
		QryCanSeeAttackers(_Char,_Src,_SrcSummon)
		AND
		DB_SawAttacker(_Target)
		THEN
		DB_StoppedOutOfSight(_Char);
		CharacterPurgeQueue(_Char);
		CharacterSetTemporaryHostileRelation(_Char,_Target);
		NOT DB_SawAttacker(_Target);
		
		IF
		CharacterSetTemporaryRelationsFailed(_Char,_Target)
		AND
		DB_StoppedOutOfSight(_Char)
		THEN
		ProcResumeDisappearOutOfSight(_Char);
		
		IF
		ObjectLeftCombat((CHARACTERGUID)_Char,_)
		AND
		DB_StoppedOutOfSight(_Char)
		THEN
		ProcResumeDisappearOutOfSight(_Char);
		
		PROC
		ProcResumeDisappearOutOfSight((CHARACTERGUID)_Char)
		AND
		NOT DB_Dead(_Char)
		AND
		DB_CharacterDisappearedOutOfSight(_Char,_Event,1)
		THEN
		NOT DB_StoppedOutOfSight(_Char);
		CharacterDisappearOutOfSight(_Char,0,1,_Event,1);
		
		IF
		CharacterWentOnStage(_Character,1)
		AND
		DB_CharacterDisappearedOutOfSight(_Character,_Event,_ReactToCombat)
		THEN
		NOT DB_CharacterDisappearedOutOfSight(_Character,_Event,_ReactToCombat);
		ProcRestoreGenericBehaviour(_Character);
		
		IF
		StoryEvent((CHARACTERGUID)_Character,"GEN_CharacterDisableAllCrimesBeforeDisappear")
		THEN
		CharacterDisableAllCrimes(_Character);
		DB_CharacterDisappearedOutOfSight(_Character,"",0);
		
		PROC
		ProcClearDisappearData((CHARACTERGUID)_Character)
		AND
		DB_CharacterDisappearedOutOfSight(_Character,_Event,_ReactToCombat)
		THEN
		NOT DB_CharacterDisappearedOutOfSight(_Character,_Event,_ReactToCombat);
		
		//END_REGION
		
		//REGION TemporaryHostileRelation
		PROC
		Proc_CharacterSetTemporaryHostileRelation((CHARACTERGUID)_Char1,(CHARACTERGUID)_Char2)
		AND
		_Char2!= NULL_00000000-0000-0000-0000-000000000000
		AND
		_Char1!= NULL_00000000-0000-0000-0000-000000000000
		THEN
		CharacterSetTemporaryHostileRelation(_Char1,_Char2);
		//END_REGION
		
		IF
		RegionEnded(_Region)
		THEN
		ProcRegionEnded(_Region);
		
		PROC
		ProcRegionEnded((STRING)_Region)
		THEN
		DB_NOOP(1);
		
		//REGION Healing status query
		QRY
		QRY_IsHealingStatus((STRING)_Status)
		AND
		_Status != "HEAL" //DOSTWO-24618 The actual HEAL status is a tick that is set from different statusses (that possibly doesn't heal because it has its parameters overwritten). It's never set on its own.
		AND
		GetStatusType(_Status,"HEAL")
		AND
		GetHealStat(_Status,"Vitality")
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_IsHealingStatus((STRING)_Status)
		AND
		GetStatusType(_Status,"HEALING")
		AND
		GetHealStat(_Status,"Vitality")
		THEN
		DB_NOOP(1);
		//END_REGION
		
		//REGION item moving defaults
		PROC
		ItemMoveToTrigger((ITEMGUID)_Item,(TRIGGERGUID)_Trigger, (REAL)_Speed, (REAL)_Acceleration, (INTEGER)_UseRotation, (STRING)_Event)
		THEN
		ItemMoveToTrigger(_Item,_Trigger,_Speed,_Acceleration,_UseRotation,_Event,1);
		
		PROC
		ItemMoveToTrigger((ITEMGUID)_Item,(TRIGGERGUID)_Trigger, (REAL)_Speed, (REAL)_Acceleration, (INTEGER)_UseRotation)
		THEN
		ItemMoveToTrigger(_Item,_Trigger,_Speed,_Acceleration,_UseRotation,"",1);
		 
		PROC
		ItemMoveToPosition((ITEMGUID)_Item, (REAL)_X, (REAL)_Y, (REAL)_Z, (REAL)_Speed, (REAL)_Acceleration, (STRING)_Event)
		THEN
		ItemMoveToPosition(_Item, _X, _Y, _Z, _Speed, _Acceleration,_Event,1);
		
		PROC
		ItemMoveToPosition((ITEMGUID)_Item, (REAL)_X, (REAL)_Y, (REAL)_Z, (REAL)_Speed, (REAL)_Acceleration)
		THEN
		ItemMoveToPosition(_Item, _X, _Y, _Z, _Speed, _Acceleration,"",1);
		
		//END_REGION
		
		//REGION transform overloads
		PROC
		Transform((ITEMGUID)_Object, (STRING)_Template)
		THEN
		Transform(_Object,_Template,0,0,0);
		
		PROC
		Transform((GUIDSTRING)_Object, (STRING)_Template, (INTEGER)_ReplaceScripts)
		THEN
		Transform(_Object,_Template,_ReplaceScripts,0,0);
		
		PROC
		Transform((GUIDSTRING)_Object, (STRING)_Template, (INTEGER)_ReplaceScripts, (INTEGER)_ReplaceScale)
		THEN
		Transform(_Object,_Template,_ReplaceScripts,_ReplaceScale,0);
		
		//END_REGION
		
		//REGION Perception
		PROC
		ProcSetPerceptionDifficulty((ITEMGUID)_Item,(STRING)_Difficulty)
		THEN
		SetVarFixedString(_Item,"Difficulty",_Difficulty);
		SetStoryEvent(_Item,"GLO_OverrideWitsCheck");
		//END_REGION
		
		PROC
		PlayEffect((GUIDSTRING)_Object,(STRING)_FxName)
		THEN
		PlayEffect(_Object,_FxName,"");
		
		PROC
		ApplyDamage((GUIDSTRING)_Object, (INTEGER)_Damage, (STRING)_DamageType)
		THEN
		ApplyDamage(_Object, _Damage, _DamageType, NULL_00000000-0000-0000-0000-000000000000);
		
		PROC
		ApplyStatus((GUIDSTRING)_Object, (STRING)_Status, (REAL)_Duration, (INTEGER)_Force)
		THEN
		ApplyStatus(_Object, _Status, _Duration, _Force, NULL_00000000-0000-0000-0000-000000000000);
		
		PROC
		CharacterDie((CHARACTERGUID)_Character, (INTEGER)_GenerateTreasure, (STRING)_DeathType)
		THEN
		CharacterDie(_Character, _GenerateTreasure, _DeathType, NULL_00000000-0000-0000-0000-000000000000);
		
		PROC
		CharacterDieImmediate((CHARACTERGUID)_Character, (INTEGER)_GenerateTreasure, (STRING)_DeathType)
		THEN
		CharacterDieImmediate(_Character, _GenerateTreasure, _DeathType, NULL_00000000-0000-0000-0000-000000000000);
		
	}
	EXIT
	{
		
	}
}
Goal(10).Title("__Start");
Goal(10)
{
	INIT
	{
		Proc_ExclamationMarkCleanup();
		
		
	}
	KB
	{
		IF
		GameEventSet("GAMEEVENT_GameStarted")
		THEN
		InitStory();
		GoalCompleted;
		
		
		PROC
		Proc_ExclamationMarkCleanup()
		AND
		_Player.DB_IsPlayer()
		THEN
		CharacterStopAllEffectsWithName(_Player,"RS3_FX_UI_Exclamation_Mark_01");
		SetHasDialog(_Player,0);
		
	}
	EXIT
	{
		
	}
}
Goal(11).Title("_AAA_FirstGoal");
Goal(11)
{
	INIT
	{
		// Time(_Day,_Hour,_TotalHours)
		// Current time (updated last time event NewHour was generated)
		//		_TotalHours = (_Day - 1)*24 + _Hour
		//		_TotalHours is suitable for calculating time differences
		//SetTime(ENGINE_GAME,10);  TODO
		DB_Time(1,10,10);
		// CurrentHalfHour and total HalfHours
		DB_HalfHour(20,20);
		
		//TODO: for now we use these timers to simulate time passing. This should come from the game engine if we're going to support different time of day settings
		DB_GameHour(300000);
		StartTimeOfDayTimerLoop();
		
		// Money dialog variables
		DB_FirstGoal_MoneyDialogVar(1,"GEN_CheckMagicPocketGold_6057ad05-9492-4630-9f0a-be548b134c54");
		DB_FirstGoal_MoneyDialogVar(2,"GEN_CheckMagicPocketGold_2_463b0f43-5410-412d-aba3-875cf81c38ca");
		DB_FirstGoal_MoneyDialogVar(3,"GEN_CheckMagicPocketGold_3_01f129ea-b4dc-44b6-8154-9a948f876a82");
		DB_FirstGoal_MoneyDialogVar(4,"GEN_CheckMagicPocketGold_4_5dac5eea-faeb-459c-b675-46c51519b784");
		DB_FirstGoal_MoneyDialogVar(5,"GEN_CheckMagicPocketGold_5_8860ed48-ba5f-4b7b-82bf-f1220f967d41");
		
		DB_FirstGoal_CheckPocketGoldSpeakerVar(1,"GEN_CheckPocketGold_SpeakerIndex_8504b4e0-886e-4912-9525-fbe559c5f8ff");
		DB_FirstGoal_CheckPocketGoldSpeakerVar(2,"GEN_CheckPocketGold_2_SpeakerIndex_a9c4d456-3ef5-491d-a1eb-49f09b91e8b4");
		DB_FirstGoal_CheckPocketGoldSpeakerVar(3,"GEN_CheckPocketGold_3_SpeakerIndex_d7fa1537-77d4-4d7d-a955-7ffda90e6207");
		DB_FirstGoal_CheckPocketGoldSpeakerVar(4,"GEN_CheckPocketGold_4_SpeakerIndex_5c499066-448b-4d0c-8dc9-d1553d04c6d4");
		DB_FirstGoal_CheckPocketGoldSpeakerVar(5,"GEN_CheckPocketGold_5_SpeakerIndex_65757687-b815-43fe-be9c-1cefe82efb60");
		
	}
	KB
	{
		//REGION Game Mode handling
		PROC
		Proc_GameModeStarted((STRING)_Mode,(INTEGER)_)
		THEN
		ProcSetCurrentGameMode(_Mode);
		
		PROC
		ProcSetCurrentGameMode((STRING)_Mode)
		AND
		DB_CurrentGameMode(_Old)
		THEN
		NOT DB_CurrentGameMode(_Old);
		
		PROC
		ProcSetCurrentGameMode((STRING)_Mode)
		THEN
		DB_CurrentGameMode(_Mode);
		
		//END_REGION
		
		//REGION Dialog book keeping 
		IF
		DialogRequestFailed(_,_Inst)
		THEN
		DB_MarkedForDelete(_Inst);
		ProcGetInvolvedPlayers(_Inst);
		ProcGetInvolvedNPCs(_Inst);
		ProcSaveNumActors(_Inst);
		ProcClearDialogFlagsForPlayers(_Inst);
		ProcClearDialogFlagsForNPCs(_Inst);
		
		IF
		AutomatedDialogRequestFailed(_,_Inst)
		THEN
		ProcGetInvolvedPlayers(_Inst);
		ProcGetInvolvedNPCs(_Inst);
		ProcSaveNumActors(_Inst);
		DB_AutomatedDialog(_Inst);
		
		IF
		DialogStarted(_Dialog,_Inst)
		THEN
		ProcGetInvolvedPlayers(_Inst);
		ProcGetInvolvedNPCs(_Inst);
		ProcSaveNumActors(_Inst);
		ProcSetDialogGoldCheckAmount(_Dialog);
		DB_DialogName(_Dialog,_Inst);
		
		IF
		DialogActorJoined(_Dialog,_Inst,_Actor)
		THEN
		ProcAddActorToDialogList(_Inst,_Actor);
		ProcSetStoryNPC(_Inst,_Actor);
		ProcSetNumberOfInvolvedActors(_Inst);
		
		IF
		VoiceBarkStarted(_,_Inst)
		THEN
		DB_AutomatedDialogIsVB(_Inst);
		
		IF
		AutomatedDialogStarted(_Dialog,_Inst)
		THEN
		ProcGetInvolvedPlayers(_Inst);
		ProcGetInvolvedNPCs(_Inst);
		ProcSaveNumActors(_Inst);
		DB_AutomatedDialog(_Inst);
		DB_DialogName(_Dialog,_Inst);
		
		PROC
		ProcSetStoryNPC((INTEGER)_Inst,(GUIDSTRING)_Actor)
		AND
		NOT DB_AutomatedDialog(_Inst)
		AND
		ObjectIsCharacter((CHARACTERGUID)_Actor,1)
		AND
		NOT DB_CombatCharacters(_Actor,_)
		THEN
		CharacterMakeStoryNpc(_Actor,1);
		
		PROC
		ProcSetStoryNPC((INTEGER)_Inst,(GUIDSTRING)_Actor)
		AND
		NOT DB_AutomatedDialog(_Inst)
		THEN
		ProcItemSetInvulnerableForDialog(_Actor);
		
		//add these in the back so we don't disrupt the original flow
		PROC
		ProcAddActorToDialogList((INTEGER)_Inst,(GUIDSTRING)_Actor)
		AND
		DB_IsPlayer((CHARACTERGUID)_Actor)
		AND
		DB_DialogNumPlayers(_Inst,_NumPlayers)
		AND
		IntegerSum(_NumPlayers,1,_NewSlot)
		THEN
		DB_DialogPlayers(_Inst,(GUIDSTRING)_Actor,_NewSlot);
		
		PROC
		ProcAddActorToDialogList((INTEGER)_Inst,(GUIDSTRING)_Actor)
		AND
		NOT DB_IsPlayer((CHARACTERGUID)_Actor)
		AND
		DB_DialogNumNPCs(_Inst,_NumNPCs)
		AND
		IntegerSum(_NumNPCs,1,_NewSlot)
		THEN
		DB_DialogNPCs(_Inst,(GUIDSTRING)_Actor,_NewSlot);
		
		
		PROC
		ProcSetNumberOfInvolvedActors((INTEGER)_Inst)
		AND
		DB_DialogNumPlayers(_Inst,_NumPlayers)
		AND
		DB_DialogNumNPCs(_Inst,_NumNPCs)
		THEN
		NOT DB_DialogNumPlayers(_Inst,_NumPlayers);
		NOT DB_DialogNumNPCs(_Inst,_NumNPCs);
		ProcSaveNumActors(_Inst);
		
		PROC
		ProcSaveNumActors((INTEGER)_Inst)
		AND
		DialogGetNumberOfInvolvedNPCs(_Inst,_NumNPCs)
		AND
		DialogGetNumberOfInvolvedPlayers(_Inst,_NumPlayers)
		THEN
		DB_DialogNumPlayers(_Inst,_NumPlayers);
		DB_DialogNumNPCs(_Inst,_NumNPCs);
		
		PROC
		ProcGetInvolvedNPCs((INTEGER)_Inst)
		THEN
		ProcGetInvolveNPC(_Inst,1);
		
		PROC
		ProcGetInvolveNPC((INTEGER)_Inst,(INTEGER)_Index)
		AND
		DialogGetInvolvedNPC(_Inst,_Index,_NPC)
		AND
		IntegerSum(_Index,1,_New)
		THEN
		DB_DialogNPCs(_Inst,_NPC,_Index);
		ProcGetInvolveNPC(_Inst,_New);
		
		PROC
		ProcGetInvolvedPlayers((INTEGER)_Inst)
		THEN
		ProcGetInvolvePlayer(_Inst,1);
		
		PROC
		ProcGetInvolvePlayer((INTEGER)_Inst,(INTEGER)_Index)
		AND
		DialogGetInvolvedPlayer(_Inst,_Index,_Player)
		AND
		IntegerSum(_Index,1,_New)
		THEN
		DB_DialogPlayers(_Inst,_Player,_Index);
		ProcGetInvolvePlayer(_Inst,_New);
		
		PROC
		ProcSetDialogGoldCheckAmount((STRING)_Dialog)
		AND
		DB_DialogMoneyTransfer((INTEGER)_Index,(STRING)_Dialog,(INTEGER)_Amount,(INTEGER)_CheckSpeakerIndex,(INTEGER)_)
		AND
		DB_FirstGoal_MoneyDialogVar(_Index,_MoneyVarName)
		AND
		DB_FirstGoal_CheckPocketGoldSpeakerVar(_Index,_SpeakerVarName)
		THEN
		DialogSetVariableInt(_Dialog,_MoneyVarName,_Amount);
		DialogSetVariableInt(_Dialog,_SpeakerVarName,_CheckSpeakerIndex);
		
		//END_REGION
		
		//REGION Player NPC seeing
		
		PROC
		ProcCheckIfOtherPlayersCanSeeNPC((CHARACTERGUID)_,(CHARACTERGUID)_)
		AND
		DB_OtherPlayersSee(_Npc)
		THEN
		NOT DB_OtherPlayersSee(_Npc);
		
		PROC
		ProcCheckIfOtherPlayersCanSeeNPC((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc)
		AND
		_Other.DB_IsPlayer()
		AND
		_Other!=_Player 
		AND
		DB_Sees(_OtherPlayer,_Npc)
		THEN
		DB_OtherPlayersSee(_Npc);
		
		
		//END_REGION
		
		//REGION Player trigger checking
		
		QRY
		QryCheckOtherPlayersInTrigger((CHARACTERGUID)_Player,(TRIGGERGUID)_CheckTrigger)
		AND
		_Other.DB_IsPlayer()
		AND
		_Other!=_Player 
		AND
		DB_InRegion(_Other, _CheckTrigger)
		THEN
		DB_NOOP(1);
		
		//END_REGION
		
		//REGION Player triggers
		PROC
		ProcTriggerRegisterForPlayers((TRIGGERGUID)_Trig)
		AND
		GetRegion(_Trig,_Level)
		THEN
		DB_PlayerTriggers(_Level,_Trig);
		ProcDoTriggerRegisterForPlayers(_Level,_Trig);
		
		PROC
		ProcDoTriggerRegisterForPlayers((STRING)_Level,(TRIGGERGUID)_Trig)
		AND
		ObjectExists(_Trig,0)
		THEN
		DB_PlayerTriggerToRegister(_Level,_Trig);
		
		PROC
		ProcDoTriggerRegisterForPlayers((STRING)_Level,(TRIGGERGUID)_Trig)
		AND
		NOT DB_PlayerTriggerToRegister(_Level,_Trig)
		THEN
		TriggerRegisterForPlayers(_Trig);
		
		PROC
		ProcTriggerUnregisterForPlayers((TRIGGERGUID)_Trig)
		AND
		DB_PlayerTriggers(_Level,_Trig)
		AND
		ObjectExists(_Trig,0)
		THEN
		DB_PlayerTriggerToUnregister(_Level,_Trig);
		
		PROC
		ProcTriggerUnregisterForPlayers((TRIGGERGUID)_Trig)
		AND
		DB_PlayerTriggers(_Level,_Trig)
		AND
		NOT DB_PlayerTriggerToUnregister(_Level,_Trig)
		THEN
		TriggerUnregisterForPlayers(_Trig);
		
		PROC
		ProcTriggerUnregisterForPlayers((TRIGGERGUID)_Trig)
		AND
		DB_PlayerTriggers(_Level,_Trig)
		THEN
		NOT DB_PlayerTriggers(_Level,_Trig);
		
		PROC
		ProcRegisterPlayerTriggers((CHARACTERGUID)_Char)
		AND
		DB_PlayerTriggers(_Level,_Trig)
		AND
		ObjectExists(_Trig,0)
		THEN
		DB_PlayerTriggerToRegisterForCharacter(_Char,_Level,_Trig);
		
		PROC
		ProcRegisterPlayerTriggers((CHARACTERGUID)_Char)
		AND
		DB_PlayerTriggers(_Level,_Trig)
		AND
		NOT DB_PlayerTriggerToRegisterForCharacter(_Char,_Level,_Trig)
		THEN
		TriggerRegisterForCharacter(_Trig,_Char);
		
		PROC
		ProcUnRegisterPlayerTriggers((CHARACTERGUID)_Char)
		AND
		DB_PlayerTriggers(_Level,_Trig)
		AND
		ObjectExists(_Trig,0)
		THEN
		DB_PlayerTriggerToUnregisterForCharacter(_Char,_Level,_Trig);
		
		PROC
		ProcUnRegisterPlayerTriggers((CHARACTERGUID)_Char)
		AND
		DB_PlayerTriggers(_Level,_Trig)
		AND
		NOT DB_PlayerTriggerToUnregisterForCharacter(_Char,_Level,_Trig)
		THEN
		TriggerUnregisterForCharacter(_Trig,_Char);
		
		IF
		DB_PlayerTriggerToUnregisterForCharacter(_Char,_Level,_Trig)
		THEN
		NOT DB_PlayerTriggerToRegisterForCharacter(_Char,_Level,_Trig);
		
		IF
		DB_PlayerTriggerToRegisterForCharacter(_Char,_Level,_Trig)
		THEN
		NOT DB_PlayerTriggerToUnregisterForCharacter(_Char,_Level,_Trig);
		
		IF
		DB_PlayerTriggerToUnregister(_Level,_Trig)
		THEN
		NOT DB_PlayerTriggerToRegister(_Level,_Trig);
		
		IF
		DB_PlayerTriggerToRegister(_Level,_Trig)
		THEN
		NOT DB_PlayerTriggerToUnregister(_Level,_Trig);
		
		IF
		RegionStarted(_Level)
		THEN
		ProcRegisterTriggersForRegion(_Level);
		ProcUnregisterTriggersForRegion(_Level);
		ProcRegisterTriggersForCharacters(_Level);
		ProcUnregisterTriggersForCharacters(_Level);
		
		PROC
		ProcRegisterTriggersForRegion((STRING)_Level)
		AND
		DB_PlayerTriggerToRegister(_Level,_Trig)
		THEN
		TriggerRegisterForPlayers(_Trig);
		NOT DB_PlayerTriggerToRegister(_Level,_Trig);
		
		PROC
		ProcUnregisterTriggersForRegion((STRING)_Level)
		AND
		DB_PlayerTriggerToUnregister(_Level,_Trig)
		THEN
		TriggerUnregisterForPlayers(_Trig);
		NOT DB_PlayerTriggerToUnregister(_Level,_Trig);
		
		PROC
		ProcRegisterTriggersForCharacters((STRING)_Level)
		AND
		DB_PlayerTriggerToRegisterForCharacter(_Char,_Level,_Trig)
		THEN
		TriggerRegisterForCharacter(_Trig,_Char);
		NOT DB_PlayerTriggerToRegisterForCharacter(_Char,_Level,_Trig);
		
		PROC
		ProcUnregisterTriggersForCharacters((STRING)_Level)
		AND
		DB_PlayerTriggerToUnregisterForCharacter(_Char,_Level,_Trig)
		THEN
		TriggerUnregisterForCharacter(_Trig,_Char);
		NOT DB_PlayerTriggerToUnregisterForCharacter(_Char,_Level,_Trig);
		
		PROC
		ProcSetupGenericTimers((CHARACTERGUID)_Char)
		AND
		GetUUID(_Char,_UUID)
		AND
		StringConcatenate(_UUID,"_genTim",_Timer)
		THEN
		DB_GenericDialogTimers(_Char,_Timer);
		
		PROC
		ProcRemoveGenericTimer((CHARACTERGUID)_Char)
		AND
		DB_GenericDialogTimers(_Char,_Timer)
		THEN
		NOT DB_GenericDialogTimers(_Char,_Timer);
		//END_REGION
		
		// Since storyeditor orders goals alphabetically, this is the only way to make sure this goal comes first in story.div
		// This is important because Osiris uses rule order to execute alternatives.
		
		///////////////////////////////////////////////////////////////////////
		// buffer time
		
		PROC
		StartTimeOfDayTimerLoop()
		AND
		DB_GameHour(_Msec)
		THEN
		TimerLaunch("TimeOfDay",_Msec);
		
		IF
		TimerFinished("TimeOfDay")
		AND
		DB_GameHour(_Msec)
		AND
		DB_Time(_,_Hour,_)
		AND
		IntegerSum(_Hour,1,_NewHour)
		AND
		IntegerModulo(_NewHour,24,_Mod)
		THEN
		TimerLaunch("TimeOfDay",_Msec);
		NewHour(_Mod);
		
		PROC
		NewHour(0) 
		AND		// Day shifts to tomorrow
		DB_Time((INTEGER)_Day,(INTEGER)_,(INTEGER)_) 
		AND
		IntegerSum(_Day,1,_DayP1)
		THEN
		UpdateTime(_DayP1,0);
		
		PROC
		NewHour((INTEGER)_Hour) 
		AND
		_Hour != 0
		AND							// Day stays today
		DB_Time(_Day,_,_)
		THEN
		UpdateTime(_Day,_Hour);
		
		// Asserts Time(_Day,_Hour,...) with ... = the corresponding total hours = 24*(_Day - 1) + _Hour
		PROC
		UpdateTime((INTEGER)_Day,(INTEGER)_Hour) 
		AND
		DB_Time(_D,_H,_TH) 
		AND
		// calc new total hours:
		IntegerSubtract(_Day,1,_DM1) 
		AND
		IntegerProduct(_DM1,24,_T1) 
		AND
		IntegerSum(_T1,_Hour,_NewTH)
		THEN
		NOT DB_Time(_D,_H,_TH);
		DB_Time(_Day,_Hour,_NewTH);
		
		//TODO: commented stuff
		/*
		//
		IF		NewHalfHour(ENGINE_GAME,0)
		THEN	SetNewHalfHour(24);
		IF		NewHalfHour(ENGINE_GAME,_HH) AND _HH != 0
		THEN	SetNewHalfHour(_HH);
		
		PROC	SetNewHalfHour((INTEGER)_HH) AND
			HalfHour((INTEGER)_CurrentHH,(INTEGER)_TotalHH) AND
			IntegerSubtract(FUNCTION_Math,_HH,_CurrentHH,_Delta) AND
			// Normally, Delta == 1
			IntegerSum(FUNCTION_Math,_CurrentHH,_Delta,_CurrentHHPDelta) AND
			IntegerSum(FUNCTION_Math,_TotalHH,_Delta,_TotalHHPDelta)
		THEN	NOT HalfHour(_CurrentHH,_TotalHH);
			HalfHour(_CurrentHHPDelta,_TotalHHPDelta);
		
		
		///////////////////////////////////////////////////////////////////////
		// Buffer player invisibility
		IF		PlayerTurnsInvisible(NPC_Hero,1)
		THEN	PlayerIsInvisible(1);
		
		IF		PlayerTurnsInvisible(NPC_Hero,0)
		THEN	NOT PlayerIsInvisible(1);
		*/ 
		///////////////////////////////////////////////////////////////////////
		// Buffer seeing events
		// Note: "Sees" is asserted as soon as the "NpcSees" is generated. So you can use
		// "Sees" as event as well. Major difference: NpcSees ignores player invisibility.
		
		// Buffer effects of player movement:
		// (NpcSees actually means: "player starts seeing", NpcDoesNotSee means "players ends seeing")
		IF		
		CharacterSawCharacter(_Player,_Npc)
		AND
		_Player.DB_IsPlayer()
		THEN
		DB_Sees(_Player, _Npc);
		
		//DB_Dead NPCs are blind
		IF
		CharacterDying(_Npc)
		AND
		DB_Sees(_Npc,_Player)
		THEN
		NOT DB_Sees(_Npc,_Player);
		
		IF		
		CharacterLostSightOfCharacter(_Player,_Npc)
		AND
		_Player.DB_IsPlayer()
		THEN	
		NOT DB_Sees(_Player, _Npc);
		NOT DB_Sees(_Npc, _Player);
		
		// Bring player invisibility into account (neglect for story npcs):
		IF		
		DB_Sees(_Npc, _Player) 
		AND
		_Player.DB_IsPlayer()
		AND 
		DB_PlayerIsInvisible(_Player,1) 
		AND 
		NOT DB_IsStoryNpc(_Npc)
		THEN
		NOT DB_Sees(_Npc, _Player);
		
		IF		
		DB_Sees(_Player, _Npc)
		AND
		_Player.DB_IsPlayer()
		AND 
		NOT DB_PlayerIsInvisible(_Player,1)
		THEN	
		DB_Sees(_Npc, _Player);
		
		IF		
		DB_Sees(_Player, _Npc)
		AND
		_Player.DB_IsPlayer()
		AND 
		DB_IsStoryNpc(_Npc)
		THEN
		DB_Sees(_Npc, _Player);
		
		/*
		///////////////////////////////////////////////////////////////////////
		// Buffer dialog distance (analogous to seeing events)
		
		// Buffer effects of player movement:
		IF		NpcEntersDialogDistance(NPC_Hero, _Npc)
		THEN	InDialogDistance(NPC_Hero, _Npc);
		
		IF		NpcLeavesDialogDistance(NPC_Hero, _Npc)
		THEN	NOT InDialogDistance(NPC_Hero, _Npc);
			NOT InDialogDistance(_Npc, NPC_Hero);
		
		// Bring player invisibility into account (neglect for story npcs):
		IF		InDialogDistance(_Npc, NPC_Hero) AND PlayerIsInvisible(1) AND NOT DB_IsStoryNpc(_Npc)
		THEN	NOT InDialogDistance(_Npc, NPC_Hero);
		
		IF		InDialogDistance(NPC_Hero, _Npc) AND NOT PlayerIsInvisible(1)
		THEN	InDialogDistance(_Npc, NPC_Hero);
		
		IF		InDialogDistance(NPC_Hero, _Npc) AND DB_IsStoryNpc(_Npc)
		THEN	InDialogDistance(_Npc, NPC_Hero);
		*/
		
		///////////////////////////////////////////////////////////////////////
		// Buffer region events
		IF	
		CharacterEnteredTrigger(_Npc,_Region)
		THEN
		DB_InRegion(_Npc, _Region);
		
		IF
		CharacterLeftTrigger(_Npc,_Region)
		THEN
		NOT DB_InRegion(_Npc, _Region);
		DB_WasInRegion(_Npc,_Region);
		
		///////////////////////////////////////////////////////////////////////
		// Buffer killed
		IF
		CharacterDying(_Npc)
		THEN
		DB_Dead(_Npc);
		
		IF
		CharacterDied(_Npc)
		AND
		NOT DB_Dead(_Npc)
		THEN
		DB_Dead(_Npc);
		
		IF
		CharacterResurrected(_Npc)
		THEN
		NOT DB_Dead(_Npc);
		
		//TODO: comments
		/*
		// Engine does not generate NpcDoesNotSee for dead npcs anymore, so we have to clean up ourself:
		IF		NpcKilled(_Npc) AND Sees(_Npc,_OtherNpc)
		THEN	NOT Sees(_Npc,_OtherNpc);
		IF		NpcKilled(_Npc) AND Sees(_OtherNpc,_Npc)
		THEN	NOT Sees(_OtherNpc,_Npc);
		// Cleanup InDialogDistance
		IF		NpcKilled(_Npc) AND InDialogDistance(_Npc,_OtherNpc)
		THEN	NOT InDialogDistance(_Npc,_OtherNpc);
		IF		NpcKilled(_Npc) AND InDialogDistance(_OtherNpc,_Npc)
		THEN	NOT InDialogDistance(_OtherNpc,_Npc);
		*/
		
		/*			///This Breaks a lot of things especially Arrest in Generics
		IF
		CharacterDied(_Npc)
		AND
		DB_InRegion(_Npc,_Region)
		THEN
		NOT DB_InRegion(_Npc,_Region);
		*/
		
		//TODO: comments
		/*
		IF		NpcResurrected((NPC)_Npc)
		THEN	NOT DB_Dead(_Npc);
		
		IF		NpcKilledBy(_Npc,NPC_Hero)
		THEN	HeroKilled(_Npc);
		*/
		///////////////////////////////////////////////////////////////////////
		// Cleanup DB_InRegion of npc (not the hero) if they are killed
		// test for _Npc != NPC_Hero explicitely added because debug cheat key "F1" does not
		// resurrect NPC_Hero, hence he remains "dead" although he can play on, enter regions, etc...
		IF
		DB_Dead(_Npc) 
		AND
		NOT _Npc.DB_IsPlayer()
		AND 
		DB_InRegion(_Npc,_Region)
		THEN
		NOT DB_InRegion(_Npc,_Region);
		
		IF
		DB_Dead(_Npc) 
		AND
		DB_DeadEvent(_Npc,(STRING)_Event)
		AND
		GlobalGetFlag(_Event,0)
		THEN
		GlobalSetFlag(_Event);
		
		IF
		RegionStarted((STRING)_NewRegion) 
		THEN
		DB_CurrentLevel(_NewRegion);
		
		IF
		RegionEnded((STRING)_Region)
		THEN
		NOT DB_CurrentLevel(_Region);
		
		
		//REGION OneshotTriggers
		IF
		DB_OneShotPlayerTrigger(_Trigger)
		THEN
		ProcTriggerRegisterForPlayers(_Trigger);
		
		IF
		DB_OneShotPlayerOnlyTrigger(_Trigger)
		THEN
		TriggerRegisterForPlayers(_Trigger);
		
		IF
		CharacterEnteredTrigger(_Player,_Trigger)
		AND
		DB_OneShotPlayerOnlyTrigger(_Trigger)
		THEN
		TriggerUnregisterForPlayers(_Trigger);
		NOT DB_OneShotPlayerOnlyTrigger(_Trigger);
		ProcOneShotTriggerEntered(_Player,_Trigger);
		
		PROC
		RemoveOneShotTrigger((TRIGGERGUID)_Trigger)
		AND
		DB_OneShotPlayerTrigger(_Trigger)
		THEN
		ProcTriggerUnregisterForPlayers(_Trigger);
		NOT DB_OneShotPlayerTrigger(_Trigger);
		
		IF
		CharacterEnteredTrigger(_Player,_Trigger)
		AND
		DB_OneShotPlayerTrigger(_Trigger)
		AND
		_Player.DB_IsPlayer()
		THEN
		RemoveOneShotTrigger(_Trigger);
		ProcOneShotTriggerEntered(_Player,_Trigger);
		
		PROC
		ProcOneShotTriggerEntered((CHARACTERGUID)_Player,(TRIGGERGUID)_Trigger)
		THEN
		DB_NOOP(1);
		//END_REGION
		
		//REGION _Global_CharacterAnimations
		// Flush player character animations that may be ongoing at the end of a dialog
		IF
		DialogEnded(_,_Dialog)
		AND
		DB_GLO_CharacterAnimationForDialog(_Character,_Dialog)
		AND
		DB_IsPlayer(_Character)
		THEN
		CharacterFlushQueue(_Character);
		
		IF
		DialogEnded(_,_Dialog)
		AND
		DB_GLO_CharacterAnimationForDialog(_Character,_Dialog)
		THEN
		// The animation may be purged by other code and hence never finish -> this DB would never be unset
		NOT DB_GLO_CharacterAnimationForDialog(_Character,_Dialog);
		//END_REGION
		
	}
	EXIT
	{
		
	}
}
Goal(12).Title("_AdvancedSneakTriggerSpotter");
Goal(12)
{
	INIT
	{
		//REGION AdvancedSneakTriggerSupport
		DB_SneakTriggerVars(1,"SpottedTrigger");
		DB_SneakTriggerVars(2,"SpottedTrigger1");
		DB_SneakTriggerVars(3,"SpottedTrigger2");
		DB_SneakTriggerVars(4,"SpottedTrigger3");
		//END_REGION
		
	}
	KB
	{
		//REGION AdvancedSneakTrigger
		IF
		DB_AdvancedSneakTriggerSpotter((TRIGGERGUID)_Trigger,(CHARACTERGUID)_Char)
		THEN
		ProcSetSneakyTriggerVar(_Char,_Trigger);
		PROC
		ProcSetSneakyTriggerVar((CHARACTERGUID)_Char,(TRIGGERGUID)_Trigger)
		AND
		NOT DB_SneakyTriggersCounter(_Char,_)
		THEN
		DB_SneakyTriggersCounter(_Char,0);
		PROC
		ProcSetSneakyTriggerVar((CHARACTERGUID)_Char,(TRIGGERGUID)_Trigger)
		AND
		DB_SneakyTriggersCounter(_Char,_Count)
		AND
		IntegerSum(_Count,1,_New)
		AND
		DB_SneakTriggerVars(_New,_Var)
		THEN
		DB_SneakyTriggersCounter(_Char,_New);
		NOT DB_SneakyTriggersCounter(_Char,_Count);
		SetVarObject(_Char,_Var,_Trigger);
		ProcTriggerRegisterForPlayers(_Trigger);
		
		IF
		StoryEvent((CHARACTERGUID)_Char, "GLO_AdvancedSpotterSneaker")
		AND
		GetVarObject(_Char, "SpottedDude", _Player)
		THEN
		ProcCharSpottedByChar((CHARACTERGUID)_Player,_Char);
		ProcReceiveActivatedTriggers(_Char,_Player);
		ProcLockSpotting(_Char);
		
		PROC
		ProcReceiveActivatedTriggers((CHARACTERGUID)_Char,(CHARACTERGUID)_Player)
		AND
		DB_AdvancedSneakTriggerSpotter((TRIGGERGUID)_Trigger, (CHARACTERGUID)_Char)
		AND
		DB_InRegion(_Player,_Trigger)
		THEN
		ProcCharInTriggerSpotted(_Player,_Trigger);
		ProcCharInTriggerSpottedByChar(_Player,_Trigger,_Char);
		
		PROC
		ProcCharSpottedByChar((CHARACTERGUID)_Player,(CHARACTERGUID)_Spotter)
		THEN
		DB_NOOP(1);
		
		PROC
		ProcLockSpotting((CHARACTERGUID)_Char)
		THEN
		SetVarInteger(_Char, "SpottedCounter", 1);
		
		PROC
		ProcCleanUpAdvancedSneakTriggers((CHARACTERGUID)_Char)
		AND
		DB_AdvancedSneakTriggerSpotter((TRIGGERGUID)_Trigger, (CHARACTERGUID)_Char)
		THEN
		NOT DB_AdvancedSneakTriggerSpotter(_Trigger, _Char);
		SetVarInteger(_Char, "SpottedCounter", 1);
		
		PROC
		ProcTriggerUnregisterForPlayers((TRIGGERGUID)_Trigger)
		AND
		DB_AdvancedSneakTriggerSpotter((TRIGGERGUID)_Trigger, (CHARACTERGUID)_Char)
		THEN
		NOT DB_AdvancedSneakTriggerSpotter((TRIGGERGUID)_Trigger, (CHARACTERGUID)_Char);
		IF
		DB_SpotterGroup((CHARACTERGUID)_Char,(STRING)_Name)
		AND
		_Player.DB_isPlayer()
		THEN
		SetVarInteger(_Player,_Name,0);
		SetVarFixedString(_Char,"SpotterGroup",_Name);
		//END_REGION
		
	}
	EXIT
	{
		
	}
}
Goal(13).Title("_Attitude");
Goal(13)
{
	INIT
	{
		
	}
	KB
	{
		PROC
		ProcMakeNPCHostile((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc)
		AND
		CharacterIsDead(_Npc,0)
		AND
		CharacterIsPlayer(_Player,1)
		AND
		CharacterIsPlayer(_Npc,0)
		THEN
		CharacterSetTemporaryHostileRelation(_Npc,_Player);
		
		PROC
		ProcMakeNPCHostile((CHARACTERGUID)_Npc,(CHARACTERGUID)_Player)
		AND
		CharacterIsDead(_Npc,0)
		AND
		CharacterIsPlayer(_Player,1)
		THEN
		CharacterSetTemporaryHostileRelation(_Npc,_Player);
		
		PROC
		ProcMakeNPCHostile((CHARACTERGUID)_Npc,(CHARACTERGUID)_OtherNpc)
		AND
		CharacterIsDead(_Npc,0)
		AND
		CharacterIsDead(_OtherNpc,0)
		AND
		CharacterIsPlayer(_Npc,0)
		AND
		CharacterIsPlayer(_OtherNpc,0)
		THEN
		CharacterSetTemporaryHostileRelation(_Npc,_OtherNpc);
		
	}
	EXIT
	{
		
	}
}
Goal(14).Title("_CRIME_CrimeBribes");
Goal(14)
{
	INIT
	{
		// small (0) or big (1) bribe, max player level, min amount, max-min amount
		DB_CrimeBribes_BaseAmountUntilLevel(0,50,10,1);
		DB_CrimeBribes_BaseAmountUntilLevel(0,70,20,5);
		DB_CrimeBribes_BaseAmountUntilLevel(0,150,50,9);
		DB_CrimeBribes_BaseAmountUntilLevel(0,245,65,13);
		DB_CrimeBribes_BaseAmountUntilLevel(0,410,110,16);
		DB_CrimeBribes_BaseAmountUntilLevel(0,600,200,18);
		DB_CrimeBribes_BaseAmountUntilLevel(0,800,250,20);
		
		DB_CrimeBribes_BaseAmountUntilLevel(1,125,25,1);
		DB_CrimeBribes_BaseAmountUntilLevel(1,175,30,5);
		DB_CrimeBribes_BaseAmountUntilLevel(1,400,60,9);
		DB_CrimeBribes_BaseAmountUntilLevel(1,625,100,13);
		DB_CrimeBribes_BaseAmountUntilLevel(1,1100,200,16);
		DB_CrimeBribes_BaseAmountUntilLevel(1,1600,400,18);
		DB_CrimeBribes_BaseAmountUntilLevel(1,2200,500,20);
		
		DB_CrimeBribes_SevereCrimes("Murder");
		DB_CrimeBribes_SevereCrimes("SneakMurder");
		DB_CrimeBribes_SevereCrimes("Assault");
		
	}
	KB
	{
		//REGION Polymorph statuses are handled in the DivinityOrigins mod, so add a dummy proxy and a fallback
		// Actual implemetation in GLOBAL_ShapeShifting in DivinityOrigins
		QRY
		QRY_GLOBAL_Shapeshifting_GetPolymorphStatus((CHARACTERGUID)_Player)
		THEN
		DB_NOOP(1);
		
		// If we're not using DivinityOrigins, ensure we still define a
		// generic DB_GLOBAL_Shapeshifting_PolymorphStatus() as fallback
		QRY
		QRY_GLOBAL_Shapeshifting_GetPolymorphStatus_Fallback((CHARACTERGUID)_Player)
		AND
		NOT DB_GLOBAL_Shapeshifting_PolymorphStatus(_)
		THEN
		DB_GLOBAL_Shapeshifting_PolymorphStatus("");
		
		// Ensure fallback query always succeeds
		QRY
		QRY_GLOBAL_Shapeshifting_GetPolymorphStatus_Fallback((CHARACTERGUID)_Player)
		THEN
		DB_NOOP(1);
		
		//END_REGION
		
		//REGION Determine whether we select from the high or low bribes
		// Possible selectors:
		// * Tension
		// * Severity of the crime
		// * Number of times this person has been bribed
		
		// Determine severity
		// Return value:
		//   Severe crime: DB_CrimeBribes_CrimeSeverity(1)
		//   Non-sever crime: DB_CrimeBribes_CrimeSeverity(0)
		QRY
		QRY_CrimeBribes_CrimeGetSeverity((STRING)_CrimeType)
		AND
		DB_CrimeBribes_CrimeSeverity(_Severity)
		THEN
		NOT DB_CrimeBribes_CrimeSeverity(_Severity);
		
		QRY
		QRY_CrimeBribes_CrimeGetSeverity((STRING)_CrimeType)
		AND
		DB_CrimeBribes_SevereCrimes(_CrimeType)
		THEN
		DB_CrimeBribes_CrimeSeverity(1);
		
		QRY
		QRY_CrimeBribes_CrimeGetSeverity((STRING)_CrimeType)
		AND
		NOT DB_CrimeBribes_CrimeSeverity(1)
		THEN
		DB_CrimeBribes_CrimeSeverity(0);
		
		// Keep track of number of times this criminal has bribed this interrogator
		IF
		ObjectFlagSet(_Flag,_Speaker,_ID)
		AND
		DB_ItemEvents_TransferFlagToMoneyVarIndex(_Flag,_MoneyVarIndex)
		AND
		DB_DialogName(_Dialog,_ID)
		AND
		DB_CrimeTriggers_GeneralBribeDialog(_MoneyVarIndex,_Dialog)
		AND
		DB_DialogMoneyTransfer(_MoneyVarIndex,_Dialog,_,_,_TargetDBIndex)
		AND
		DB_DialogPlayers(_ID,_Player,1)
		AND
		DB_DialogNPCs(_ID,_NPC,_TargetDBIndex)
		AND
		QRY_GLOBAL_Shapeshifting_GetPolymorphStatus(_Player)
		AND
		QRY_GLOBAL_Shapeshifting_GetPolymorphStatus_Fallback(_Player)
		AND
		DB_GLOBAL_Shapeshifting_PolymorphStatus(_Race)
		THEN
		PROC_CrimeBribes_RecordBribe((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player,_Race);
		
		PROC
		PROC_CrimeBribes_RecordBribe((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player,(STRING)_Race)
		AND
		DB_CrimeBribes_PairBribes(_NPC,_Player,_Race,_Bribes)
		AND
		IntegerSum(_Bribes,1,_NewBribes)
		THEN
		NOT DB_CrimeBribes_PairBribes(_NPC,_Player,_Race,_Bribes);
		DB_CrimeBribes_PairBribes(_NPC,_Player,_Race,_NewBribes);
		
		PROC
		PROC_CrimeBribes_RecordBribe((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player,(STRING)_Race)
		AND
		NOT DB_CrimeBribes_PairBribes(_NPC,_Player,_Race,_)
		THEN
		DB_CrimeBribes_PairBribes(_NPC,_Player,_Race,1);
		
		// Return value:
		//   Bribed too many times: DB_CrimeBribes_BribedTooManyTimes(1)
		//   Not yet bribed or a few times: DB_CrimeBribes_BribedTooManyTimes(0)
		QRY
		QRY_CrimeBribes_BribedTooManyTimes((CHARACTERGUID)_Interrogator,(CHARACTERGUID)_Criminal,(STRING)_Race)
		AND
		DB_CrimeBribes_BribedTooManyTimes(_Result)
		THEN
		NOT DB_CrimeBribes_BribedTooManyTimes(_Result);
		
		QRY
		QRY_CrimeBribes_BribedTooManyTimes((CHARACTERGUID)_Interrogator,(CHARACTERGUID)_Criminal,(STRING)_Race)
		AND
		DB_CrimeBribes_PairBribes(_Interrogator,_Criminal,_Race,_Bribes)
		AND
		// This is the number of times the NPC has already been bribed before. So starting at the second time,
		// it's too much
		_Bribes >= 1
		THEN
		DB_CrimeBribes_BribedTooManyTimes(1);
		
		QRY
		QRY_CrimeBribes_BribedTooManyTimes((CHARACTERGUID)_Interrogator,(CHARACTERGUID)_Criminal,(STRING)_Race)
		AND
		NOT DB_CrimeBribes_BribedTooManyTimes(1)
		THEN
		DB_CrimeBribes_BribedTooManyTimes(0);
		
		// Get bribe base & variation from table
		PROC
		PROC_CrimeBribes_GetBribeBounds((INTEGER)_HighBase,(INTEGER)_InterrogatorLevel)
		AND
		DB_CrimeBribes_GetBribeBounds(_Base,_Rand)
		THEN
		NOT DB_CrimeBribes_GetBribeBounds(_Base,_Rand);
		
		PROC
		PROC_CrimeBribes_GetBribeBounds((INTEGER)_HighBase,(INTEGER)_InterrogatorLevel)
		AND
		DB_CrimeBribes_BaseAmountUntilLevel(_HighBase,_Base,_Rand,1)
		THEN
		DB_CrimeBribes_GetBribeBounds(_Base,_Rand);
		
		PROC
		PROC_CrimeBribes_GetBribeBounds((INTEGER)_HighBase,(INTEGER)_InterrogatorLevel)
		AND
		DB_CrimeBribes_BaseAmountUntilLevel(_HighBase,_Base,_Rand,_Level)
		AND
		DB_CrimeBribes_GetBribeBounds(_OldBase,_OldRand)
		AND
		_Level <= _InterrogatorLevel
		AND
		_Base > _OldBase
		THEN
		NOT DB_CrimeBribes_GetBribeBounds(_OldBase,_OldRand);
		DB_CrimeBribes_GetBribeBounds(_Base,_Rand);
		
		// Get the bribe amount
		// Once a bribe amount has been set for an NPC, it stays that way until it switches from low to high
		// base, or if the level of the NPC changes (it doesn't make sense if the bribe changes randomly for
		// the same NPC with every new encounter).
		PROC
		PROC_CrimeBribes_GetBribe((CHARACTERGUID)_NPC,(INTEGER)_NPCLevel,(INTEGER)_HighBase)
		AND
		NOT DB_CrimeBribes_GetBribe_NPC(_NPC,_NPCLevel,_HighBase,_)
		THEN
		PROC_CrimeBribes_GetBribeBounds((INTEGER)_HighBase,(INTEGER)_NPCLevel);
		
		PROC
		PROC_CrimeBribes_GetBribe((CHARACTERGUID)_NPC,(INTEGER)_NPCLevel,(INTEGER)_HighBase)
		AND
		NOT DB_CrimeBribes_GetBribe_NPC(_NPC,_NPCLevel,_HighBase,_)
		AND
		DB_CrimeBribes_GetBribeBounds(_Base,_Rand)
		AND
		Random(_Rand,_Variation)
		AND
		IntegerSum(_Base,_Variation,_Bribe)
		THEN
		DB_CrimeBribes_GetBribe_NPC(_NPC,_NPCLevel,_HighBase,_Bribe);
		
		// return value
		PROC
		PROC_CrimeBribes_GetBribe((CHARACTERGUID)_NPC,(INTEGER)_NPCLevel,(INTEGER)_HighBase)
		AND
		DB_CrimeBribes_GetBribe(_Bribe)
		THEN
		NOT DB_CrimeBribes_GetBribe(_Bribe);
		
		PROC
		PROC_CrimeBribes_GetBribe((CHARACTERGUID)_NPC,(INTEGER)_NPCLevel,(INTEGER)_HighBase)
		AND
		DB_CrimeBribes_GetBribe_NPC(_NPC,_NPCLevel,_HighBase,_Bribe)
		THEN
		DB_CrimeBribes_GetBribe(_Bribe);
		
		// Set the bribe amount
		IF
		CrimeInterrogationRequest(_RegionID,_ID,_Interrogator,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_Dialog)
		THEN
		PROC_CrimeBribes_SetCrimeBribe(_ID,_Interrogator,_Criminal1,_Dialog);
		
		PROC
		ProcStartCrimeDialog((INTEGER)_CrimeID,(STRING)_CrimeDialog,1,(CHARACTERGUID)_NPC,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		THEN
		PROC_CrimeBribes_SetCrimeBribe(_CrimeID,_NPC,_Criminal,_CrimeDialog);
		
		//REGION Generic callback to disable bribing by certain (classes of) characters
		PROC
		PROC_CrimeBribes_SetCrimeBribe((INTEGER)_CrimeID,(CHARACTERGUID)_Interrogator,(CHARACTERGUID)_Criminal,(STRING)_Dialog)
		AND
		QRY_CrimeBribes_DisableBribe(_CrimeID,_Interrogator,_Criminal,_Dialog)
		THEN
		DB_CrimeBribesDisabledBribe(_Interrogator,_Criminal,_Dialog);
		ObjectSetFlag(_Interrogator,"GEB_BribeDisabled");
		//END_REGION
		
		//REGION Only allow bribing a few times
		QRY
		QRY_CrimeBribes_DisableBribe((INTEGER)_CrimeID,(CHARACTERGUID)_Interrogator,(CHARACTERGUID)_Criminal,(STRING)_Dialog)
		AND
		QRY_GLOBAL_Shapeshifting_GetPolymorphStatus(_Criminal)
		AND
		DB_GLOBAL_Shapeshifting_PolymorphStatus(_Race)
		AND
		QRY_CrimeBribes_BribedTooManyTimes(_Interrogator,_Criminal,_Race)
		AND
		DB_CrimeBribes_BribedTooManyTimes(1)
		THEN
		DB_NOOP(1);
		
		IF
		DialogEnded(_Dialog,_ID)
		AND
		DB_CrimeBribesDisabledBribe(_Interrogator,_Criminal,_Dialog)
		AND
		DB_DialogNPCs(_ID,_Interrogator,_)
		AND
		DB_DialogPlayers(_ID,_Criminal,_)
		THEN
		NOT DB_CrimeBribesDisabledBribe(_Interrogator,_Criminal,_Dialog);
		ObjectClearFlag(_Interrogator,"GEB_BribeDisabled");
		//END_REGION
		
		// Low bribe if this NPC has not yet been bribed too many time by this player,
		// AND it's not a severe crime, AND tension is below warning threshold.
		// Otherwise higher bribe.
		PROC
		PROC_CrimeBribes_SetCrimeBribe((INTEGER)_CrimeID,(CHARACTERGUID)_Interrogator,(CHARACTERGUID)_Criminal,(STRING)_Dialog)
		AND
		DB_CrimeTriggers_GeneralBribeDialog(_MoneyVarIndex,_Dialog)
		AND
		CrimeGetType(_CrimeID,_CrimeType)
		AND
		QRY_CrimeBribes_CrimeGetSeverity(_CrimeType)
		AND
		QRY_GLOBAL_Shapeshifting_GetPolymorphStatus(_Criminal)
		AND
		DB_GLOBAL_Shapeshifting_PolymorphStatus(_Race)
		AND
		QRY_CrimeBribes_BribedTooManyTimes(_Interrogator,_Criminal,_Race)
		AND
		DB_CrimeBribes_CrimeSeverity(_Severity)
		AND
		DB_CrimeBribes_BribedTooManyTimes(_TooManyTimes)
		AND
		IntegerMax(_Severity,_TooManyTimes,_HighBase1)
		AND
		CrimeIsTensionOverWarningTreshold(_Criminal,_TensionOverWarning)
		AND
		IntegerMax(_HighBase1,_TensionOverWarning,_HighBaseFinal)
		AND
		CharacterGetLevel(_Interrogator,_InterrogatorLevel)
		THEN
		PROC_CrimeBribes_GetBribe(_Interrogator,_InterrogatorLevel,_HighBaseFinal);
		
		PROC
		PROC_CrimeBribes_SetCrimeBribe((INTEGER)_CrimeID,(CHARACTERGUID)_Interrogator,(CHARACTERGUID)_Criminal,(STRING)_Dialog)
		AND
		DB_CrimeTriggers_GeneralBribeDialog(_MoneyVarIndex,_Dialog)
		AND
		DB_CrimeBribes_GetBribe(_Bribe)
		THEN
		// Will clear previous entries, if any
		DB_DialogMoneyTransfer(_MoneyVarIndex,_Dialog,_Bribe);
		
	}
	EXIT
	{
		
	}
}
Goal(15).Title("_CRIME_CrimeTriggers");
Goal(15)
{
	INIT
	{
		//Warning As AD
		// TODO: what if a custom warning is an AD? Does it get added in there?
		DB_CrimeWarningIsAD("GEB_AD_Noticed_EscapedPrisonerHelpful");
		DB_CrimeWarningIsAD("GEB_AD_Noticed_Vandalise");
		DB_CrimeWarningIsAD("GEB_AD_Noticed_Sneaking");
		DB_CrimeWarningIsAD("GEB_AD_Noticed_Smelly");
		DB_CrimeWarningIsAD("GEB_AD_Noticed_Weapons");
		DB_CrimeWarningIsAD("GEB_AD_Noticed_AttackedAnimal");
		DB_CrimeWarningIsAD("GEB_AD_Noticed_KilledAnimal");
		DB_CrimeWarningIsAD("GEB_AD_Noticed_AnimalAttackedAnimal");
		DB_CrimeWarningIsAD("GEB_AD_Help_Thief");
		DB_CrimeWarningIsAD("GEB_AD_FTJ_Noticed_NoCollar");
		DB_CrimeWarningIsAD("GEB_AD_Noticed_SummonAssault");
		DB_CrimeWarningIsAD("GEB_AD_Noticed_SummonVandalise");
		DB_CrimeWarningIsAD("GEB_AD_Noticed_Summon");
		DB_CrimeWarningIsAD("GEB_AD_Noticed_Polymorphed");
		DB_CrimeWarningIsAD("GEB_Lohse_AD_Warning_SummonAssault");
		DB_CrimeWarningIsAD("GEB_Ifan_AD_Warning_SummonAssault");
		DB_CrimeWarningIsAD("GEB_Sebille_AD_Warning_SummonAssault");
		DB_CrimeWarningIsAD("GEB_RedPrince_AD_Warning_SummonAssault");
		DB_CrimeWarningIsAD("GEB_AD_NoticedDeadSilentMonk");
		
		// Trespassing
		DB_TrespassingCrimes("Trespassing");
		
		// Murder
		
		// Killing -> Murder type mapping : Sneak or not, Killed animal or not, killer is Summon or not
		DB_CRIME_MurderType(0,0,0,"Murder");
		DB_CRIME_MurderType(1,0,0,"SneakMurder");
		DB_CRIME_MurderType(0,1,0,"KilledAnimal");
		DB_CRIME_MurderType(1,1,0,"SneakKilledAnimal");
		DB_CRIME_MurderType(0,0,1,"SummonMurder");
		DB_CRIME_MurderType(1,0,1,"SummonMurder");
		DB_CRIME_MurderType(0,1,1,"SummonKilledAnimal");
		DB_CRIME_MurderType(1,1,1,"SummonKilledAnimal");
		
		DB_CRIME_ForbiddenStatus("LYING");
		
		//For Status Reactions
		DB_StatusReaction("SMELLY","Smelly");
		DB_StatusReaction("UNSHEATHED","WeaponsDrawn");
		
		//Ingnore Vandalise Tags
		DB_IgnoreVandaliseTag("JUNK");
		DB_IgnoreVandaliseTag("IGNOREVANDALISE");
		
		//Bribe
		DB_CrimeTriggers_GeneralBribeDialog(1,"GEB_Arrest");
		DB_CrimeTriggers_GeneralBribeDialog(1,"GEB_Arrest_EscapedPrison");
		DB_CrimeTriggers_GeneralBribeDialog(1,"GEB_Arrest_Theft");
		DB_CrimeTriggers_GeneralBribeDialog(1,"GEB_Arrest_Trespassing");
		DB_CrimeTriggers_GeneralBribeDialog(1,"GEB_Arrest_UseForbiddenItem");
		DB_CrimeTriggers_GeneralBribeDialog(1,"GEB_Arrest_Vandalise");
		DB_CrimeTriggers_GeneralBribeDialog(1,"GEB_Interrogation");
		DB_CrimeTriggers_GeneralBribeDialog(1,"GEB_Interrogation_Assault");
		DB_CrimeTriggers_GeneralBribeDialog(1,"GEB_Interrogation_Murder");
		DB_CrimeTriggers_GeneralBribeDialog(1,"GEB_Interrogation_PickPocketNoticed");
		DB_CrimeTriggers_GeneralBribeDialog(1,"GEB_Interrogation_Steal");
		DB_CrimeTriggers_GeneralBribeDialog(1,"GEB_Interrogation_UsedSource");
		DB_CrimeTriggers_GeneralBribeDialog(1,"GEB_Interrogation_Vandalise");
		DB_CrimeTriggers_GeneralBribeDialog(1,"GEB_Warning_PickPocketFailed_EvidenceCheck");
		
		//Pickpocket
		DB_CannotPickpocketTags("ANIMAL");
		DB_CannotPickpocketTags("ELEMENTAL");
		DB_CannotPickpocketTags("GHOST");
		DB_CannotPickpocketTags("VOIDLING");
		DB_CannotPickpocketTags("VOIDSECT");
		DB_CannotPickpocketTags("VOID_SOLDIER");
		DB_CannotPickpocketTags("ALANBIRD");
		DB_CannotPickpocketTags("MOLESPITTER");
		DB_CannotPickpocketTags("NIGHTFANG");
		DB_CannotPickpocketTags("VOIDWOLF");
		DB_CannotPickpocketTags("FLESH_GOLEM");
		DB_CannotPickpocketTags("BLOCK_PICKPOCKET");
		
		//Attitude Change
		DB_CrimeAttitudeChange("SourceMagic",-5);
		DB_CrimeAttitudeChange("Murder",-30);
		DB_CrimeAttitudeChange("SpiritTalk",-1);
		DB_CrimeAttitudeChange("Assault",-20);
		DB_CrimeAttitudeChange("Steal",-5);
		DB_CrimeAttitudeChange("PickPocketFailed",-5);
		DB_CrimeAttitudeChange("PickPocket",-10);
		DB_CrimeAttitudeChange("ItemDestroy",-15);
		DB_CrimeAttitudeChange("Vandalise",-10);
		DB_CrimeAttitudeChange("VandaliseNoOwner",-5);
		DB_CrimeAttitudeChange("Trespassing",-5);
		DB_CrimeAttitudeChange("UseForbiddenItem",-5);
		DB_CrimeAttitudeChange("MoveForbiddenItem",-5);
		DB_CrimeAttitudeChange("AttackAnimal",-5);
		
		//Evidence check
		DB_EvidenceCheckInWarning("GEB_Warning_PickPocketFailed_EvidenceCheck");
		DB_EvidenceCheckInWarning("RC_WH_DijinnItem_Interrogation");
		
		DB_NeutralTagIgnore("GHOST");
		
		DB_Negate(0,1);
		DB_Negate(1,0);
		
		DB_IgnoreDamageSources("SurfaceMove");
		DB_IgnoreDamageSources("StatusTick");
		DB_IgnoreDamageSources("SurfaceStatus");
		DB_IgnoreDamageSources("Offhand");
		
		//crime tpyes that should be kept in sync when the parent crime is enabled/disabled
		DB_LinkedCrimes("Assault","SummonAssault");
		DB_LinkedCrimes("Assault","IncapacitatedAssault");
		
		DB_LinkedCrimes("Murder","KilledAnimal");
		DB_LinkedCrimes("Murder","SneakKilledAnimal");
		DB_LinkedCrimes("Murder","SneakMurder");
		DB_LinkedCrimes("Murder","SummonMurder");
		DB_LinkedCrimes("Murder","SummonKilledAnimal");
		
		//crime warning to hostile dialogs
		DB_CrimeWarningHostileADs("GEB_Warning_Theft","GEB_AD_Help_Thief");
		DB_CrimeWarningHostileADs("GEB_Warning_UseForbiddenItem","GEB_AD_Help_UseForbiddenItem");
		
		// Apply item effect to user
		DB_ItemStatusAffectCharacterOnUse("BURNING");
		DB_ItemStatusAffectCharacterOnUse("SHOCKED");
		
		// Score increase based on invisible/sneaking. At 9 or more, NPC will realise where attack
		// comes from and go to location of that attacker. Script will actually increase by one more
		// for implementation reasons (taken into account in values of table below)
		//                                  sneaking   invisible   base increase   random increase (mod, 1 -> 0)
		DB_CRIME_CrimeLocationScoreIncrease(0,         0,          3,              1);
		DB_CRIME_CrimeLocationScoreIncrease(1,         0,          2,              1);
		DB_CRIME_CrimeLocationScoreIncrease(0,         1,          1,              1);
		DB_CRIME_CrimeLocationScoreIncrease(1,         1,          2,              1);
		
		// score >= threshold -> perform action
		DB_CRIME_CrimeLocationScore_GoToAttackerThreshold(9);
		DB_CRIME_CrimeLocationScore_StartAttackingThreshold(13);
		// health < threshold -> perform action
		DB_CRIME_Assault_HealthStartAttackingThreshold(80);
		
		// Flee crime reactions
		DB_CRIME_FleeReaction("CRIME_Flee");
		DB_CRIME_FleeReaction("CRIME_FleeWithAD");
		
	}
	KB
	{
		PROC
		Proc_GameModeStarted("GameMaster",_)
		THEN
		GoalCompleted;
		
		//REGION Register crime wrapper to handle ignoring crimes
		QRY
		QRY_CRIME_CrimeTriggers_IsCrimeFamilyMember((STRING)_Crime,(STRING)_CrimeOrFamily)
		AND
		_Crime == _CrimeOrFamily
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_CRIME_CrimeTriggers_IsCrimeFamilyMember((STRING)_Crime,(STRING)_CrimeOrFamily)
		AND
		DB_LinkedCrimes(_CrimeOrFamily,_Crime)
		THEN
		DB_NOOP(1);
		
		// Built-in:
		// * DB_AssaultIgnoreFor(_Witness, _Victim): _Witness ignores all Assault crimes against victim
		// * DB_AssaultFamilyIgnoreFor((CHARACTERGUID)_AnyWitness,(CHARACTERGUID)_Victim): _Witness ignores all Assault-like crimes against victim
		PROC
		PROC_CRIME_CrimeTriggers_GetSilentWitnessesForCrime((INTEGER)_CrimeID,(CHARACTERGUID)_Perpetrator,"Assault",(GUIDSTRING)_Evidence,(CHARACTERGUID)_Victim)
		AND
		DB_AssaultIgnoreFor((CHARACTERGUID)_AnyWitness,(CHARACTERGUID)_Victim)
		THEN
		DB_CRIME_CrimeTriggers_SilentWitnessesForCrime(_AnyWitness);
		
		PROC
		PROC_CRIME_CrimeTriggers_GetSilentWitnessesForCrime((INTEGER)_CrimeID,(CHARACTERGUID)_Perpetrator,(STRING)_CrimeType,(GUIDSTRING)_Evidence,(CHARACTERGUID)_Victim)
		AND
		DB_AssaultFamilyIgnoreFor((CHARACTERGUID)_AnyWitness,(CHARACTERGUID)_Victim)
		AND
		QRY_CRIME_CrimeTriggers_IsCrimeFamilyMember(_CrimeType,"Assault")
		THEN
		DB_CRIME_CrimeTriggers_SilentWitnessesForCrime(_AnyWitness);
		
		PROC
		ProcCharacterRegisterCrime((CHARACTERGUID)_Char,(STRING)_CrimeType,(GUIDSTRING)_Evidence,(CHARACTERGUID)_CrimeWitness,(INTEGER)_CrimeID,(CHARACTERGUID)_Victim)
		THEN
		ProcCharacterRegisterCrimeHandleIgnoresBefore(_Char,_CrimeType,_Evidence,_CrimeWitness,_CrimeID,_Victim);
		
		PROC
		ProcCharacterRegisterCrimeWithPosition((CHARACTERGUID)_Char,(STRING)_CrimeType,(GUIDSTRING)_Evidence,(CHARACTERGUID)_CrimeWitness,(REAL)_X,(REAL)_Y,(REAL)_Z,(INTEGER)_CrimeID,(CHARACTERGUID)_Victim)
		THEN
		ProcCharacterRegisterCrimeHandleIgnoresBefore(_Char,_CrimeType,_Evidence,_CrimeWitness,_CrimeID,_Victim);
		
		PROC
		ProcCharacterRegisterCrimeHandleIgnoresBefore((CHARACTERGUID)_Char,(STRING)_CrimeType,(GUIDSTRING)_Evidence,(CHARACTERGUID)_CrimeWitness,(INTEGER)_CrimeID,(CHARACTERGUID)_Victim)
		THEN
		PROC_CRIME_CrimeTriggers_GetSilentWitnessesForCrime(_CrimeID,_Char,_CrimeType,_Evidence,_Victim);
		
		// If this crime is specifically already disabled for the witness, don't do anything special
		PROC
		ProcCharacterRegisterCrimeHandleIgnoresBefore((CHARACTERGUID)_Char,(STRING)_CrimeType,(GUIDSTRING)_Evidence,(CHARACTERGUID)_CrimeWitness,(INTEGER)_CrimeID,(CHARACTERGUID)_Victim)
		AND
		DB_CRIME_CrimeTriggers_SilentWitnessesForCrime(_AnyWitness)
		AND
		DB_CharacterCrimeDisabled(_AnyWitness,_CrimeType)
		THEN
		// Undefine here instead of directly checking in QRY_CRIME_CrimeTriggers_GetSilentWitnessesForCrime(), as
		// QRY_CRIME_CrimeTriggers_GetSilentWitnessesForCrime() may be overloaded in user goals and may miss such checks
		NOT DB_CRIME_CrimeTriggers_SilentWitnessesForCrime(_AnyWitness);
		
		// If all crimes are disabled for the witness and this one is not enabled, don't do anything special either
		PROC
		ProcCharacterRegisterCrimeHandleIgnoresBefore((CHARACTERGUID)_Char,(STRING)_CrimeType,(GUIDSTRING)_Evidence,(CHARACTERGUID)_CrimeWitness,(INTEGER)_CrimeID,(CHARACTERGUID)_Victim)
		AND
		DB_CRIME_CrimeTriggers_SilentWitnessesForCrime(_AnyWitness)
		AND
		DB_CharacterAllCrimesDisabled(_AnyWitness)
		AND
		NOT DB_CharacterCrimeEnabled(_AnyWitness,_CrimeType)
		THEN
		NOT DB_CRIME_CrimeTriggers_SilentWitnessesForCrime(_AnyWitness);
		
		// The remaining witnesses that need to temporarily ignore this crime
		PROC
		ProcCharacterRegisterCrimeHandleIgnoresBefore((CHARACTERGUID)_Char,(STRING)_CrimeType,(GUIDSTRING)_Evidence,(CHARACTERGUID)_CrimeWitness,(INTEGER)_CrimeID,(CHARACTERGUID)_Victim)
		AND
		DB_CRIME_CrimeTriggers_SilentWitnessesForCrime(_AnyWitness)
		THEN
		CharacterDisableCrime(_AnyWitness,_CrimeType);
		
		// Register the crime
		PROC
		ProcCharacterRegisterCrime((CHARACTERGUID)_Char,(STRING)_CrimeType,(GUIDSTRING)_Evidence,(CHARACTERGUID)_CrimeWitness,(INTEGER)_CrimeID,(CHARACTERGUID)_Victim)
		THEN
		CharacterRegisterCrime(_Char,_CrimeType,_Evidence,_CrimeWitness,_CrimeID);
		
		PROC
		ProcCharacterRegisterCrimeWithPosition((CHARACTERGUID)_Char,(STRING)_CrimeType,(GUIDSTRING)_Evidence,(CHARACTERGUID)_CrimeWitness,(REAL)_X,(REAL)_Y,(REAL)_Z,(INTEGER)_CrimeID,(CHARACTERGUID)_Victim)
		THEN
		CharacterRegisterCrimeWithPosition(_Char,_CrimeType,_Evidence,_CrimeWitness,_X,_Y,_Z,_CrimeID);
		
		PROC
		ProcCharacterRegisterCrime((CHARACTERGUID)_Char,(STRING)_CrimeType,(GUIDSTRING)_Evidence,(CHARACTERGUID)_CrimeWitness,(INTEGER)_CrimeID,(CHARACTERGUID)_Victim)
		THEN
		ProcCharacterRegisterCrimeHandleIgnoresAfter(_CrimeType,_CrimeID);
		
		PROC
		ProcCharacterRegisterCrimeWithPosition((CHARACTERGUID)_Char,(STRING)_CrimeType,(GUIDSTRING)_Evidence,(CHARACTERGUID)_CrimeWitness,(REAL)_X,(REAL)_Y,(REAL)_Z,(INTEGER)_CrimeID,(CHARACTERGUID)_Victim)
		THEN
		ProcCharacterRegisterCrimeHandleIgnoresAfter(_CrimeType,_CrimeID);
		
		// Ignore the crime for the silent witnesses (they will also ignore it in case they were not a witness
		// and discover the crime scene later on) and then re-enable the crime for them
		PROC
		ProcCharacterRegisterCrimeHandleIgnoresAfter((STRING)_CrimeType,(INTEGER)_CrimeID)
		AND
		DB_CRIME_CrimeTriggers_SilentWitnessesForCrime(_AnyWitness)
		THEN
		CrimeIgnoreCrime(_CrimeID,_AnyWitness);
		CharacterEnableCrime(_AnyWitness,_CrimeType);
		NOT DB_CRIME_CrimeTriggers_SilentWitnessesForCrime(_AnyWitness);
		//END_REGION
		
		//REGION Stopping Dialog
		IF
		CharacterOnCrimeSensibleActionNotification(_NPC,_Region,_CrimeID,_PriorityName,_Dialog,_Criminal,_Criminal2,_Criminal3,_Criminal4,_)
		THEN
		ProcForceStopDialog(_NPC); //This will only stop ADs Code stops interactive ones and SensibleAction will fail if he can't react to it
		//END_REGION
		
		//REGION Behaviour scripts disabling
		IF
		CrimeDisabled(_Char,"")
		THEN
		ProcCharacterDisableAllCrimes((CHARACTERGUID)_Char);
		
		IF
		CrimeDisabled(_Char,_Crime)
		AND
		_Crime != ""
		THEN
		ProcCharacterDisableCrime(_Char,_Crime);
		
		IF
		CrimeEnabled(_Char,"")
		THEN
		ProcCharacterEnableAllCrimes((CHARACTERGUID)_Char);
		
		IF
		CrimeEnabled(_Char,_Crime)
		AND
		_Crime != ""
		THEN
		ProcCharacterEnableCrime(_Char,_Crime);
		//END_REGION
		
		//REGION Crime Enabling/Disabling
		PROC
		ProcCharacterDisableAllCrimes((CHARACTERGUID)_Char)
		THEN
		DB_CharacterAllCrimesDisabled(_Char);
		CharacterDisableAllCrimes(_Char);
		
		PROC
		ProcCharacterEnableAllCrimes((CHARACTERGUID)_Char)
		THEN
		NOT DB_CharacterAllCrimesDisabled(_Char);
		CharacterEnableAllCrimes(_Char);
		
		PROC
		ProcCharacterEnableCrime((CHARACTERGUID)_Char,(STRING)_Crime)
		THEN
		DB_CharacterCrimeEnabled(_Char,_Crime);
		CharacterEnableCrime(_Char,_Crime);
		
		PROC
		ProcCharacterDisableCrime((CHARACTERGUID)_Char,(STRING)_Crime)
		THEN
		DB_CharacterCrimeDisabled(_Char,_Crime);
		CharacterDisableCrime(_Char,_Crime);
		
		IF
		DB_CharacterCrimeEnabled(_Char,_Crime)
		THEN
		NOT DB_CharacterCrimeDisabled(_Char,_Crime);
		
		IF
		DB_CharacterCrimeDisabled(_Char,_Crime)
		THEN
		NOT DB_CharacterCrimeEnabled(_Char,_Crime);
		
		//END_REGION
		
		//REGION Warning
		IF
		DB_CrimeReaction_DoNotWarn((CHARACTERGUID)_Char)
		THEN
		DB_CrimeReaction_DoNotWarn2(_Char);
		CharacterEnableCrimeWarnings(_Char,0);
		
		IF
		DB_CrimeReaction_DoNotWarn2((CHARACTERGUID)_Char)
		AND
		NOT DB_CrimeReaction_DoNotWarn(_Char)
		THEN
		NOT DB_CrimeReaction_DoNotWarn2(_Char);
		CharacterEnableCrimeWarnings(_Char,1);
		
		
		// Crime Warning Request events
		//--- Generic Warning:
		IF
		CharacterOnCrimeSensibleActionNotification(_Warner,_CrimeRegion,_CrimeID,"CRIME_OsirisReaction",_WarningDialog,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_)
		AND
		NOT DB_CrimeReaction_DoNotWarn(_Warner)
		AND
		CrimeGetType(_CrimeID,_CrimeName)
		AND
		NOT DB_CrimeReaction_CustomWarning((CHARACTERGUID)_Warner,_CrimeName,(STRING)_)
		THEN
		ProcCrimeCheckCrimeTypeForFlags(_CrimeID,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_CrimeName,_WarningDialog);
		ProcCrimeSetupWarning(_CrimeRegion,_CrimeID,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_WarningDialog);
		ProcCrimeWarningTryStopDialogs(_CrimeID,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_WarningDialog);
		ProcCrimeCheckStartedWarning(_CrimeID,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_WarningDialog);
		
		
		//--- Custom Warning:
		IF
		CharacterOnCrimeSensibleActionNotification(_Warner,_CrimeRegion,_CrimeID,"CRIME_OsirisReaction",_WarningDialog,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_)
		AND
		NOT DB_CrimeReaction_DoNotWarn(_Warner)
		//AND
		//NOT QryCrimeOnlyHasSummonCriminal(_CrimeID,_Criminal1,_Criminal2,_Criminal3,_Criminal4)
		AND
		CrimeGetType(_CrimeID,_CrimeName)
		AND
		DB_CrimeReaction_CustomWarning(_Warner,_CrimeName,_CustomDialog)
		THEN
		ProcCrimeCheckCrimeTypeForFlags(_CrimeID,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_CrimeName,_CustomDialog);
		ProcCrimeSetupWarning(_CrimeRegion,_CrimeID,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_CustomDialog);
		ProcCrimeWarningTryStopDialogs(_CrimeID,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_CustomDialog);
		ProcCrimeCheckStartedWarning(_CrimeID,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_CustomDialog);
		
		//--- No Warning
		IF
		CharacterOnCrimeSensibleActionNotification(_Warner,_CrimeRegion,_CrimeID,"CRIME_OsirisReaction",_Dialog,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_)
		AND
		DB_CrimeReaction_DoNotWarn(_Warner)
		THEN
		CrimeConfrontationDone(_CrimeID,_Warner);
		
		
		//--- 1) Prepare a DB and set flag
		PROC
		ProcCrimeCheckCrimeTypeForFlags((INTEGER)_CrimeID,(CHARACTERGUID)_Warner,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_CrimeType,(STRING)_WarningDialog)
		AND
		QryCrimeIsVandalismWithTension(_CrimeType)
		THEN
		ProcCrimeSetupCountFlag(_CrimeID,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4,"Vandalise",_WarningDialog);
		
		PROC
		ProcCrimeCheckCrimeTypeForFlags((INTEGER)_CrimeID,(CHARACTERGUID)_Warner,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_CrimeType,(STRING)_WarningDialog)
		AND
		NOT QryCrimeIsVandalismWithTension(_CrimeType)
		THEN
		ProcCrimeSetupCountFlag(_CrimeID,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_CrimeType,_WarningDialog);
		
		QRY
		QryCrimeIsVandalismWithTension((STRING)_CrimeType)
		AND
		_CrimeType == "Vandalise"
		THEN
		DB_NOOP(1);
		
		QRY
		QryCrimeIsVandalismWithTension((STRING)_CrimeType)
		AND
		_CrimeType == "ItemDestroy"
		THEN
		DB_NOOP(1);
		
		PROC
		ProcCrimeSetupCountFlag((INTEGER)_CrimeID,(CHARACTERGUID)_Warner,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_CrimeType,(STRING)_WarningDialog)
		AND
		CrimeGetTension(_CrimeID,_Tension)
		AND
		_Tension > 0
		THEN
		DB_Crime_RequestedDialogWithTension(_CrimeType,_WarningDialog,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4);
		
		PROC
		ProcCrimeSetupCountFlag((INTEGER)_CrimeID,(CHARACTERGUID)_Warner,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_CrimeType,(STRING)_WarningDialog)
		AND
		NOT DB_Crime_WarningCount(_,_CrimeType,_Criminal1,_Warner) // DB doesn't exist yet, meaning the player has never been warned by that NPC with that dialog (i.e. for that crime)
		THEN
		DB_Crime_WarningCount(1,_CrimeType,_Criminal1,_Warner);
		
		PROC
		ProcCrimeSetupCountFlag((INTEGER)_CrimeID,(CHARACTERGUID)_Warner,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_CrimeType,(STRING)_WarningDialog)
		AND
		DB_Crime_RequestedDialogWithTension(_CrimeType,_WarningDialog,_Warner,_,_,_,_)
		AND
		DB_Crime_WarningCount(_Pos,_CrimeType,_Player,_Warner)
		AND
		IntegertoString(_Pos,_StrPos)
		AND
		StringConcatenate("GEB_CrimeWarning_",_StrPos,_Flag)
		THEN
		ObjectSetFlag(_Player,_Flag);
		
		IF
		DialogEnded(_Dialog,_ID)
		AND
		DB_TemporaryHostilityAfterDialog(_,_ID)
		AND
		DB_CrimeWarningHostileADs(_Dialog,_AD)
		AND
		DB_DialogNPCs(_ID,_NPC,1)
		THEN
		Proc_StartDialog(1,_AD,_NPC);
		
		//--- 2) Set variables in the Warner's script
		PROC
		ProcCrimeSetupWarning((STRING)_CrimeRegion,(INTEGER)_CrimeID,(CHARACTERGUID)_Warner,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_WarningDialog)
		THEN
		ObjectClearFlag(_Criminal1,"GEB_CrimeHasEvidenceInInventory");
		
		PROC
		ProcCrimeSetupWarning((STRING)_CrimeRegion,(INTEGER)_CrimeID,(CHARACTERGUID)_Warner,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_WarningDialog)
		AND
		CrimeGetType(_CrimeID,"Steal")
		AND
		CrimeFindEvidence(_CrimeID,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4,1,_,_)
		THEN
		DB_Interrogation(_Warner,_CrimeID);
		ObjectSetFlag(_Criminal1,"GEB_CrimeHasEvidenceInInventory");
		
		PROC
		ProcCrimeSetupWarning((STRING)_CrimeRegion,(INTEGER)_CrimeID,(CHARACTERGUID)_Warner,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_WarningDialog)
		THEN
		SetVarInteger(_Warner,"CrimeID",_CrimeID);
		SetVarFixedString(_Warner,"RegionID",_CrimeRegion);
		DB_Crime_SetupCriminalIndex(_CrimeID,1);
		ProcCrimeSetupValidWarningCriminals(_CrimeID,_Warner,_Criminal1);
		ProcCrimeSetupValidWarningCriminals(_CrimeID,_Warner,_Criminal2);
		ProcCrimeSetupValidWarningCriminals(_CrimeID,_Warner,_Criminal3);
		ProcCrimeSetupValidWarningCriminals(_CrimeID,_Warner,_Criminal4);
		ProcCrimeSetupNullWarningCriminals(_CrimeID,_Warner);
		
		PROC
		ProcCrimeSetupValidWarningCriminals((INTEGER)_CrimeID,(CHARACTERGUID)_Warner,(CHARACTERGUID)_Criminal)
		AND
		NOT QryCrimeCharacterIsSummonOrNull(_Criminal)
		AND
		DB_Crime_SetupCriminalIndex(_CrimeID,_Index)
		AND
		IntegertoString(_Index,_StrIndex)
		AND
		StringConcatenate("Criminal",_StrIndex,_Param)
		AND
		IntegerSum(_Index,1,_NewIndex)
		THEN
		SetVarObject(_Warner,_Param,_Criminal);
		NOT DB_Crime_SetupCriminalIndex(_CrimeID,_Index);
		DB_Crime_SetupCriminalIndex(_CrimeID,_NewIndex);
		
		PROC
		ProcCrimeSetupNullWarningCriminals((INTEGER)_CrimeID,(CHARACTERGUID)_Warner)
		AND
		DB_Crime_SetupCriminalIndex(_CrimeID,_Index)
		AND
		_Index < 5 //goes from 1 to 4
		AND
		IntegertoString(_Index,_StrIndex)
		AND
		StringConcatenate("Criminal",_StrIndex,_Param)
		AND
		IntegerSum(_Index,1,_NewIndex)
		THEN
		ClearVarObject(_Warner,_Param);
		NOT DB_Crime_SetupCriminalIndex(_CrimeID,_Index);
		DB_Crime_SetupCriminalIndex(_CrimeID,_NewIndex);
		ProcCrimeSetupNullWarningCriminals(_CrimeID,_Warner);
		
		PROC
		ProcCrimeSetupWarning((STRING)_CrimeRegion,(INTEGER)_CrimeID,(CHARACTERGUID)_Warner,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_WarningDialog)
		AND
		DB_Crime_SetupCriminalIndex(_CrimeID,_Index)
		THEN
		NOT DB_Crime_SetupCriminalIndex(_CrimeID,_Index);
		
		PROC
		ProcCrimeSetupWarning((STRING)_CrimeRegion,(INTEGER)_CrimeID,(CHARACTERGUID)_Warner,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_WarningDialog)
		AND
		GetPosition(_Warner,_x,_y,_z)
		THEN
		SetVarFloat3(_Warner,"NPCOrgPos",_x,_y,_z);
		
		PROC
		ProcCrimeSetupWarning((STRING)_CrimeRegion,(INTEGER)_CrimeID,(CHARACTERGUID)_Warner,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_WarningDialog)
		AND
		DB_EvidenceCheckInWarning(_WarningDialog) //Sets up Interrogation DB for evidence check in warning Dialog
		THEN
		DB_Crime_Interrogation(_CrimeID,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_WarningDialog);
		
		
		//--- 3) Try to stop the warner's dialog
		PROC
		ProcCrimeWarningTryStopDialogs((INTEGER)_CrimeID,(CHARACTERGUID)_Warner,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_WarningDialog)
		AND
		DB_CrimeWarningIsAD(_WarningDialog)
		THEN
		ProcCrimeInterruptStoryDialogs(_CrimeID,_WarningDialog,0,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4);
		
		PROC
		ProcCrimeWarningTryStopDialogs((INTEGER)_CrimeID,(CHARACTERGUID)_Warner,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_WarningDialog)
		AND
		NOT DB_CrimeWarningIsAD(_WarningDialog)
		THEN
		ProcCrimeInterruptStoryDialogs(_CrimeID,_WarningDialog,1,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4);
		
		
		//--- 4) Verify if the crime dialog succeeded to start and clean up
		PROC
		ProcCrimeCheckStartedWarning((INTEGER)_CrimeID,(CHARACTERGUID)_Warner,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_WarningDialog)
		AND
		DB_Crime_FailedToInterruptStoryDialogs(_CrimeID,_WarningDialog,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4)
		AND
		DB_Crime_RequestedDialogWithTension(_CrimeType,_WarningDialog,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4)
		AND
		DB_Crime_WarningCount(_Pos,_Dialog,_Player,_Warner)
		AND
		IntegertoString(_Pos,_StrPos)
		AND
		StringConcatenate("GEB_CrimeWarning_",_StrPos,_Flag)
		THEN
		NOT DB_Crime_RequestedDialogWithTension(_CrimeType,_WarningDialog,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4);
		ObjectClearFlag(_Player,_Flag,0);
		
		PROC
		ProcCrimeCheckStartedWarning((INTEGER)_CrimeID,(CHARACTERGUID)_Warner,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_WarningDialog)
		AND
		DB_Crime_FailedToInterruptStoryDialogs(_CrimeID,_WarningDialog,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4)
		THEN
		ProcCrimeFailedToInterruptStoryDialog(_CrimeID,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_WarningDialog);
		NOT DB_Crime_FailedToInterruptStoryDialogs(_CrimeID,_WarningDialog,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4);
		CrimeConfrontationDone(_CrimeID,_Warner);
		
		PROC
		ProcCrimeCheckStartedWarning((INTEGER)_CrimeID,(CHARACTERGUID)_Warner,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_WarningDialog)
		AND
		DB_Crime_FailedToInterruptStoryDialogs(_CrimeID,_WarningDialog,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4)
		AND
		CrimeIsContinuous(_CrimeID,1)
		THEN
		ProcCrimeFailedToInterruptStoryDialog(_CrimeID,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_WarningDialog);
		NOT DB_Crime_FailedToInterruptStoryDialogs(_CrimeID,_WarningDialog,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4);
		
		PROC // Useful for custom scripting
		ProcCrimeFailedToInterruptStoryDialog((INTEGER)_CrimeID,(CHARACTERGUID)_Warner,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_WarningDialog)
		THEN
		DB_NOOP(1);
		
		PROC
		ProcCrimeCheckStartedWarning((INTEGER)_CrimeID,(CHARACTERGUID)_Warner,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_WarningDialog)
		AND
		DB_Crime_FailedToInterruptStoryDialogs(_AnyCrimeID,_AnyWarningDialog,_AnyWarner,_AnyCriminal1,_AnyCriminal2,_AnyCriminal3,_AnyCriminal4) // Clean up anything that could have failed previously
		THEN
		NOT DB_Crime_FailedToInterruptStoryDialogs(_AnyCrimeID,_AnyWarningDialog,_AnyWarner,_AnyCriminal1,_AnyCriminal2,_AnyCriminal3,_AnyCriminal4);
		
		
		//--- Count the warnings done:
		IF
		DialogEnded(_Dialog,_Inst)
		AND
		DB_Crime_RequestedDialogWithTension(_CrimeType,_Dialog,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4)
		AND
		DB_DialogNPCs(_Inst,_Warner,_)
		AND
		DB_DialogPlayers(_Inst,_Player,_)
		AND
		DB_Crime_WarningCount(_Pos,_CrimeType,(CHARACTERGUID)_Player,_Warner)
		AND
		IntegertoString(_Pos,_StrPos)
		AND
		StringConcatenate("GEB_CrimeWarning_",_StrPos,_Flag)
		AND
		ObjectGetFlag(_Player,_Flag,1)
		AND
		IntegerSum(_Pos,1,_NewPos)
		THEN
		NOT DB_Crime_RequestedDialogWithTension(_CrimeType,_Dialog,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4);
		ObjectClearFlag(_Player,_Flag,0);
		NOT DB_Crime_WarningCount(_Pos,_CrimeType,_Player,_Warner);
		DB_Crime_WarningCount(_NewPos,_CrimeType,_Player,_Warner);
		
		IF
		DB_Crime_WarningCount(_NewPos,_CrimeType,_Player,_Warner)
		AND
		_NewPos > 3
		THEN
		NOT DB_Crime_WarningCount(_NewPos,_CrimeType,_Player,_Warner);
		DB_Crime_WarningCount(3,_CrimeType,_Player,_Warner);
		
		IF
		DialogEnded(_Dialog,_Inst)
		AND
		DB_CrimeWarner(_CrimeID,_Warner,_Dialog)
		AND
		DB_DialogNPCs(_Inst,_Warner,_)
		THEN
		CrimeConfrontationDone(_CrimeID,_Warner);
		NOT DB_CrimeWarner(_CrimeID,_Warner,_Dialog);
		
		IF
		AutomatedDialogEnded(_Dialog,_Inst)
		AND
		DB_Crime_RequestedDialogWithTension(_CrimeType,_Dialog,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4)
		AND
		DB_DialogNPCs(_Inst,_Warner,_)
		AND
		DB_Crime_WarningAD_Target(_CrimeType,_Warner,_Criminal1)
		AND
		DB_Crime_WarningCount(_Pos,_CrimeType,(CHARACTERGUID)_Player,_Warner)
		AND
		IntegertoString(_Pos,_StrPos)
		AND
		StringConcatenate("GEB_CrimeWarning_",_StrPos,_Flag)
		AND
		ObjectGetFlag(_Player,_Flag,1)
		AND
		IntegerSum(_Pos,1,_NewPos)
		THEN
		NOT DB_Crime_RequestedDialogWithTension(_CrimeType,_Dialog,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4);
		ObjectClearFlag(_Player,_Flag,0);
		NOT DB_Crime_WarningCount(_Pos,_CrimeType,_Player,_Warner);
		DB_Crime_WarningCount(_NewPos,_CrimeType,_Player,_Warner);
		
		IF
		AutomatedDialogEnded(_Dialog,_Inst)
		AND
		DB_DialogNPCs(_Inst,_Warner,_)
		AND
		DB_Crime_WarningAD_Target(_CrimeType,(CHARACTERGUID)_Warner,(CHARACTERGUID)_TargetPlayer)
		THEN
		NOT DB_Crime_WarningAD_Target(_CrimeType,_Warner,_TargetPlayer);
		
		PROC
		ProcHandleCrimeDialog((CHARACTERGUID)_Warner,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_Dialog,0,(INTEGER)_MarkForInteractive)
		THEN
		DB_CrimeDialogStartFailed(_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_Dialog);
		
		IF
		OnCrimeResolved(_CrimeID,_Victim,_Criminal1,_Criminal2,_Criminal3,_Criminal4)
		AND
		DB_CrimeDialogStartFailed(_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_Dialog)
		AND
		DB_Crime_RequestedDialogWithTension(_CrimeType,_Dialog,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4)
		AND
		DB_Crime_WarningCount(_Pos,_CrimeType,(CHARACTERGUID)_Player,_Warner)
		AND
		IntegertoString(_Pos,_StrPos)
		AND
		StringConcatenate("GEB_CrimeWarning_",_StrPos,_Flag)
		AND
		ObjectGetFlag(_Player,_Flag,1)
		AND
		IntegerSum(_Pos,1,_NewPos)
		THEN
		NOT DB_CrimeDialogStartFailed(_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_Dialog);
		NOT DB_Crime_RequestedDialogWithTension(_CrimeType,_Dialog,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4);
		ObjectClearFlag(_Player,_Flag,0);
		NOT DB_Crime_WarningAD_Target(_CrimeType,_Warner,_Player);
		NOT DB_Crime_WarningCount(_Pos,_CrimeType,_Player,_Warner);
		DB_Crime_WarningCount(_NewPos,_CrimeType,_Player,_Warner);
		
		
		//REGION Prepare the characters for the dialog
		PROC
		ProcHandleCrimeDialog((CHARACTERGUID)_Warner,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_WarningDialog,1,(INTEGER)_MarkForInteractive)
		AND
		GetPosition(_Warner,_x,_y,_z)
		THEN
		SetVarFloat3(_Warner,"NPCOrgPos",_x,_y,_z);
		
		PROC
		ProcHandleCrimeDialog((CHARACTERGUID)_Warner,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_WarningDialog,1,1)
		THEN
		CharacterLookAt(_Warner,_Criminal1,0);
		CharacterLookAt(_Criminal1,_Warner,0);
		CharacterMakeStoryNpc(_Warner,1);
		CharacterMakeStoryNpc(_Criminal1,1);
		CharacterMakeStoryNpc(_Criminal2,1);
		CharacterMakeStoryNpc(_Criminal3,1);
		CharacterMakeStoryNpc(_Criminal4,1);
		
		PROC
		ProcHandleCrimeDialog((CHARACTERGUID)_Warner,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_WarningDialog,1,0)
		THEN
		CharacterLookAt(_Warner,_Criminal1,0);
		
		PROC
		ProcHandleCrimeDialog((CHARACTERGUID)_Warner,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_WarningDialog,1,_)
		AND
		DB_CRIME_ForbiddenStatus(_Status)
		AND
		HasActiveStatus(_Warner,_Status,1)
		THEN
		RemoveStatus(_Warner,_Status);
		
		IF
		CharacterLeftParty(_Summon)
		AND
		ObjectExists(_Summon,1)
		AND
		IsTagged(_Summon,"SUMMON",1)
		AND
		DB_Crime_WarningCount(_Pos,_CrimeType,_Summon,_Warner)
		THEN
		NOT DB_Crime_WarningCount(_Pos,_CrimeType,_Summon,_Warner);
		
		//END_REGION
		
		//REGION Check Prison Cell in Warning
		
		IF
		CharacterOnCrimeSensibleActionNotification(_Warner,_CrimeRegion,_CrimeID,"CRIME_OsirisReaction",_Dialog,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_)
		THEN
		ObjectClearFlag(_Warner,"GEB_Arrest_HavePrison",0);
		
		IF
		CharacterOnCrimeSensibleActionNotification(_Warner,_CrimeRegion,_CrimeID,"CRIME_OsirisReaction",_Dialog,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_)
		AND
		DB_RegionPrison(_CrimeRegion,_)
		THEN
		ObjectSetFlag(_Warner,"GEB_Arrest_HavePrison");
		
		//END_REGION
		//END_REGION
		
		//REGION Summon check
		
		//--- Only summon (or null) in criminals
		QRY
		QryCrimeOnlyHasSummonCriminal((CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		QryCrimeCharacterIsSummonOrNull(_Criminal1)
		AND
		QryCrimeCharacterIsSummonOrNull(_Criminal2)
		AND
		QryCrimeCharacterIsSummonOrNull(_Criminal3)
		AND
		QryCrimeCharacterIsSummonOrNull(_Criminal4)
		THEN
		DB_NOOP(1);
		
		QRY
		QryCrimeCharacterIsSummonOrNull((CHARACTERGUID)_Char)
		AND
		QRY_CharacterIsNull(_Char)
		THEN
		DB_NOOP(1);
		
		QRY
		QryCrimeCharacterIsSummonOrNull((CHARACTERGUID)_Char)
		AND
		NOT QRY_CharacterIsNull(_Char)
		AND
		IsTagged(_Char,"SUMMON",1)
		THEN
		DB_NOOP(1);
		
		
		QRY
		QryCrimeAssailantIsNotSummon((CHARACTERGUID)_Char,(CHARACTERGUID)_Summon)
		AND
		_Char == _Summon
		THEN
		DB_NOOP(1);
		
		QRY
		QryCrimeAssailantIsNotSummon((CHARACTERGUID)_Char,(CHARACTERGUID)_Summon)
		AND
		QRY_CharacterIsNull(_Summon)
		THEN
		DB_NOOP(1);
		
		
		//--- Continuous summon crime
		IF
		CharacterJoinedParty(_Char)
		AND
		IsTagged(_Char,"SUMMON",1)
		THEN
		CharacterRegisterCrime(_Char,"ActiveSummon",NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,0);
		
		IF
		CharacterLeftParty(_Char)
		AND
		IsTagged(_Char,"SUMMON",1)
		THEN
		CharacterStopCrime(_Char,"ActiveSummon",NULL_00000000-0000-0000-0000-000000000000);
		
		//END_REGION
		
		//REGION Investigation
		// Override crime scene location (needs to be exact to ensure that e.g. in case of assault,
		// we don't have a crime scene too far for the victim to see or hear) with a separate investigation
		// location if appropriate
		IF
		StoryEvent((CHARACTERGUID)_Investigator,"CRIME_SetCrimeInvestigationPos")
		AND
		GetVarInteger(_Investigator,"CrimeID",_CrimeID)
		AND
		DB_CRIME_CrimeInvestigationPos(_CrimeID,_X,_Y,_Z)
		THEN
		// In case it's an alternate position, run rather than walk, because it means
		// that we probably cannot find anything in the default location
		SetVarInteger(_Investigator,"bool_RunToInvestigationScene",1);
		SetVarFloat3(_Investigator,"CrimePos",_X,_Y,_Z);
		
		IF
		StoryEvent((CHARACTERGUID)_Investigator,"CRIME_SetCrimeInvestigationPos")
		THEN
		CharacterSetReactionPriority(_Investigator,"WalkToCrimeScene",30000);
		//END_REGION
		
		//REGION Interrogation
		
		IF
		CrimeInterrogationRequest(_RegionID,_ID,_Interrogator,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_Dialog)
		THEN
		ObjectClearFlag(_Interrogator,"GEB_Arrest_HavePrison",0);
		
		IF
		CrimeInterrogationRequest(_RegionID,_ID,_Interrogator,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_Dialog)
		AND
		DB_RegionPrison((STRING)_RegionID,(TRIGGERGUID)_)
		THEN
		ObjectSetFlag(_Interrogator,"GEB_Arrest_HavePrison");
		
		PROC
		ProcCrimeCheckInterrogationDialog((STRING)_RegionID,(INTEGER)_ID,(CHARACTERGUID)_Interrogator,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_Dialog)
		AND
		IsTagged(_Interrogator,"NOT_MESSING_AROUND",0)
		AND
		IsTagged(_Interrogator,"ANIMAL",0)
		AND
		IsTagged(_Interrogator,"KID",0)
		THEN
		DB_Crime_InterrogationStarted(_ID,_Interrogator);
		ProcStartInterrogationDialog(_ID,_Interrogator,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_Dialog);
		
		PROC
		ProcCrimeCheckInterrogationDialog((STRING)_RegionID,(INTEGER)_ID,(CHARACTERGUID)_Interrogator,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_Dialog)
		AND
		NOT DB_Crime_InterrogationStarted(_ID,_Interrogator)
		AND
		IsTagged(_Interrogator,"NOT_MESSING_AROUND",1)
		THEN
		DB_Crime_InterrogationStarted(_ID,_Interrogator);
		//TODO: should not just interrupt the dialog here
		DialogRequestStop(_Criminal1);
		ProcMakeNPCHostile(_Criminal1,_Interrogator);
		CrimeInterrogationDone(_ID,_Interrogator,1,_Criminal1,_Criminal2,_Criminal3,_Criminal4);
		Proc_StartDialog(1,"GEB_AD_AttackHelp",_Interrogator);
		
		PROC
		ProcCrimeCheckInterrogationDialog((STRING)_RegionID,(INTEGER)_ID,(CHARACTERGUID)_Interrogator,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_Dialog)
		AND
		NOT DB_Crime_InterrogationStarted(_ID,_Interrogator)
		AND
		IsTagged(_Interrogator,"ANIMAL",1)
		THEN
		DB_Crime_InterrogationStarted(_ID,_Interrogator);
		CrimeInterrogationDone(_ID,_Interrogator,1,_Criminal1,_Criminal2,_Criminal3,_Criminal4);
		
		PROC
		ProcCrimeCheckInterrogationDialog((STRING)_RegionID,(INTEGER)_ID,(CHARACTERGUID)_Interrogator,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_Dialog)
		AND
		NOT DB_Crime_InterrogationStarted(_ID,_Interrogator)
		AND
		IsTagged(_Interrogator,"AGGRESSIVEANIMAL",1)
		THEN
		DB_Crime_InterrogationStarted(_ID,_Interrogator);
		Proc_StartDialog(1,"GEB_AD_Noticed_AnimalAttackedAnimal",_Interrogator);
		ProcMakeNPCHostile(_Interrogator,_Criminal1);
		ProcMakeNPCHostile(_Interrogator,_Criminal2);
		ProcMakeNPCHostile(_Interrogator,_Criminal3);
		ProcMakeNPCHostile(_Interrogator,_Criminal4);
		
		PROC
		ProcCrimeCheckInterrogationDialog((STRING)_RegionID,(INTEGER)_ID,(CHARACTERGUID)_Interrogator,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_Dialog)
		AND
		NOT DB_Crime_InterrogationStarted(_ID,_Interrogator)
		AND
		IsTagged(_Interrogator,"KID",1)
		THEN
		DB_Crime_InterrogationStarted(_ID,_Interrogator);
		CrimeInterrogationDone(_ID,_Interrogator,1,_Criminal1,_Criminal2,_Criminal3,_Criminal4);
		
		PROC
		ProcCrimeCheckInterrogationDialog((STRING)_RegionID,(INTEGER)_ID,(CHARACTERGUID)_Interrogator,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_Dialog)
		THEN
		NOT DB_Crime_InterrogationStarted(_ID,_Interrogator);
		
		
		//--- Interrogation requested:
		IF
		CrimeInterrogationRequest(_RegionID,_ID,_Interrogator,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_Dialog)
		THEN
		DB_InterrogationRequested(_RegionID,_ID,_Interrogator,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_Dialog);
		CharacterDisableAllCrimes(_Interrogator);
		SetHasDialog(_Interrogator,0);	//TODO: this is not great, we assume these guys have dialogs
		CharacterMoveToAndTalk(_Interrogator,_Criminal1,"",0,"GEB_InterrogationMove",1,6.0);
		
		IF
		CharacterMoveToAndTalkRequestDialog(_Arrester,(CHARACTERGUID)_Criminal,_,_,"GEB_InterrogationMove")
		AND
		DB_InterrogationRequested(_RegionID,_ID,_Arrester,_Criminal,_Criminal2,_Criminal3,_Criminal4,_Dialog)
		THEN
		ProcCrimeCheckInterrogationDialog(_RegionID,_ID,_Arrester,_Criminal,_Criminal2,_Criminal3,_Criminal4,_Dialog);
		
		IF
		CharacterMoveToAndTalkFailed(_Arrester,_,"GEB_InterrogationMove")
		AND
		DB_InterrogationRequested(_RegionID,_ID,_Arrester,_Criminal,_Criminal2,_Criminal3,_Criminal4,_Dialog)
		THEN
		CrimeInterrogationDone(_ID,_Arrester,0,_Criminal,_Criminal2,_Criminal3,_Criminal4);
		ProcCleanUpInterrogation(_Arrester);
		NOT DB_IgnoreInterrogation(_Arrester,NULL_00000000-0000-0000-0000-000000000000);
		ProcObjectTimer(_Arrester,"GEB_RestoreInterrogation",4500);
		CrimeEnableInterrogation(_Arrester,0);
		//allow others to interrogate them
		CrimeResetInterrogationForCriminals(_ID,_Criminal,_Criminal2,_Criminal3,_Criminal4);
		
		PROC
		ProcObjectTimerFinished((CHARACTERGUID)_Arrester,"GEB_RestoreInterrogation")
		AND
		NOT DB_CrimeReaction_DoNotInterrogate(_Arrester)
		THEN
		CrimeEnableInterrogation(_Arrester,1);
		
		PROC
		ProcCleanUpInterrogation((CHARACTERGUID)_Arrester)
		AND
		DB_InterrogationRequested(_RegionID,_ID,_Arrester,_Criminal,_Criminal2,_Criminal3,_Criminal4,_Dialog)
		THEN
		ProcRestoreGenericBehaviour(_Arrester);
		SetHasDialog(_Arrester,1);
		NOT DB_InterrogationRequested(_RegionID,_ID,_Arrester,_Criminal,_Criminal2,_Criminal3,_Criminal4,_Dialog);
		
		IF
		CharacterMoveToAndTalkRequestDialog(_Arrester,(CHARACTERGUID)_Criminal,_,_,"GEB_InterrogationMove")
		AND
		NOT DB_InterrogationRequested(_,_,_Arrester,_Criminal,_,_,_,_)
		THEN
		CharacterMoveToAndTalkRequestDialogFailed(_Arrester,_Criminal,"GEB_InterrogationMove");
		
		IF
		DB_Crime_FailedToInterruptStoryDialogs(_CrimeID,_ArrestDialog,_Arrester,_Criminal,_Criminal2,_Criminal3,_Criminal4)
		AND
		DB_InterrogationRequested(_RegionID,_CrimeID,_Arrester,_Criminal,_Criminal2,_Criminal3,_Criminal4,_ArrestDialog)
		THEN
		CharacterMoveToAndTalkRequestDialogFailed(_Arrester,_Criminal,"GEB_InterrogationMove");
		
		IF
		DB_Crime_InterrogationStarted(_CrimeID,_Arrester)
		AND
		DB_InterrogationRequested(_RegionID,_CrimeID,_Arrester,_Criminal,_Criminal2,_Criminal3,_Criminal4,_ArrestDialog)
		THEN
		ProcCleanUpInterrogation(_Arrester);
		
		IF
		OnCrimeResolved(_CrimeID,_,_,_,_,_)
		AND
		DB_InterrogationRequested(_,_CrimeID,_Arrester,_,_,_,_,_)
		THEN
		ProcCleanUpInterrogation(_Arrester);
		
		//--- Start dialog:
		PROC
		ProcStartInterrogationDialog((INTEGER)_CrimeID,(CHARACTERGUID)_Interrogator,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_Dialog)
		AND
		_Dialog == ""
		THEN
		ProcDoStartInterrogationDialog(_CrimeID,_Interrogator,_Criminal1,_Criminal2,_Criminal3,_Criminal4,"GEB_Interrogation");
		
		PROC
		ProcStartInterrogationDialog((INTEGER)_CrimeID,(CHARACTERGUID)_Interrogator,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_Dialog)
		AND
		_Dialog != ""
		THEN
		ProcDoStartInterrogationDialog(_CrimeID,_Interrogator,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_Dialog);
		
		PROC
		ProcDoStartInterrogationDialog((INTEGER)_,(CHARACTERGUID)_Interrogator,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_Dialog)
		AND
		DB_Interrogation(_Interrogator,_CrimeID)
		THEN
		NOT DB_Interrogation(_Interrogator,_CrimeID); // This Database is set on CRIME_Allow_Search
		
		PROC
		ProcDoStartInterrogationDialog((INTEGER)_CrimeID,(CHARACTERGUID)_Interrogator,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_Dialog)
		THEN
		ProcCrimeInterruptStoryDialogs(_CrimeID,_Dialog,1,_Interrogator,_Criminal1,_Criminal2,_Criminal3,_Criminal4);
		ProcCrimeCheckInterrogationDialogSucceeded(_CrimeID,_Interrogator,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_Dialog);
		
		PROC
		ProcCrimeCheckInterrogationDialogSucceeded((INTEGER)_CrimeID,(CHARACTERGUID)_Interrogator,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_Dialog)
		AND
		NOT DB_Crime_FailedToInterruptStoryDialogs(_CrimeID,_Dialog,_Interrogator,_Criminal1,_Criminal2,_Criminal3,_Criminal4)
		THEN
		DB_Crime_Interrogation(_CrimeID,_Interrogator,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_Dialog);
		DB_Interrogation(_Interrogator,_CrimeID);
		
		PROC
		ProcCrimeCheckInterrogationDialogSucceeded((INTEGER)_CrimeID,(CHARACTERGUID)_Interrogator,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_Dialog)
		AND
		DB_Crime_FailedToInterruptStoryDialogs(_CrimeID,_Dialog,_Interrogator,_Criminal1,_Criminal2,_Criminal3,_Criminal4)
		THEN
		CrimeInterrogationDone(_CrimeID,_Interrogator,1,_Criminal1,_Criminal2,_Criminal3,_Criminal4);
		
		IF
		ObjectFlagSet("CRIME_Allow_Search",(CHARACTERGUID)_Interrogator,_ID)
		THEN
		ObjectClearFlag(_Interrogator,"CRIME_Allow_Search",_ID);
		ObjectClearFlag(_Interrogator,"CRIME_EvidenceFound",_ID);
		ObjectClearFlag(_Interrogator,"CRIME_GuiltFound",_ID);
		ObjectClearFlag(_Interrogator,"CRIME_FoundEvidenceCurrentCrime",_ID);
		ObjectClearFlag(_Interrogator,"CRIME_FoundGuiltyPlayer",_ID);
		
		IF
		ObjectFlagSet("CRIME_Allow_Search",(CHARACTERGUID)_Interrogator,_ID)
		AND
		DB_Crime_Interrogation(_CrimeID,_Interrogator,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_)
		AND
		CrimeFindEvidence(_CrimeID,_Interrogator,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_FoundEvidenceCurrentCrime,_FoundEvidence,_FoundGuilty)
		AND
		QRY_GetCriminalGuilty(_CrimeID,_Interrogator,_FoundEvidenceCurrentCrime,_FoundEvidence,_FoundGuilty)
		THEN
		DB_Interrogation(_Interrogator,_CrimeID);
		
		IF
		ObjectFlagSet("CRIME_Resist_Search",(CHARACTERGUID)_Character,_ID)
		THEN
		ObjectClearFlag(_Character,"CRIME_Resist_Search",_ID);
		DB_Crime_CombatAfterDialog(_ID);
		
		QRY
		QRY_GetCriminalGuilty((INTEGER)_CrimeID,(CHARACTERGUID)_Interrogator,(INTEGER)_FoundEvidenceCurrentCrime,(INTEGER)_FoundEvidence,(INTEGER)_FoundGuilty)
		AND
		_FoundEvidence == 1
		THEN
		ObjectSetFlag(_Interrogator,"CRIME_EvidenceFound",0);
		
		QRY
		QRY_GetCriminalGuilty((INTEGER)_CrimeID,(CHARACTERGUID)_Interrogator,(INTEGER)_FoundEvidenceCurrentCrime,(INTEGER)_FoundEvidence,(INTEGER)_FoundGuilty)
		AND
		_FoundGuilty == 1
		THEN
		ObjectSetFlag(_Interrogator,"CRIME_GuiltFound",0);
		
		QRY
		QRY_GetCriminalGuilty((INTEGER)_CrimeID,(CHARACTERGUID)_Interrogator,(INTEGER)_FoundEvidenceCurrentCrime,(INTEGER)_FoundEvidence,(INTEGER)_FoundGuilty)
		AND
		_FoundEvidenceCurrentCrime == 1
		THEN
		ObjectSetFlag(_Interrogator,"CRIME_FoundEvidenceCurrentCrime",0);
		
		//Resolve Crime
		IF
		ObjectFlagSet("CRIME_FoundGuiltyPlayer",(CHARACTERGUID)_Interrogator,_ID)
		AND
		DB_Interrogation(_Interrogator,_CrimeID)
		THEN
		DB_EvidenceFound(_CrimeID,_Interrogator);
		//DebugText(_Interrogator,"Evidence Found");
		
		//Give Evidance Back to investigator
		IF
		ObjectFlagSet("CRIME_ReturnGoodsToOnwer",(CHARACTERGUID)_Interrogator,_ID)
		AND
		DB_Interrogation(_Interrogator,_CrimeID)
		THEN
		ObjectClearFlag(_Interrogator,"CRIME_ReturnGoodsToOnwer",_ID);
		CrimeTransferEvidenceTo(_CrimeID,_Interrogator);
		
		IF
		ObjectFlagSet("CRIME_CallGuardsFromDialog",(CHARACTERGUID)_Interrogator,_ID) // When A Civilian finds a Thief in Interrogation
		AND
		DB_DialogPlayers(_ID,_Criminal,1)
		THEN
		ObjectClearFlag(_Interrogator,"CRIME_CallGuardsFromDialog");
		DB_Crime_CallingGuards(_Interrogator,_Criminal,_ID);
		
		IF
		DialogEnded(_Dialog,_ID)
		AND
		DB_DialogNPCs(_ID,_Interrogator,1)
		AND
		DB_Crime_Interrogation(_CrimeID,(CHARACTERGUID)_Interrogator,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_Dialog)
		AND
		NOT DB_Crime_CallingGuards(_Interrogator,_,_ID)
		THEN
		ProcCheckInterrogationDone(_Interrogator,_Dialog);
		
		PROC
		ProcCheckInterrogationDone((CHARACTERGUID)_Interrogator,(STRING)_Dialog)
		AND
		NOT DB_EvidenceCheckInWarning(_Dialog)
		AND
		DB_Crime_Interrogation(_CrimeID,_Interrogator,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_Dialog)
		THEN
		NOT DB_Crime_Interrogation(_CrimeID,_Interrogator,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_Dialog);
		ProcStopInterrogation(_CrimeID,_Interrogator,_Criminal1,_Criminal2,_Criminal3,_Criminal4);
		
		
		IF
		DialogEnded(_Dialog,_ID)
		AND
		DB_Crime_CallingGuards(_Interrogator,_Criminal,_ID)
		AND
		DB_Interrogation(_Interrogator,_CrimeID)
		THEN
		SetVarObject(_Interrogator,"Criminal1",(CHARACTERGUID)_Criminal); // TODO REMOVE THIS HACK!
		SetVarString(_Interrogator,"ArrestDialog","GEB_Arrest");
		SetVarInteger(_Interrogator,"CrimeID",_CrimeID);
		SetStoryEvent(_Interrogator,"CRIME_CallGuardsFromDialog");
		NOT DB_Crime_CallingGuards(_Interrogator,_Criminal,_ID);
		
		IF
		ObjectFlagSet("CRIME_FleeHelpFromDialog",(CHARACTERGUID)_Interrogator,_ID) // When A Kid finds a Criminal in Interrogation
		AND
		DB_DialogPlayers(_ID,_Criminal,1)
		THEN
		DB_Crime_FleeCallforHelp(_Interrogator,_Criminal,_ID);
		
		IF
		DialogEnded(_Dialog,_ID)
		AND
		DB_Crime_FleeCallforHelp(_Interrogator,_Criminal,_ID)
		AND
		DB_Interrogation(_Interrogator,_CrimeID)
		THEN
		SetVarObject(_Interrogator,"Criminal1",(CHARACTERGUID)_Criminal); // TODO REMOVE THIS HACK!
		SetVarString(_Interrogator,"ArrestDialog","GEB_Arrest");
		SetVarInteger(_Interrogator,"CrimeID",_CrimeID);
		SetStoryEvent(_Interrogator,"CRIME_FleeHelpFromDialog");
		//CrimeInterrogationDone(_CrimeID,_Interrogator,1);
		NOT DB_Crime_FleeCallforHelp(_Interrogator,_Criminal,_ID);
		
		IF
		DialogEnded(_Dialog,_ID)
		AND
		DB_DialogPlayers(_ID,_Player,1)
		AND
		ObjectGetFlag(_Player,"CRIME_PersuasionFailed",1)
		THEN
		ObjectClearFlag(_Player,"CRIME_PersuasionFailed",0);
		
		// Stop Investigation when join combat
		
		
		//REGION Dialog Ended
		IF
		DialogEnded(_Dialog,_ID)
		AND
		DB_Crime_CombatAfterDialog(_ID)
		AND
		DB_DialogNPCs(_ID,_Interrogator,1)
		AND
		DB_DialogPlayers(_ID,_Player,_)
		THEN
		ProcMakeNPCHostile((CHARACTERGUID)_Player,(CHARACTERGUID)_Interrogator);
		NOT DB_Crime_CombatAfterDialog(_ID);
		
		IF
		DialogEnded(_Dialog,_ID)
		AND
		DB_DialogNPCs(_ID,_Interrogator,1)
		AND
		DB_Crime_Interrogation(_CrimeID,(CHARACTERGUID)_Interrogator,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_Dialog)
		THEN
		NOT DB_Crime_Interrogation(_CrimeID,(CHARACTERGUID)_Interrogator,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_Dialog);
		
		PROC
		ProcStopInterrogation((INTEGER)_CrimeID,(CHARACTERGUID)_Interrogator,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		DB_EvidenceFound(_CrimeID,_Interrogator)
		THEN
		CrimeInterrogationDone(_CrimeID,_Interrogator,1,_Criminal1,_Criminal2,_Criminal3,_Criminal4);
		
		PROC
		ProcStopInterrogation((INTEGER)_CrimeID,(CHARACTERGUID)_Interrogator,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		NOT DB_EvidenceFound(_CrimeID,_Interrogator)
		THEN
		CrimeInterrogationDone(_CrimeID,_Interrogator,0,_Criminal1,_Criminal2,_Criminal3,_Criminal4);
		
		PROC
		ProcStopInterrogation((INTEGER)_CrimeID,(CHARACTERGUID)_Interrogator,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		THEN
		NOT DB_EvidenceFound(_CrimeID,_Interrogator);
		//END_REGION
		
		//REGION Saw Criminal In Combat While Invesigating
		IF
		OnCrimeSawCriminalInCombat(_CrimeID,_Witness,_Criminal)
		AND
		IsTagged(_Witness,"CIVILIAN",0)
		AND
		IsTagged(_Witness,"ANIMAL",0) //Animals should not investigate should be disabled in excel
		THEN
		ProcMakeNPCHostile(_Witness,_Criminal);
		//END_REGION
		//END_REGION
		
		//REGION Trespassing
		
		//--- Registering DB
		IF
		DB_TrespassTrigger((TRIGGERGUID)_Trigger,(TRIGGERGUID)_OutTrigger)
		THEN
		DB_TrespassTrigger((TRIGGERGUID)_Trigger,(TRIGGERGUID)_OutTrigger,"Trespassing",(CHARACTERGUID)NULL_00000000-0000-0000-0000-000000000000);
		
		IF
		DB_TrespassTrigger((TRIGGERGUID)_Trigger,(TRIGGERGUID)_OutTrigger,(STRING)_CrimeName)
		THEN
		DB_TrespassingCrimes((STRING)_CrimeName);
		DB_TrespassTrigger((TRIGGERGUID)_Trigger,(TRIGGERGUID)_OutTrigger,(STRING)_CrimeName,(CHARACTERGUID)NULL_00000000-0000-0000-0000-000000000000);
		
		IF
		DB_TrespassTrigger((TRIGGERGUID)_Trigger,(TRIGGERGUID)_OutTrigger,(STRING)_CrimeName,(CHARACTERGUID)_Victim)
		THEN
		DB_TrespassingCrimes((STRING)_CrimeName);
		DB_TrespassTrigger((TRIGGERGUID)_Trigger,(TRIGGERGUID)_OutTrigger,(STRING)_CrimeName,(CHARACTERGUID)_Victim);
		
		IF
		DB_TrespassTrigger((TRIGGERGUID)_Trigger,(TRIGGERGUID)_,_,_)
		THEN
		ProcTriggerRegisterForPlayers(_Trigger);
		
		
		//--- Removing:
		PROC
		ProcRemoveDBTrespassTrigger((TRIGGERGUID)_Trigger,(TRIGGERGUID)_OutTrigger)
		THEN
		ProcRemoveDBTrespassTrigger((TRIGGERGUID)_Trigger,(TRIGGERGUID)_OutTrigger,(CHARACTERGUID)NULL_00000000-0000-0000-0000-000000000000);
		
		PROC
		ProcRemoveDBTrespassTrigger((TRIGGERGUID)_Trigger,(TRIGGERGUID)_OutTrigger,(CHARACTERGUID)_Victim)
		AND
		DB_TrespassTrigger(_Trigger,_OutTrigger,_CrimeName,_Victim)
		AND
		DB_IsPlayer(_Player)
		THEN
		CharacterStopCrime(_Player, _CrimeName, _Trigger);
		
		PROC
		ProcRemoveDBTrespassTrigger((TRIGGERGUID)_Trigger,(TRIGGERGUID)_OutTrigger,(CHARACTERGUID)_Victim)
		AND
		DB_TrespassTrigger(_Trigger,_OutTrigger,_CrimeName)
		AND
		DB_IsPlayer(_Player)
		THEN
		CharacterStopCrime(_Player, _CrimeName, _Trigger);
		
		PROC
		ProcRemoveDBTrespassTrigger((TRIGGERGUID)_Trigger,(TRIGGERGUID)_OutTrigger,(CHARACTERGUID)_Victim)
		AND
		DB_TrespassTrigger(_Trigger,_OutTrigger)
		AND
		DB_IsPlayer(_Player)
		THEN
		CharacterStopCrime(_Player, "Trespassing", _Trigger);
		
		PROC
		ProcRemoveDBTrespassTrigger((TRIGGERGUID)_Trigger,(TRIGGERGUID)_OutTrigger,(CHARACTERGUID)_Victim)
		AND
		DB_TrespassTrigger(_Trigger,_OutTrigger,_CrimeName,_Victim)
		THEN
		NOT DB_TrespassTrigger(_Trigger,_OutTrigger,_CrimeName,_Victim);
		
		PROC
		ProcRemoveDBTrespassTrigger((TRIGGERGUID)_Trigger,(TRIGGERGUID)_OutTrigger,(CHARACTERGUID)_Victim)
		AND
		DB_TrespassTrigger(_Trigger,_OutTrigger)
		THEN
		NOT DB_TrespassTrigger(_Trigger,_OutTrigger);
		
		PROC
		ProcRemoveDBTrespassTrigger((TRIGGERGUID)_Trigger,(TRIGGERGUID)_OutTrigger,(CHARACTERGUID)_Victim)
		AND
		DB_TrespassTrigger(_Trigger,_OutTrigger,_CrimeName)
		THEN
		NOT DB_TrespassTrigger(_Trigger,_OutTrigger,_CrimeName);
		
		//--- Register/stop crime
		IF
		CharacterEnteredTrigger(_Player,_Trigger)
		AND
		DB_TrespassTrigger(_Trigger,_,_CrimeName,_Victim)
		AND
		DB_IsPlayer(_Player)
		THEN
		DB_PlayerTrespassing(_Player,_Trigger);
		CharacterRegisterCrime(_Player,_CrimeName,_Trigger,_Victim,0);
		
		IF
		CharacterLeftTrigger(_Player,_Trigger)
		AND
		DB_TrespassTrigger(_Trigger,_,_CrimeName,_Victim)
		THEN
		CharacterStopCrime(_Player,_CrimeName,_Trigger);
		NOT DB_PlayerTrespassing(_Player,_Trigger);
		
		IF
		ObjectFlagSet("TeleportOutOfTrespass",_Player,_Inst)
		THEN
		DB_CrimeTeleportOutOfTrespass(_Player,_Inst);
		
		IF
		DialogEnded(_,_ID)
		AND
		DB_DialogPlayers(_ID,_FirstPlayer,1)
		AND
		DB_PlayerTrespassing((CHARACTERGUID)_FirstPlayer,_Trigger)
		AND
		DB_CrimeTeleportOutOfTrespass(_FirstPlayer,_ID)
		AND
		DB_TrespassTrigger(_Trigger,_Outside,_,_)
		AND
		DB_DialogPlayers(_ID,_Player,_)
		THEN
		TeleportTo(_Player,_Outside,"",1);
		NOT DB_PlayerTrespassing(_FirstPlayer,_Trigger);
		NOT DB_CrimeTeleportOutOfTrespass(_Player,_ID);
		ObjectClearFlag(_Player,"TeleportOutOfTrespass",0);
		CharacterFlushQueue((CHARACTERGUID)_Player);
		FireOsirisEvents();
		
		IF
		DialogEnded(_,_ID)
		AND
		DB_CrimeTeleportOutOfTrespass(_Player,_ID)
		THEN
		NOT DB_CrimeTeleportOutOfTrespass(_Player,_ID);
		ObjectClearFlag(_Player,"TeleportOutOfTrespass",0);
		
		//////////////////////////////
		// Unavailable Fallback lead
		IF
		CharacterSelectedAsBestUnavailableFallbackLead(_NPC,_RegionID,_CrimeID,_BusyCrimeID,_Criminal1,_Criminal2,_Criminal3,_Criminal4)
		AND
		NOT QryCrimeOnlyHasSummonCriminal(_Criminal1,_Criminal2,_Criminal3,_Criminal4)
		AND
		CrimeGetType(_CrimeID,_CrimeName)
		AND
		DB_TrespassingCrimes(_CrimeName)
		THEN
		ProcCrimeTrespassingCheckDetection(_CrimeID,_NPC,_Criminal1);
		ProcCrimeTrespassingCheckDetection(_CrimeID,_NPC,_Criminal2);
		ProcCrimeTrespassingCheckDetection(_CrimeID,_NPC,_Criminal3);
		ProcCrimeTrespassingCheckDetection(_CrimeID,_NPC,_Criminal4);
		ProcCrimeTrespassingCheckValidLead(_CrimeID,_NPC);
		ProcCrimeTrespassingStopNPCsDialogAndMakeHostileTo(_CrimeID,_BusyCrimeID,_NPC);
		
		PROC
		ProcCrimeTrespassingCheckDetection((INTEGER)_CrimeID,(CHARACTERGUID)_NPC,(CHARACTERGUID)_Player)
		AND
		_Player != NULL_00000000-0000-0000-0000-000000000000
		AND
		GetDistanceTo(_NPC,_Player,_Dist)
		AND
		CrimeGetDetectionRange(_CrimeID,_Range)
		AND
		_Dist <= _Range
		THEN
		DB_Crime_TrespassUnavailableLeadDetected((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player);
		
		PROC
		ProcCrimeTrespassingCheckValidLead((INTEGER)_CrimeID,(CHARACTERGUID)_NPC)
		AND
		QryCrimeTrespassUnavailableLeadDetected(_NPC)
		THEN
		ProcCrimeTrespassingBlockHostileFallback(_CrimeID,_NPC);
		
		QRY
		QryCrimeTrespassUnavailableLeadDetected((CHARACTERGUID)_NPC)
		AND
		DB_Crime_TrespassUnavailableLeadDetected((CHARACTERGUID)_NPC,_)
		THEN
		DB_NOOP(1);
		
		PROC
		ProcCrimeTrespassingBlockHostileFallback((INTEGER)_CrimeID,(CHARACTERGUID)_NPC)
		THEN
		DB_NOOP(1);
		
		PROC
		ProcCrimeTrespassingStopNPCsDialogAndMakeHostileTo((INTEGER)_CrimeID,(INTEGER)_BusyCrimeID,(CHARACTERGUID)_NPC)
		AND
		DB_Crime_TrespassUnavailableLeadDetected(_NPC,_Player)
		AND
		NOT DB_CrimeTrespassingBlockHostile(_CrimeID,_NPC)
		THEN
		ProcTryMergingCrimes(_CrimeID,_BusyCrimeID,_NPC,_Player);
		
		PROC
		ProcTryMergingCrimes((INTEGER)_NewCrime,(INTEGER)_OldCrime,(CHARACTERGUID)_NPC,(CHARACTERGUID)_Player)
		THEN
		NOT DB_CanMergeCrimes(1);
		
		PROC
		ProcTryMergingCrimes((INTEGER)_NewCrime,(INTEGER)_OldCrime,(CHARACTERGUID)_NPC,(CHARACTERGUID)_Player)
		AND
		QryCanMergeCrimes(_NewCrime,_OldCrime,_Player)
		THEN
		DB_CanMergeCrimes(1);
		
		IF
		OnCriminalMergedWithCrime(_Crime,_Criminal)
		AND
		CrimeGetLeadInvestigator(_Crime,_Lead)
		AND
		CrimeGetType(_Crime,_Type)
		AND
		DB_CrimeAttitudeChange(_Type,_Adjust)
		THEN
		ProcCrimeCheckIfAttitudeCauseCombat(_Lead,_Criminal,_Adjust);
		
		PROC
		ProcTryMergingCrimes((INTEGER)_NewCrime,(INTEGER)_OldCrime,(CHARACTERGUID)_NPC,(CHARACTERGUID)_Player)
		AND
		NOT DB_CanMergeCrimes(1)
		AND
		QueryOnlyOnce("CRIME_Trespassing_NPCForceStopDialog")
		THEN
		ProcForceStopDialog(_NPC);
		
		PROC
		ProcTryMergingCrimes((INTEGER)_NewCrime,(INTEGER)_OldCrime,(CHARACTERGUID)_NPC,(CHARACTERGUID)_Player)
		AND
		NOT DB_CanMergeCrimes(1)
		THEN
		//ignore these 2 crimes, since we're dealing with them in our own way
		CrimeIgnoreCrime(_OldCrime,_NPC);
		CrimeIgnoreCrime(_NewCrime,_NPC);
		DB_CrimeTresPassCombatFallback(_NPC);
		ProcTryStartAttackAD(_NPC);
		CharacterSetTemporaryHostileRelation(_NPC,_Player);
		
		PROC
		ProcTryMergingCrimes((INTEGER)_NewCrime,(INTEGER)_OldCrime,(CHARACTERGUID)_NPC,(CHARACTERGUID)_Player)
		AND
		DB_CanMergeCrimes(1)
		AND
		DB_DialogNPCs(_ID,_NPC,_)
		THEN
		CharacterStopCrimeWithID(_Player,_NewCrime);
		DialogAddCharacter(_ID,_Player);
		
		QRY
		QryCanMergeCrimes((INTEGER)_NewCrime,(INTEGER)_OldCrime,(CHARACTERGUID)_Player)
		AND
		CrimeGetType(_NewCrime,_Type)
		AND
		CrimeGetType(_OldCrime,_Type)
		AND
		CrimeAddCriminal(_OldCrime,_Player,1)
		THEN
		DB_Noop(1);
		
		PROC
		ProcTryStartAttackAD((CHARACTERGUID)_NPC)
		AND
		IsTagged(_NPC,"ANIMAL",0)
		THEN
		Proc_StartDialog(1,"GEB_AD_AttackHelp",_NPC);
		
		//Clearing
		PROC
		ProcCrimeTrespassingStopNPCsDialogAndMakeHostileTo((INTEGER)_CrimeID,(INTEGER)_BusyCrimeID,(CHARACTERGUID)_NPC)
		AND
		DB_Crime_TrespassUnavailableLeadDetected(_NPC,_Player)
		THEN
		NOT DB_OnlyOnce("CRIME_Trespassing_NPCForceStopDialog");
		NOT DB_Crime_TrespassUnavailableLeadDetected(_NPC,_Player);
		
		PROC
		ProcCrimeTrespassingStopNPCsDialogAndMakeHostileTo((INTEGER)_CrimeID,(INTEGER)_BusyCrimeID,(CHARACTERGUID)_NPC)
		THEN
		DB_CrimeTrespassingBlockHostile(_CrimeID,_NPC);
		
		IF
		ObjectEnteredCombat((CHARACTERGUID)_NPC,_)
		AND
		DB_CrimeTresPassCombatFallback(_NPC)
		AND
		DB_CrimeTrespassingBlockHostile(_CrimeID,_NPC)
		THEN
		NOT DB_CrimeTrespassingBlockHostile(_CrimeID,_NPC);
		
		IF
		OnCrimeResolved(_CrimeID,_,_,_,_,_)
		AND
		DB_CrimeTrespassingBlockHostile(_CrimeID,_NPC)
		THEN
		NOT DB_CrimeTrespassingBlockHostile(_CrimeID,_NPC);
		
		//END_REGION
		
		//----------------------------------- ASSAULT -----------------------------------
		//REGION Chicken touch
		
		IF
		CharacterStatusAttempt((CHARACTERGUID)_NPC,"CHICKEN",(CHARACTERGUID)_Player)
		AND
		DB_IsPlayer(_Player)
		AND
		NOT DB_IsPlayer(_NPC)
		AND
		NOT DB_IgnoreAssault(_NPC)
		AND
		NOT DB_CombatCharacters(_NPC,_)
		AND
		NOT DB_IgnoreAssaultFor(_Player,_NPC)
		AND
		ObjectIsCharacter(_NPC,1)
		AND
		IsTagged(_NPC,"GHOST",0)
		AND
		IsTagged(_NPC,"SUMMON",0)
		AND
		HasAppliedStatus(_NPC,"CHICKEN",1)
		AND
		CharacterIsEnemy(_NPC,_Player,0)
		THEN
		DB_Crime_PolymorphedIgnoreAssault(_NPC,_Player);	//keep this first, the register forces a flush!
		
		//END_REGION
		
		//REGION Assault
		
		QRY
		QryHasNeutralBlockTag((CHARACTERGUID)_NPC)
		AND
		DB_NeutralTagIgnore((STRING)_Tag)
		AND
		IsTagged(_NPC,_Tag,1)
		THEN
		DB_NOOP(1);
		
		//--- Checks if the NPC and/or the player/summon are in combat while being neutral to each other, then makes them hostile
		IF
		AttackedByObject((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player,(CHARACTERGUID)_Summon,_,_DamageSource)
		AND
		NOT DB_Crime_Assault(_,_,_NPC)
		AND
		NOT DB_Crime_Assault(_,_Player,_)
		AND
		NOT DB_Crime_PolymorphedIgnoreAssault(_NPC,_Player)
		AND
		NOT QryIgnoreDamageSource(_DamageSource)
		AND
		ObjectIsCharacter(_NPC,1)
		AND
		CharacterIsPlayer(_Player,1)
		AND
		CharacterIsDeadOrFeign(_Player,0)
		AND
		CharacterIsPlayer(_NPC,0)
		AND
		Qry_AreInCombat(_Player,_NPC)
		AND
		CharacterCanFight(_NPC,1)
		AND
		CharacterIsDead(_NPC,0)
		AND
		CharacterIsNeutral(_NPC,_Player,1)
		AND
		NOT QryHasNeutralBlockTag(_NPC)
		AND
		IsTagged(_NPC,"ANIMAL",0)
		AND
		DB_CombatCharacters(_NPC,_ID)
		THEN
		ProcWarnPlayerOfAttack(_NPC,_Player,_ID);
		
		//REGION Combat warnings
		IF
		ObjectLeftCombat((CHARACTERGUID)_NPC,_)
		AND
		DB_CombatWarnings(_NPC,_Cnt)
		THEN
		NOT DB_CombatWarnings(_NPC,_Cnt);
		
		PROC
		ProcWarnPlayerOfAttack((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player,(INTEGER)_ID)
		AND
		NOT DB_CombatWarnings(_NPC,_)
		THEN
		DB_CombatWarnings(_NPC,0);
		
		PROC
		ProcWarnPlayerOfAttack((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player,(INTEGER)_ID)
		AND
		NOT DB_CombatCharacters(_Player,_)
		AND
		DB_CombatWarnings(_NPC,_Count)
		THEN
		NOT DB_CombatWarnings(_NPC,_Count);
		DB_CombatWarnings(_NPC,3);
		
		PROC
		ProcWarnPlayerOfAttack((CHARACTERGUID)_NPC,_,_)
		THEN
		ObjectClearFlag(_NPC,"GEB_Crime_LastNeutralWarning");
		ObjectClearFlag(_NPC,"GEB_Crime_AttackNeutralWarning");
		
		PROC
		ProcWarnPlayerOfAttack((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player,(INTEGER)_ID)
		AND
		DB_CombatWarnings(_NPC,_Old)
		AND
		IntegerSum(_Old,1,_Count)
		THEN
		NOT DB_CombatWarnings(_NPC,_Old);
		DB_CombatWarnings(_NPC,_Count);
		
		PROC
		ProcWarnPlayerOfAttack((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player,(INTEGER)_ID)
		AND
		DB_CombatWarnings(_NPC,_Count)
		AND
		_Count > 3
		THEN
		ObjectSetFlag(_NPC,"GEB_Crime_AttackNeutralWarning");
		ProcMakeNPCHostile(_NPC,_Player);
		
		PROC
		ProcWarnPlayerOfAttack((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player,(INTEGER)_ID)
		AND
		DB_CombatWarnings(_NPC,3)
		THEN
		ObjectSetFlag(_NPC,"GEB_Crime_LastNeutralWarning");
		
		PROC
		ProcWarnPlayerOfAttack((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player,(INTEGER)_ID)
		AND
		DB_CombatWarnings(_NPC,_Count)
		AND
		QryDoNeutralAttackWarning(_Count)
		THEN
		Proc_StartDialog(1,"GEB_AD_WarnFriendlyFire",_NPC);
		
		QRY
		QryDoNeutralAttackWarning((INTEGER)_Count)
		AND
		_Count < 3
		AND
		Random(100,_Rnd)
		AND
		_Rnd <= 40
		THEN
		DB_Noop(1);
		
		QRY
		QryDoNeutralAttackWarning(3)
		THEN
		DB_Noop(1);
		
		//END_REGION
		QRY
		Qry_AreInCombat((CHARACTERGUID)_Player,(CHARACTERGUID)_NPC)
		AND
		DB_CombatCharacters(_NPC,_)
		THEN
		DB_NOOP(1);
		
		QRY
		Qry_AreInCombat((CHARACTERGUID)_Player,(CHARACTERGUID)_NPC)
		AND
		DB_CombatCharacters(_Player,_)
		THEN
		DB_NOOP(1);
		
		PROC
		ProcClearAssaultDBForCrime((INTEGER)_CrimeID)
		AND
		DB_Crime_Assault(_CrimeID,_Criminal,_Victim)
		THEN
		NOT DB_Crime_Assault(_CrimeID,_Criminal,_Victim);
		
		IF
		OnCrimeRemoved(_CrimeID,_Victim,_Criminal1,_Criminal2,_Criminal3,_Criminal4)
		THEN
		ProcClearAssaultDBForCrime(_CrimeID);
		
		IF
		OnCrimeResolved(_CrimeID,_Victim,_Criminal1,_Criminal2,_Criminal3,_Criminal4)
		AND
		_Victim != NULL_00000000-0000-0000-0000-000000000000
		AND
		DB_Crime_Assault(_CrimeID,_,_)
		AND
		IntegertoString(_CrimeID,_CrimeSuffix)
		AND
		StringConcatenate("Timer_ClearAttackDB",_CrimeSuffix,_TimerName)
		THEN
		DB_Crime_PlayerAttacked(_CrimeID,_Criminal1,_Victim); // This is For Murder crime
		DB_Crime_PlayerAttacked(_CrimeID,_Criminal2,_Victim);
		DB_Crime_PlayerAttacked(_CrimeID,_Criminal3,_Victim);
		DB_Crime_PlayerAttacked(_CrimeID,_Criminal4,_Victim);
		DB_AttackTimer(_CrimeID,_TimerName);
		ProcObjectTimer(_Victim,_TimerName,1500);
		NOT DB_Crime_PlayerAttacked(_CrimeID,NULL_00000000-0000-0000-0000-000000000000,_Victim); //Future Feature if needed Generate Murder for every on in combat with the OG DB_Crime_PlayerAttacked _Victim
		
		IF
		OnCrimeResolved(_CrimeID,_Victim,_Criminal1,_Criminal2,_Criminal3,_Criminal4)
		THEN
		ProcClearAssaultDBForCrime(_CrimeID);
		
		PROC
		ProcObjectTimerFinished((CHARACTERGUID)_Victim,_TimerName)
		AND
		DB_AttackTimer(_CrimeID,_TimerName)
		AND
		DB_Crime_PlayerAttacked(_CrimeID,_Player,_Victim)
		AND
		NOT DB_CombatCharacters(_Victim, _)
		THEN
		NOT DB_Crime_PlayerAttacked(_CrimeID,_Player,_Victim);
		
		PROC
		ProcObjectTimerFinished(_Victim,_TimerName)
		AND
		DB_AttackTimer(_CrimeID,_TimerName)
		THEN
		NOT DB_AttackTimer(_CrimeID,_TimerName);
		
		IF
		CrimeInterrogationRequest(_RegionID,_CrimeID,_Interrogator,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_Dialog)
		THEN
		ProcClearAssaultDBForCrime(_CrimeID);
		
		IF
		OnCrimeMergedWith(_Old,_New)
		AND
		DB_Crime_Assault(_Old,_Criminal1,_Victim)
		THEN
		NOT DB_Crime_Assault(_Old,_Criminal1,_Victim);
		DB_Crime_Assault(_New,_Criminal1,_Victim);
		
		//if our vicitim is not selected as lead (incapacitated), don't track this DB because that will mean he won't be able to react anymore
		//update it with the new lead
		IF
		CharacterOnCrimeSensibleActionNotification(_NPC,_,_CrimeID,_,_,_Criminal1,_,_,_,1)
		AND
		DB_Crime_Assault(_CrimeID,_Criminal1,_Victim)
		THEN
		NOT DB_Crime_Assault(_CrimeID,_Criminal1,_Victim);
		DB_Crime_Assault(_CrimeID,_Criminal1,_NPC);
		
		//END_REGION
		
		//REGION General Assault crime -- verifies if the assailant is a summon or not and registers the Assault or AttackAnimal crime
		
		QRY
		QryIgnoreDamageSource((STRING)_Dmg)
		AND
		DB_IgnoreDamageSources(_Dmg)
		THEN
		DB_NOOP(1);
		
		IF
		AttackedByObject((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player,(CHARACTERGUID)_Summon,_,_DamageSource)
		AND
		NOT DB_IgnoreAssault(_NPC)
		AND
		NOT DB_Crime_PolymorphedIgnoreAssault(_NPC,_Player)
		AND
		NOT DB_CombatCharacters(_NPC,_)
		AND
		NOT DB_Crime_Assault(_,_,_NPC)
		AND
		CharacterIsPlayer(_Player,1)
		AND
		NOT QryIgnoreDamageSource(_DamageSource)
		AND
		CharacterIsDeadOrFeign(_Player,0)
		AND
		ObjectIsCharacter(_NPC,1)
		AND
		CharacterIsPlayer(_NPC,0)
		AND
		CharacterIsDead(_NPC,0)
		AND
		IsTagged(_NPC,"GHOST",0)
		AND
		IsTagged(_NPC,"SUMMON",0)
		THEN
		ProcCrimeCheckAssailant(_NPC,_Player,_Summon);
		
		
		//--- Assailant is not a summon
		PROC
		ProcCrimeCheckAssailant((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player,(CHARACTERGUID)_Summon)
		AND
		NOT QRY_CharacterIsNull(_Summon)
		AND
		IsTagged(_Summon,"SUMMON",1)
		AND
		NOT DB_IgnoreAssaultFor(_Summon,_NPC)
		AND
		NOT DB_Crime_Assault(_,_Summon,_)
		AND
		CharacterIsEnemy(_NPC,_Summon,0)
		THEN
		ProcCrimeRegisterAssault(_Summon,_NPC,1);
		
		//--- Assailant is a summon
		PROC
		ProcCrimeCheckAssailant((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player,(CHARACTERGUID)_Summon)
		AND
		QryCrimeAssailantIsNotSummon(_Player,_Summon)
		AND
		NOT DB_IgnoreAssaultFor(_Player,_NPC)
		AND
		NOT DB_Crime_Assault(_,_Player,_)
		AND
		CharacterIsEnemy(_NPC,_Player,0)
		THEN
		ProcCrimeRegisterAssault(_Player,_NPC,0);
		
		//--- Split the type of assault
		// Normal
		PROC
		ProcCrimeRegisterAssault((CHARACTERGUID)_Assailant,(CHARACTERGUID)_NPC,0) //_AssailantIsSummon
		AND
		IsTagged(_NPC,"ANIMAL",0)
		THEN
		ProcCrimeRegisterAssaultType(_Assailant,_NPC,"Assault");
		
		PROC
		ProcCrimeRegisterAssault((CHARACTERGUID)_Assailant,(CHARACTERGUID)_NPC,0)
		AND
		IsTagged(_NPC,"ANIMAL",1)
		THEN
		ProcCrimeRegisterAssaultType(_Assailant,_NPC,"AttackAnimal");
		
		// Summon
		PROC
		ProcCrimeRegisterAssault((CHARACTERGUID)_Assailant,(CHARACTERGUID)_NPC,1)
		AND
		IsTagged(_NPC,"ANIMAL",0)
		THEN
		ProcCrimeRegisterAssaultType(_Assailant,_NPC,"SummonAssault");
		
		PROC
		ProcCrimeRegisterAssault((CHARACTERGUID)_Assailant,(CHARACTERGUID)_NPC,1)
		AND
		IsTagged(_NPC,"ANIMAL",1)
		THEN
		ProcCrimeRegisterAssaultType(_Assailant,_NPC,"SummonAttackAnimal");
		
		//REGION Assault investigation location determination
		// Default: victim location
		// Problem: if attacked from out of sight range, they won't be able to find the attacker
		// Solution: after a while, report the assailant's rather than the victim's location as investigation location
		// If assaulted even more: force combat
		//
		// Reasoning: the more an NPC has been attacked, the more they'll pay attention
		//   regarding where the attack came from. Factors influencing them homing in on
		//   the source: sneaking, invisibility, wits difference between victim and assailant
		
		QRY
		QRY_CRIMES_AssaultCrimeGetCrimeLocationScoreIncrease((CHARACTERGUID)_Assailant,(CHARACTERGUID)_Victim)
		AND
		DB_CRIME_AssaultCrimeGetCrimeLocationScoreIncrease(_Total)
		THEN
		NOT DB_CRIME_AssaultCrimeGetCrimeLocationScoreIncrease(_Total);
		
		QRY
		QRY_CRIMES_AssaultCrimeGetCrimeLocationScoreIncrease((CHARACTERGUID)_Assailant,(CHARACTERGUID)_Victim)
		AND
		HasActiveStatus(_Assailant,"SNEAKING",_IsSneaking)
		AND
		HasActiveStatus(_Assailant,"INVISIBLE",_IsInvisible)
		AND
		CharacterGetAttribute(_Assailant,"WITS",_AssailantWits)
		AND
		CharacterGetAttribute(_Assailant,"WITS",_VictimWits)
		AND
		IntegerSubtract(_VictimWits,_AssailantWits,_WitsRes)
		AND
		QRY_IntegerSign(_WitsRes)
		AND
		DB_IntegerSign(_WitsBonus)
		AND
		DB_CRIME_CrimeLocationScoreIncrease(_IsSneaking,_IsInvisible,_Base,_Rand)
		AND
		Random(_Rand,_Extra)
		AND
		IntegerSum(_Base,_Extra,_BaseTotal)
		AND
		IntegerSum(_BaseTotal,_WitsBonus,_Total)
		THEN
		DB_CRIME_AssaultCrimeGetCrimeLocationScoreIncrease(_Total);
		
		QRY
		QRY_CRIME_AssaultCrimeGetInvestigationPos((CHARACTERGUID)_Assailant,(CHARACTERGUID)_Victim)
		AND
		DB_CRIME_AssaultCrimeInvestigationPos(_x,_yUp,_z)
		THEN
		NOT DB_CRIME_AssaultCrimeInvestigationPos(_x,_yUp,_z);
		
		QRY
		QRY_CRIME_AssaultCrimeGetInvestigationPos((CHARACTERGUID)_Assailant,(CHARACTERGUID)_Victim)
		THEN
		Proc_CharCountHelper(_Victim,"CRIME_CrimeTriggers_AssaultCrimeLocation");
		
		// Update assault score
		QRY
		QRY_CRIME_AssaultCrimeGetInvestigationPos((CHARACTERGUID)_Assailant,(CHARACTERGUID)_Victim)
		AND
		QRY_CRIMES_AssaultCrimeGetCrimeLocationScoreIncrease(_Assailant,_Victim)
		AND
		DB_CRIME_AssaultCrimeGetCrimeLocationScoreIncrease(_Increase)
		THEN
		Proc_CharCountHelper(_Victim,"CRIME_CrimeTriggers_AssaultCrimeLocation",_Increase);
		
		// Assaulted many times -> investigate location of assailant
		QRY
		QRY_CRIME_AssaultCrimeGetInvestigationPos((CHARACTERGUID)_Assailant,(CHARACTERGUID)_Victim)
		AND
		DB_CharCountHelper(_Victim,"CRIME_CrimeTriggers_AssaultCrimeLocation",_Count)
		AND
		DB_CRIME_CrimeLocationScore_GoToAttackerThreshold(_Threshold)
		AND
		_Count >= _Threshold
		AND
		GetPosition(_Assailant,_x,_y,_z)
		AND
		RealSum(_y,1.0,_yUp)
		THEN
		DB_CRIME_AssaultCrimeInvestigationPos(_x,_yUp,_z);
		
		// Fallback if not yet assaulted many times
		QRY
		QRY_CRIME_AssaultCrimeGetInvestigationPos((CHARACTERGUID)_Assailant,(CHARACTERGUID)_Victim)
		AND
		NOT DB_CRIME_AssaultCrimeInvestigationPos(_,_,_)
		AND
		GetPosition(_Victim,_x,_y,_z)
		AND
		RealSum(_y,1.0,_yUp)
		THEN
		DB_CRIME_AssaultCrimeInvestigationPos(_x,_yUp,_z);
		
		// Clean up when dying
		IF
		CharacterDied(_Victim)
		AND
		DB_CharCountHelper(_Victim,"CRIME_CrimeTriggers_AssaultCrimeLocation",_Count)
		THEN
		NOT DB_CharCountHelper(_Victim,"CRIME_CrimeTriggers_AssaultCrimeLocation",_Count);
		
		//END_REGION
		
		//REGION Assaulted really a lot or down on health -> start combat
		// Allows for at least three assaults -> don't cut off warning system
		PROC
		ProcCrimeRegisterAssaultType((CHARACTERGUID)_Assailant,(CHARACTERGUID)_Victim,(STRING)_AssaultType)
		AND
		QRY_CRIME_AssaultCrimeGetInvestigationPos(_Assailant,_Victim)
		AND
		DB_CharCountHelper(_Victim,"CRIME_CrimeTriggers_AssaultCrimeLocation",_Count)
		AND
		DB_CRIME_CrimeLocationScore_StartAttackingThreshold(_Threshold)
		AND
		_Count >= _Threshold
		AND
		CharacterCanFight(_Victim,1)
		THEN
		DB_CrimeRegisterAssaultType_Handled(1);
		Proc_StartDialog(1,"GEB_AD_AttackHelp",_Victim);
		Proc_CharacterSetTemporaryHostileRelation(_Victim,_Assailant);
		EnterCombat(_Victim,_Assailant);
		
		PROC
		ProcCrimeRegisterAssaultType((CHARACTERGUID)_Assailant,(CHARACTERGUID)_Victim,(STRING)_AssaultType)
		AND
		CharacterGetHitpointsPercentage(_Victim,_Percentage)
		AND
		DB_CRIME_Assault_HealthStartAttackingThreshold(_Threshold)
		AND
		_Percentage < _Threshold
		AND
		CharacterCanFight(_Victim,1)
		AND
		CharacterIsDead(_Victim,0)
		THEN
		DB_CrimeRegisterAssaultType_Handled(1);
		Proc_StartDialog(1,"GEB_AD_AttackHelp",_Victim);
		Proc_CharacterSetTemporaryHostileRelation(_Victim,_Assailant);
		EnterCombat(_Victim,_Assailant);
		//END_REGION
		
		PROC
		ProcCrimeRegisterAssaultType((CHARACTERGUID)_Assailant,(CHARACTERGUID)_Victim,(STRING)_AssaultType)
		AND
		NOT DB_CrimeRegisterAssaultType_Handled(1)
		AND
		GetPosition(_Victim,_x,_y,_z)
		AND
		RealSum(_y,1.0,_yUp)
		AND
		CrimeIsAnyNPCGoingToReact(_Assailant,_AssaultType,_x,_yUp,_z,_WillReact)
		AND
		CrimeGetNewID(_CrimeID)
		AND
		DB_CRIME_AssaultCrimeInvestigationPos(_XInv,_YInv,_ZInv)
		THEN
		NOT DB_CRIME_AssaultCrimeInvestigationPos(_XInv,_YInv,_ZInv);
		DB_CRIME_CrimeInvestigationPos(_CrimeID,_XInv,_YInv,_ZInv);
		DB_Crime_Assault(_CrimeID,_Assailant,_Victim);
		ProcCheckRegisterAssault(_Assailant,_Victim,_AssaultType,_x,_yUp,_z,_CrimeID,_WillReact);
		
		PROC
		ProcCrimeRegisterAssaultType((CHARACTERGUID)_Assailant,(CHARACTERGUID)_Victim,(STRING)_AssaultType)
		AND
		DB_CrimeRegisterAssaultType_Handled(1)
		THEN
		NOT DB_CrimeRegisterAssaultType_Handled(1);
		
		PROC
		ProcClearAssaultDBForCrime((INTEGER)_CrimeID)
		AND
		DB_CRIME_CrimeInvestigationPos(_CrimeID,_XInv,_YInv,_ZInv)
		THEN
		NOT DB_CRIME_CrimeInvestigationPos(_CrimeID,_XInv,_YInv,_ZInv);
		
		PROC
		ProcCheckRegisterAssault((CHARACTERGUID)_Assailant,(CHARACTERGUID)_Victim,(STRING)_AssaultType,(REAL)_X,(REAL)_Y,(REAL)_Z,(INTEGER)_CrimeID,1)
		THEN
		ProcCharacterRegisterCrimeWithPosition(_Assailant,_AssaultType,NULL_00000000-0000-0000-0000-000000000000,_Victim,_X,_Y,_Z,_CrimeID,_Victim);
		
		//noone reacted to this one, so assume the victim was incapacitated
		PROC
		ProcCheckRegisterAssault((CHARACTERGUID)_Assailant,(CHARACTERGUID)_Victim,(STRING)_AssaultType,(REAL)_X,(REAL)_Y,(REAL)_Z,(INTEGER)_CrimeID,0)
		THEN
		ProcCharacterRegisterCrimeWithPosition(_Assailant,"IncapacitatedAssault",NULL_00000000-0000-0000-0000-000000000000,_Victim,_X,_Y,_Z,_CrimeID,_Victim);
		
		//END_REGION
		
		//REGION Clear PolymorphedIgnoreAssault fact
		
		IF
		AttackedByObject((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player,(CHARACTERGUID)_Summon,_,_)
		AND
		DB_Crime_PolymorphedIgnoreAssault(_NPC,_Player)
		AND
		GetPosition(_NPC,_x,_y,_z)
		AND
		RealSum(_y,1.0,_yUp)
		AND
		CrimeGetNewID(_CrimeID)
		THEN
		NOT DB_Crime_PolymorphedIgnoreAssault(_NPC,_Player);
		CharacterRegisterCrimeWithPosition(_Player,"Polymorphed",NULL_00000000-0000-0000-0000-000000000000,_NPC,_x,_yUp,_z,_CrimeID);
		
		//END_REGION
		
		//REGION Teleportation Netherswap
		IF
		CharacterUsedSkillOnTarget(_Player,(CHARACTERGUID)_Npc,"Teleportation_Netherswap",_)
		AND
		NOT Qry_AreInCombat(_Player,_NPC)
		AND
		CharacterIsPlayer(_Player,1)
		AND
		ObjectIsCharacter(_Npc,1)
		AND
		CharacterIsDeadOrFeign(_Player,0)
		AND
		CharacterIsPlayer(_NPC,0)
		AND
		CharacterIsDead(_NPC,0)
		THEN
		ProcDoCrimeCheckAssailant(_Player,_NPC);
		
		PROC
		ProcDoCrimeCheckAssailant((CHARACTERGUID)_Summon,(CHARACTERGUID)_NPC)
		AND
		CharacterIsSummon(_Summon,1)
		AND
		CharacterGetOwner(_Summon,_Player)
		THEN
		ProcCrimeCheckAssailant(_NPC,_Player,_Summon);
		
		PROC
		ProcDoCrimeCheckAssailant((CHARACTERGUID)_Player,(CHARACTERGUID)_NPC)
		AND
		CharacterIsSummon(_Player,0)
		THEN
		ProcCrimeCheckAssailant(_NPC,_Player,_Player);
		
		//END_REGION
		
		//----------------------------------- /ASSAULT -----------------------------------
		
		//REGION GEB_FleeOutOfSight
		IF
		AutomatedDialogEnded("GEB_AD_CallForHelp",_ID) // For kids looking for help
		AND
		DB_DialogNPCs(_ID,_NPC,1)
		AND
		IsTagged(_NPC,"KID",1)
		AND
		ObjectGetFlag(_NPC,"GEB_FleeOutOfSight",0)
		THEN
		ObjectSetFlag(_NPC,"GEB_FleeOutOfSight");
		
		IF
		ObjectFlagSet("GEB_FleeOutOfSight",(CHARACTERGUID)_NPC,_)
		THEN
		SetHasDialog(_NPC,0);
		ProcCharacterDisappearOutOfSight((CHARACTERGUID)_NPC,0,1,"GEB_NPCFledOutOfSight",1);
		Proc_StartDialog(1,"GEB_AD_CallForHelp",_NPC);
		ProcForceStopDialog(_NPC);
		
		IF
		ObjectFlagSet("GEB_FleeOutOfSight",_NPC,_)
		AND
		NOT DB_GEB_FledOutOfSight(_NPC,_,_,_)
		AND
		GetPosition(_NPC,_X,_Y,_Z)
		THEN
		DB_GEB_FledOutOfSight(_NPC,_X,_Y,_Z);
		
		IF
		ObjectFlagSet("GEB_FleeOutOfSight",(CHARACTERGUID)_NPC,_)
		AND
		DB_Crime_Assault(_CrimeID,_Player,_NPC)
		THEN
		NOT DB_Crime_Assault(_CrimeID,_Player,_NPC);
		
		IF
		StoryEvent(_NPC,"GEB_NPCFledOutOfSight")
		AND
		ObjectGetFlag(_NPC,"GEB_DontAppearAfter",0)
		THEN
		ProcObjectTimer(_NPC,"GEB_AppearNPCOutOfSight",15000);
		
		IF
		ObjectFlagSet("GEB_DontAppearAfter",_Char,_)
		THEN
		ProcObjectTimerCancel(_Char,"GEB_AppearNPCOutOfSight");
		
		IF
		ObjectFlagSet("GEB_DontAppearAfter",(CHARACTERGUID)_Char,_)
		AND
		DB_GEB_NPCAppearAfterCombat(_Char,_CombatID)
		THEN
		NOT DB_GEB_NPCAppearAfterCombat(_Char,_CombatID);
		
		//--- Start trying to reappear
		PROC
		ProcObjectTimerCancel((CHARACTERGUID)_NPC,"GEB_AppearNPCOutOfSight")
		AND
		DB_GEB_FledOutOfSight(_NPC,_X,_Y,_Z)
		THEN
		NOT DB_GEB_FledOutOfSight(_NPC,_X,_Y,_Z);
		
		PROC
		ProcObjectTimerFinished((CHARACTERGUID)_NPC,"GEB_AppearNPCOutOfSight")
		AND
		DB_GEB_FledOutOfSight(_NPC,_X,_Y,_Z)
		AND
		GetClosestPlayerToPosition(_X,_Y,_Z,_Player,_Dist)
		THEN
		ProcCrimeAppearOutOfSightChecks(_NPC,_Player,_Dist);
		
		//--- Check the distance and if the player is dead, in dialog or in combat
		PROC
		ProcCrimeAppearOutOfSightChecks((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player,(REAL)_Dist)
		AND
		_Dist > 20.0
		THEN
		ProcAppearOutOfSightAfterFleeing(_NPC);
		
		PROC
		ProcCrimeAppearOutOfSightChecks((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player,(REAL)_Dist)
		AND
		_Dist <= 20.0
		AND
		Query_CharacterIsAliveAndNotInCombat(_Player)
		AND
		IsSpeakerReserved(_Player,0)
		THEN
		ProcAppearOutOfSightAfterFleeing(_NPC);
		
		PROC
		ProcCrimeAppearOutOfSightChecks((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player,(REAL)_Dist)
		AND
		_Dist <= 20.0
		AND
		DB_CombatCharacters(_Player,_CombatID)
		THEN
		DB_GEB_NPCAppearAfterCombat(_NPC,_CombatID);
		
		PROC
		ProcCrimeAppearOutOfSightChecks((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player,(REAL)_Dist)
		AND
		_Dist <= 20.0
		AND
		CharacterIsDeadOrFeign(_Player,1)
		THEN
		ProcAppearOutOfSight_DeadClosestPlayer(_NPC,_Player);
		
		PROC
		ProcCrimeAppearOutOfSightChecks((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player,(REAL)_Dist)
		AND
		NOT DB_GEB_NPCAppearAfterCombat(_NPC,_)
		AND
		_Dist <= 20.0
		AND
		IsSpeakerReserved(_Player,1)
		AND
		DB_DialogPlayers(_Inst,_Player,1)
		THEN
		DB_GEB_NPCAppearAfterDialog(_NPC,_Inst);
		
		// Try to find a live player
		PROC
		ProcAppearOutOfSight_DeadClosestPlayer((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player)
		AND
		GetClosestAlivePlayer(_Player,_AlivePlayer,_)
		THEN
		DB_GEB_AppearOutOfSight_AlivePlayerFound(_NPC,_AlivePlayer);
		
		PROC
		ProcAppearOutOfSight_DeadClosestPlayer((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player)
		AND
		NOT DB_GEB_AppearOutOfSight_AlivePlayerFound(_NPC,_)
		THEN
		ProcAppearOutOfSightAfterFleeing(_NPC);
		
		PROC
		ProcAppearOutOfSight_DeadClosestPlayer((CHARACTERGUID)_NPC,(CHARACTERGUID)_)
		AND
		DB_GEB_AppearOutOfSight_AlivePlayerFound(_NPC,_AlivePlayer)
		AND
		DB_GEB_FledOutOfSight(_NPC,_X,_Y,_Z)
		AND
		GetDistanceToPosition(_AlivePlayer,_X,_Y,_Z,_Dist)
		THEN
		NOT DB_GEB_AppearOutOfSight_AlivePlayerFound(_NPC,_AlivePlayer);
		ProcCrimeAppearOutOfSightChecks(_NPC,(CHARACTERGUID)_AlivePlayer,_Dist);
		
		//--- Recheck after dialog & combat
		IF
		DialogEnded(_,_Inst)
		AND
		DB_GEB_NPCAppearAfterDialog(_NPC,_Inst)
		THEN
		NOT DB_GEB_NPCAppearAfterDialog(_NPC,_Inst);
		ProcObjectTimer(_NPC,"GEB_AppearNPCOutOfSight",3000); // restart from the beginning (delay in case combat starts after the dialog)
		
		IF
		CombatEnded(_CombatID)
		AND
		DB_GEB_NPCAppearAfterCombat(_NPC,_CombatID)
		THEN
		NOT DB_GEB_NPCAppearAfterCombat(_NPC,_CombatID);
		ProcObjectTimer(_NPC,"GEB_AppearNPCOutOfSight",3000); // restart the checks from the beginning
		
		//--- Appear
		PROC
		ProcAppearOutOfSightAfterFleeing((CHARACTERGUID)_NPC)
		AND
		DB_GEB_FledOutOfSight(_NPC,_X,_Y,_Z)
		THEN
		NOT DB_GEB_FledOutOfSight(_NPC,_X,_Y,_Z);
		SetHasDialog(_NPC,1);
		CharacterAppearAtPositionOutOfSightTo((CHARACTERGUID)_NPC,_X,_Y,_Z,0,0,"GEB_NPCAppeared");
		ObjectClearFlag(_NPC,"GEB_FleeOutOfSight",0);
		CharacterSetHitpointsPercentage(_NPC,100);
		
		//END_REGION
		
		//REGION Source Magic
		
		IF
		CharacterUsedSkill(_Character,_Skill,_)
		AND
		DB_IsPlayer(_Character)
		AND
		IsSourceSkill(_Skill,1)
		THEN
		CharacterRegisterCrime(_Character,"SourceMagic",NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,0);
		
		//END_REGION
		
		//REGION Stealing
		IF
		CharacterStoleItem(_Character,_Item,_X,_Y,_Z,_Victim,_SrcContainer,_)
		AND
		CharacterIsPlayer(_Character,1)
		AND
		_SrcContainer==NULL_00000000-0000-0000-0000-000000000000
		THEN
		//TODO: do not register Steal for stelaing from a container? IE: the problem with doing this is, that NPCs will detect missign items from a barrel without looking into it
		CharacterRegisterCrimeWithPosition(_Character,"Steal",_Item,_Victim,_X,_Y,_Z,0);
		
		//END_REGION
		
		//REGION Murder (animals and non-animals)
		
		//REGION Helpers
		// A killed character may get removed from a combat before the CharacterKilledByCharacter event gets triggered
		// -> also check DB_WasInCombat for the _Victim
		QRY
		QryCrimeKillerVictimWereInSameCombat((CHARACTERGUID)_Killer,(CHARACTERGUID)_Victim)
		AND
		DB_CombatCharacters(_Killer,_ID)
		AND
		DB_WasInCombat(_Victim,_ID)
		THEN
		DB_NOOP(1);
		
		QRY
		QryCrimeKillerVictimWereInSameCombat((CHARACTERGUID)_Killer,(CHARACTERGUID)_Victim)
		AND
		DB_CombatCharacters(_Killer,_ID)
		AND
		DB_CombatCharacters(_Victim,_ID)
		THEN
		DB_NOOP(1);
		
		// Killing a totem or a summon is not murder
		QRY
		QryCrimeCharacterCanCreateMurder((CHARACTERGUID)_Char)
		AND
		IsTagged(_Char,"SUMMON",0)
		AND
		IsTagged(_Char,"TOTEM",0)
		THEN
		DB_NOOP(1);
		//END_REGION
		
		//REGION Determine crime type
		// By default, murdering an animal results in "KilledAnimal" and murdering anyone
		// else in "Murder". Can override QryCrimeMurderGetCrimeTypeCustom() to return custom results.
		//
		// Note: QryCrimeMurderGetCrimeTypeCustom() can be called multiple times for the same murder
		//   (-> should not keep state, e.g. don't assume second call is for second murder)
		
		// Define signature for custom query
		QRY
		QryCrimeMurderGetCrimeTypeCustom((CHARACTERGUID)_Killer,(CHARACTERGUID)_Victim)
		AND
		DB_CrimeNeverEverSet__INVALID(1)
		THEN
		DB_NOOP(1);
		
		// Reset previous result, if any
		QRY
		QryCrimeMurderGetCrimeType((CHARACTERGUID)_Killer,(CHARACTERGUID)_Victim)
		AND
		DB_CrimeMurderCrimeType(_Type)
		THEN
		NOT DB_CrimeMurderCrimeType(_Type);
		
		// Query custom overrides
		QRY
		QryCrimeMurderGetCrimeType((CHARACTERGUID)_Killer,(CHARACTERGUID)_Victim)
		AND
		QryCrimeMurderGetCrimeTypeCustom(_Killer,_Victim)
		THEN
		DB_NOOP(1);
		
		// Default fallbacks
		QRY
		QryCrimeMurderGetCrimeType((CHARACTERGUID)_Killer,(CHARACTERGUID)_Victim)
		AND
		NOT DB_CrimeMurderCrimeType(_)
		AND
		IsTagged(_Victim,"ANIMAL",_Animal)
		AND
		HasActiveStatus(_Killer,"SNEAKING",_Sneaking)
		AND
		CharacterIsSummon(_Killer,_Summon)
		AND
		DB_CRIME_MurderType(_Sneaking,_Animal,_Summon,_MurderType)
		THEN
		DB_CrimeMurderCrimeType(_MurderType);
		//END_REGION
		
		//REGION Witnesses that should ignore this murder crime
		// Only have to do something before registering the crime if
		// the witness does not ignore crimes like this in general
		PROC
		ProcCrimeMurderDefineSilentWitness((INTEGER)_CrimeID,(CHARACTERGUID)_Witness,(CHARACTERGUID)_Killer,(CHARACTERGUID)_Victim)
		AND
		QryCrimeMurderGetCrimeType(_Killer,_Victim)
		AND
		DB_CrimeMurderCrimeType(_CrimeType)
		AND
		NOT DB_CharacterCrimeDisabled(_Witness,_CrimeType)
		THEN
		DB_CrimeSilentWitness(_CrimeID,_CrimeType,_Witness);
		// Don't set it to ignore this crime yet, as another crime (murder)
		// could occur between now and when this murder is registered due to
		// the use of an iterator) -- that will be done by ProcCrimeCreateMurder)
		
		// Convert DB_CrimeSilentWitness() to DB_CRIME_CrimeTriggers_SilentWitnessesForCrime(), as used by ProcCharacterRegisterCrimeWithPosition()
		PROC
		PROC_CRIME_CrimeTriggers_GetSilentWitnessesForCrime((INTEGER)_CrimeID,(CHARACTERGUID)_Perpetrator,(STRING)_CrimeType,(GUIDSTRING)_Evidence,(CHARACTERGUID)_Victim)
		AND
		DB_CrimeSilentWitness(_CrimeID,_CrimeType,_Witness)
		THEN
		NOT DB_CrimeSilentWitness(_CrimeID,_CrimeType,_Witness);
		DB_CRIME_CrimeTriggers_SilentWitnessesForCrime(_Witness);
		
		// NPCs that should ignore the murder of this victim should be treated as silent witnesses
		PROC
		PROC_CRIME_CrimeTriggers_GetSilentWitnessesForCrime((INTEGER)_CrimeID,(CHARACTERGUID)_Perpetrator,(STRING)_CrimeType,(GUIDSTRING)_Evidence,(CHARACTERGUID)_Victim)
		AND
		DB_MurderIgnoreFor((CHARACTERGUID)_Witness,(CHARACTERGUID)_Victim)
		THEN
		DB_CRIME_CrimeTriggers_SilentWitnessesForCrime(_Witness);
		//END_REGION
		
		//REGION Register the murder crime
		PROC
		ProcCrimeCreateMurder((CHARACTERGUID)_Killer,(CHARACTERGUID)_Victim,(INTEGER)_CrimeID)
		AND
		QryCrimeMurderGetCrimeType(_Killer,_Victim)
		AND
		DB_CrimeMurderCrimeType(_CrimeType)
		AND
		GetPosition(_Victim,_x,_y,_z)
		AND
		RealSum(_y,1.0,_yUp)
		THEN
		ProcCharacterRegisterCrimeWithPosition(_Killer,_CrimeType,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,_x,_yUp,_z,_CrimeID,_Victim);
		//END_REGION
		
		//REGION 1) Killed a non-enemy NPC outside of combat (one-shot, so combat did not have a chance to start)
		IF
		CharacterKilledBy(_Defender,_Attacker,_AttackerOwner)
		AND
		NOT DB_IsPlayer(_Defender)
		AND
		CharacterIsPlayer(_Attacker,1)
		AND
		CharacterIsPartyFollower(_Attacker,0)
		AND
		CharacterIsEnemy(_Defender,_Attacker,0)
		AND
		NOT DB_DontCreateMurder(_Defender)
		AND
		NOT QryCrimeKillerVictimWereInSameCombat(_Attacker,_Defender)
		AND
		QryCrimeCharacterCanCreateMurder(_Defender)
		AND
		CrimeGetNewID(_CrimeID)
		THEN
		DebugText(_Defender,"OneShot Murder Crime Scene");
		DB_CrimeMurderCreated(_Defender,_Attacker);
		ProcCrimeCreateMurder(_Attacker,_Defender,_CrimeID);
		//END_REGION
		
		//REGION 2) Killed an NPC while it was investigating
		IF
		CharacterKilledBy(_Defender,_Attacker,_AttackerOwner)
		AND
		NOT DB_CrimeMurderCreated(_Defender,_Attacker)
		AND
		NOT DB_IsPlayer(_Defender)
		AND
		NOT DB_DontCreateMurder(_Defender)
		AND
		DB_Crime_Assault(_,_,_Defender) // This DB Will be filled in if the character is still investigating
		AND
		QryCrimeCharacterCanCreateMurder(_Defender)
		AND
		CharacterIsPlayer(_Attacker,1)
		AND
		CharacterIsPartyFollower(_Attacker,0)
		AND
		CrimeGetNewID(_CrimeID)
		THEN
		DebugText(_Defender,"Mid Investigate Murder Crime Scene");
		ProcCrimeCreateMurder(_Attacker,_Defender,_CrimeID);
		//END_REGION
		
		//REGION 3) Killed an NPC in a combat following an assault crime
		// Current logic:
		//  - Create a murder for any NPC that you kill in this combat
		//  - This murder is, however, ignored by anyone within a 25 metre range that was not in combat
		// Reasoning: the characters that joined in the combat due to the assault, presumably would
		// have done the same for murder. The ones that did not, might not join for murder either. They also
		// might, but we don't have a good way to determine this. Creating a murder in this case can easily
		// lead to an avalache where a whole city starts fighting a player, which is not good -> be very
		// restrictive about who will care about such a murder
		//
		// Don't check for CharacterIsEnemy(_NPC,0), because when someone attacks you after you assaulted them,
		// they will obviously be an enemty to you.
		IF
		CharacterKilledBy(_Defender,_Attacker,_AttackerOwner)
		AND
		NOT DB_CrimeMurderCreated(_Defender,_Attacker)
		AND
		// This DB is set after an assault crime, and also for other
		// characters that join a combat in which an assault victim is involved
		DB_Crime_PlayerAttacked(_,_,_Defender)
		AND
		DB_CombatCharacters(_Defender,_ID)
		AND
		NOT DB_IsPlayer(_Defender)
		AND
		NOT DB_DontCreateMurder(_Defender)
		AND
		CharacterIsPlayer(_Attacker,1)
		AND
		CharacterIsPartyFollower(_Attacker,0)
		AND
		QryCrimeCharacterCanCreateMurder(_Defender)
		AND
		CrimeGetNewID(_CrimeID)
		AND
		IntegertoString(_CrimeID,_Iterator)
		AND
		StringConcatenate(_Iterator,"GEB_IgnoreCrime",_IteratorID)
		THEN
		DebugText(_Defender,"Assault murder scene");
		DB_CrimeMurderSilentWitnessCollectionContext(_CrimeID,_Defender,_IteratorID,_Attacker);
		CharacterLaunchIteratorAroundCharacter(_Defender,25.0,_IteratorID);
		
		PROC
		ProcCrimeMurderMaybeMakeSilentWitness((INTEGER)_CrimeID,(CHARACTERGUID)_Witness,(CHARACTERGUID)_Killer,(CHARACTERGUID)_Victim)
		AND
		NOT DB_CombatCharacters(_Witness,_)
		THEN
		ProcCrimeMurderDefineSilentWitness(_CrimeID,_Witness,_Killer,_Victim);
		
		// Allies let allies commit murders! That's what real friendship is all about.
		PROC
		ProcCrimeMurderMaybeMakeSilentWitness((INTEGER)_CrimeID,(CHARACTERGUID)_Witness,(CHARACTERGUID)_Killer,(CHARACTERGUID)_Victim)
		AND
		DB_CombatCharacters(_Witness,_)
		AND
		CharacterIsAlly(_Witness,_Killer,1)
		THEN
		ProcCrimeMurderDefineSilentWitness(_CrimeID,_Witness,_Killer,_Victim);
		
		// An ally of my ally is my friend (e.g. Butter in Fort Joy is only allied to the player that charmed her).
		PROC
		ProcCrimeMurderMaybeMakeSilentWitness((INTEGER)_CrimeID,(CHARACTERGUID)_Witness,(CHARACTERGUID)_Killer,(CHARACTERGUID)_Victim)
		AND
		DB_CombatCharacters(_Witness,_)
		AND
		DB_IsPlayer(_Player)
		AND
		CharacterIsAlly(_Witness,_Player,1)
		AND
		CharacterIsAlly(_Player,_Killer,1)
		THEN
		ProcCrimeMurderDefineSilentWitness(_CrimeID,_Witness,_Killer,_Victim);
		
		// Ignore murder seen in combat
		IF
		StoryEvent((CHARACTERGUID)_NPC,_IteratorID)
		AND
		DB_CrimeMurderSilentWitnessCollectionContext(_CrimeID,_DeadMan,_IteratorID,_Killer)
		AND
		_NPC != NULL_00000000-0000-0000-0000-000000000000
		AND
		NOT DB_dead((CHARACTERGUID)_NPC)
		THEN
		ProcCrimeMurderMaybeMakeSilentWitness(_CrimeID,_NPC,_Killer,_DeadMan);
		ProcCrimeMurderMaybeMakeSilentWitness(_CrimeID,_NPC,_Killer,_DeadMan);
		
		// Create Murder (Last NPC in the Iterator is NULL_00000000-0000-0000-0000-000000000000)
		IF
		StoryEvent(_NPC,_IteratorID)
		AND
		DB_CrimeMurderSilentWitnessCollectionContext(_CrimeID,_DeadMan,_IteratorID,_Killer)
		AND
		_NPC == NULL_00000000-0000-0000-0000-000000000000
		THEN
		NOT DB_CrimeMurderSilentWitnessCollectionContext(_CrimeID,_DeadMan,_IteratorID,_Killer);
		DebugText(_DeadMan,"Normal Murder Crime Scene");
		ProcCrimeCreateMurder(_Killer,_DeadMan,_CrimeID);
		
		QRY
		Qry_HasDontCreateMurderInCombat((INTEGER)_ID)
		AND
		DB_CombatCharacters(_NPCS,_ID)
		AND
		DB_DontCreateMurder((CHARACTERGUID)_NPCS)
		THEN
		DB_NOOP(1);
		
		// One DB_DontCreateMurder() NPC in a combat -> killing others that join the combat should not create murders either
		// (TODO: check that they're allies of one of the DB_DontCreateMurder() NPCs -- especially now that neutrals don't
		//  join random combats anymore)
		IF
		ObjectEnteredCombat(_Obj,_ID)
		AND
		ObjectIsCharacter(_Obj,1)
		AND
		Qry_HasDontCreateMurderInCombat(_ID)
		AND
		DB_CombatCharacters(_NPC,_ID)
		AND
		NOT DB_IsPlayer(_NPC)
		AND
		NOT DB_DontCreateMurder(_NPC)
		THEN
		DB_DontCreateMurder(_NPC);
		DB_CrimeCreateMurderAfterCombat(_NPC,_ID);
		DebugText(_NPC," Killing me won't create a murder in this combat, because I joined a combat with others whose murder gets ignored");
		
		IF
		ObjectSwitchedCombat((CHARACTERGUID)_NPC,_OldCombatID,_NewCombatID)
		AND
		DB_CrimeCreateMurderAfterCombat(_NPC,_OldCombatID)
		THEN
		NOT DB_CrimeCreateMurderAfterCombat(_NPC,_OldCombatID);
		DB_CrimeCreateMurderAfterCombat(_NPC,_NewCombatID);
		
		IF
		CombatEnded(_CombatID)
		AND
		DB_CrimeCreateMurderAfterCombat(_NPC,_CombatID)
		THEN
		NOT DB_CrimeCreateMurderAfterCombat(_NPC,_CombatID);
		NOT DB_DontCreateMurder(_NPC);
		
		IF
		ObjectEnteredCombat(_NPC,_)
		AND
		ObjectIsCharacter(_NPC,1)
		THEN
		ProcCrimeAddToAttackedDBIfAssaultCombat((CHARACTERGUID)_NPC);
		
		IF
		ObjectSwitchedCombat(_NPC,_,_)
		AND
		ObjectIsCharacter(_NPC,1)
		THEN
		ProcCrimeAddToAttackedDBIfAssaultCombat((CHARACTERGUID)_NPC);
		
		IF
		DB_Crime_PlayerAttacked(_CrimeID,_Player,_NPC)
		THEN
		ProcCrimeAddToAttackedDBIfAssaultCombat((CHARACTERGUID)_NPC);
		
		PROC
		ProcCrimeAddToAttackedDBIfAssaultCombat((CHARACTERGUID)_NPC)
		AND
		DB_CombatCharacters(_NPC,_ID)
		AND
		DB_Crime_PlayerAttacked(_CrimeID,_Player,_OrigVic)
		AND
		DB_CombatCharacters(_Player,_ID)
		AND
		DB_CombatCharacters(_NPC2,_ID)
		AND
		NOT DB_Crime_PlayerAttacked(_CrimeID,_Player,_NPC2)
		AND
		CharacterIsPlayer(_NPC2,0)
		AND
		CharacterIsAlly(_OrigVic,_NPC2,1)
		THEN
		DB_Crime_PlayerAttacked(_CrimeID,_Player,_NPC2);
		DebugText(_NPC2," Killing me will create a murder scene (probably joined combat to help assaulted NPC), although it will be ignored by anyone within a 25m radius of this combat");
		
		IF
		ObjectLeftCombat((CHARACTERGUID)_NPC,_)
		AND
		DB_Crime_PlayerAttacked(_CrimeID,_Player,_NPC)
		THEN
		NOT DB_Crime_PlayerAttacked(_CrimeID,_Player,_NPC);
		
		IF
		OnCrimeMergedWith(_Old,_New)
		AND
		DB_CrimeMurderSilentWitnessCollectionContext(_Old,_DeadMan,_IteratorID,_Killer)
		THEN
		NOT DB_CrimeMurderSilentWitnessCollectionContext(_Old,_DeadMan,_IteratorID,_Killer);
		DB_CrimeMurderSilentWitnessCollectionContext(_New,_DeadMan,_IteratorID,_Killer);
		
		IF
		OnCrimeMergedWith(_Old,_New)
		AND
		DB_CrimeSilentWitness(_Old,_CrimeType,_NPC)
		THEN
		NOT DB_CrimeSilentWitness(_Old,_CrimeType,_NPC);
		DB_CrimeSilentWitness(_New,_CrimeType,_NPC);
		//END_REGION
		
		//REGION Reset DB_CrimeMurderCreated
		IF
		CharacterKilledBy(_Defender,_Attacker,_AttackerOwner)
		AND
		DB_CrimeMurderCreated(_Defender,_Attacker)
		THEN
		NOT DB_CrimeMurderCreated(_Defender,_Attacker);
		//END_REGION
		
		//END_REGION
		
		//REGION Pickpocket
		
		IF
		RequestPickpocket(_Player,_Npc)
		AND
		DB_CannotPickpocketTags(_Tag)
		AND
		IsTagged(_Npc, _Tag, 1)
		AND
		CharacterIsPartyMember(_Npc, 0)
		THEN
		DB_PickpocketingBlocked(1);
		Proc_StartDialog(1,"GEB_AD_CannotPickpocket",_Player);
		
		IF
		RequestPickpocket(_Player,_Npc)
		AND
		NOT DB_PickpocketingBlocked(1)
		THEN
		RemoveStatus(_Player,"INVISIBLE");
		
		IF
		CharacterPickpocketFailed(_Player,_)
		THEN
		RemoveStatus(_Player,"INVISIBLE");
		
		
		IF
		RequestPickpocket(_Player,_Npc)
		AND
		DB_PickpocketingBlocked(1)
		THEN
		StartPickpocket(_Player,_Npc,0);
		
		IF
		RequestPickpocket(_Player,_Npc)
		AND
		NOT DB_PickpocketingBlocked(1)
		AND
		CharacterIsPartyMember(_Npc, 0)
		THEN
		GenTradeItems(_Player,_Npc);
		StartPickpocket(_Player,_Npc,1);
		
		IF
		RequestPickpocket(_Player,_Npc)
		THEN
		NOT DB_PickpocketingBlocked(1);
		
		IF
		RequestPickpocket(_Player,_OtherPlayer)
		AND
		CharacterIsPartyMember(_OtherPlayer, 1)
		THEN
		StartPickpocket(_Player,_OtherPlayer,1);
		
		
		//--- PICKPOCKET SUCCESS
		IF
		CharacterPickpocketSuccess(_Thief,_Victim,_Item,_Amount) //TODO: Only trigger on HighValueItems
		AND
		CharacterIsCrimeEnabled(_Victim,"EmptyPocketNoticed",1)
		AND
		CharacterCanSpotCrimes(_Victim,1)
		AND
		Random(10000,_Rand)
		AND
		IntegerSum(_Rand,5000,_Time)
		THEN
		DB_Pickpocketed(_Thief,_Victim,_Item);
		ProcObjectTimerCancel(_Victim,"CRIME_Pickpocket_CheckPockets");
		ProcObjectTimer(_Victim,"CRIME_Pickpocket_CheckPockets",_Time);
		
		
		PROC
		ProcObjectTimerFinished((CHARACTERGUID)_Victim,"CRIME_Pickpocket_CheckPockets")
		AND
		CharacterIsDead(_Victim,0)
		AND
		IsSpeakerReserved(_Victim,1) // Victim is in dialog, restart timer to delay reaction
		AND
		Random(10000,_Rand)
		AND
		IntegerSum(_Rand,5000,_Time)
		THEN
		ProcObjectTimerCancel(_Victim,"CRIME_Pickpocket_CheckPockets");
		ProcObjectTimer(_Victim,"CRIME_Pickpocket_CheckPockets",_Time);
		
		PROC
		ProcObjectTimerFinished((CHARACTERGUID)_Victim,"CRIME_Pickpocket_CheckPockets")
		AND
		QRY_SpeakerIsAvailable(_Victim)
		AND
		DB_Pickpocketed(_Thief,_Victim,_)
		AND
		QueryOnlyOnce("CRIME_Pickpocket_PlayAnimation")
		THEN
		RemoveStatus(_Victim,"SITTING");
		RemoveStatus(_Victim,"LYING");
		PlayAnimation(_Victim,"PickPocket_01");
		
		PROC
		ProcObjectTimerFinished((CHARACTERGUID)_Victim,"CRIME_Pickpocket_CheckPockets")
		AND
		QRY_SpeakerIsAvailable(_Victim)
		AND
		DB_Pickpocketed(_Thief,_Victim,_Item)
		AND
		GetPosition(_Victim,_x,_y,_z)
		THEN
		NOT DB_OnlyOnce("CRIME_Pickpocket_PlayAnimation");
		NOT DB_Pickpocketed(_Thief,_Victim,_Item);
		CharacterRegisterCrimeWithPosition(_Thief,"EmptyPocketNoticed",_Item,_Victim,_x,_y,_z,0);
		
		
		//--- PICKPOCKET FAIL
		//--- Don't create a crime if it failed because of a tag
		IF
		CharacterPickpocketFailed(_Player,_Npc)
		AND
		CharacterIsPartyMember(_Npc, 0)
		AND
		DB_CannotPickpocketTags(_Tag)
		AND
		IsTagged(_Npc, _Tag, 1)
		THEN
		DB_PickpocketingBlocked(1);
		
		//--- Check if player already stole items on that NPC
		//--- Pass the item as evidence if it's the case.
		IF
		CharacterPickpocketFailed(_Player,_Npc)
		AND
		NOT DB_PickpocketingBlocked(1)
		AND
		CharacterIsPartyMember(_Npc, 0)
		THEN
		ProcCrimePickpocketFailedFlow(_Player,_Npc);
		
		PROC
		ProcCrimePickpocketFailedFlow((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc)
		THEN
		ProcObjectTimerCancel(_Npc,"CRIME_Pickpocket_CheckPockets");
		
		PROC
		ProcCrimePickpocketFailedFlow((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc)
		AND
		CharacterIsCrimeEnabled(_Npc,"PickPocketFailed",1)
		THEN
		RemoveStatus(_Player,"SNEAKING");
		RemoveStatus(_Npc,"SLEEPING");
		RemoveStatus(_Npc,"LYING");
		
		PROC
		ProcCrimePickpocketFailedFlow((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc)
		AND
		NOT DB_Pickpocketed(_Player,_Npc,_)
		THEN
		ProcRegisterPickPocketFailed(_Player,_Npc,NULL_00000000-0000-0000-0000-000000000000);
		
		PROC
		ProcCrimePickpocketFailedFlow((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc)
		AND
		DB_Pickpocketed(_Player,_Npc,_)
		AND
		QryCrimeWarningPickPocketFailed_NpcDoesNOTCheckEvidence(_Npc)
		THEN
		ProcRegisterPickPocketFailed(_Player,_Npc,NULL_00000000-0000-0000-0000-000000000000);
		
		// pass item as evidence if NPC must perform a search
		PROC
		ProcCrimePickpocketFailedFlow((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc)
		AND
		DB_Pickpocketed(_Player,_Npc,_Item)
		AND
		NOT QryCrimeWarningPickPocketFailed_NpcDoesNOTCheckEvidence(_Npc)
		THEN
		ProcRegisterPickPocketFailed(_Player,_Npc,_Item);
		NOT DB_Pickpocketed(_Player,_Npc,_Item);
		
		PROC
		ProcRegisterPickPocketFailed((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc,(GUIDSTRING)_Evidence)
		AND
		GetPosition(_Npc,_X,_Y,_Z)
		AND
		RealSum(_Y,1.0,_YUp)
		THEN
		CharacterRegisterCrimeWithPosition(_Player,"PickPocketFailed",_Evidence,_Npc,_X,_YUp,_Z,0);
		
		QRY
		QryCrimeWarningPickPocketFailed_NpcDoesNOTCheckEvidence((CHARACTERGUID)_Npc)
		AND
		CharacterIsPartyMember(_Npc, 0)
		AND
		NOT QryNPCIsGuard(_Npc)
		THEN
		DB_NOOP(1);
		
		PROC
		ProcCrimePickpocketFailedFlow((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc)
		THEN
		NOT DB_PickpocketingBlocked(1);
		
		
		//END_REGION
		
		//REGION NPC Draw Weapons
		// -------------------------- CRIME_Draw Reaction ----------------------------->
		IF
		CharacterOnCrimeSensibleActionNotification(_NPC,_,_CrimeID,"CRIME_Draw",_,_Criminal,_Criminal2,_Criminal3,_Criminal4,_)
		AND
		NOT DB_CombatCharacters(_Criminal,_)
		AND
		NOT DB_CombatCharacters(_NPC,_)
		AND
		NOT DB_NPCDrawForCrimial(_NPC,_CrimeID,_Criminal)
		AND
		CharacterCanSee(_NPC,_Criminal,_)
		THEN
		DB_NPCDrawForCrimial(_NPC,_CrimeID,_Criminal);
		
		IF
		CharacterLostSightOfCharacter(_NPC,_Criminal)
		AND
		NOT DB_CombatCharacters(_NPC,_)
		AND
		DB_NPCDrawForCrimial(_NPC,_CrimeID,_Criminal)
		THEN
		CharacterSetFightMode(_NPC,0,0);
		NOT DB_NPCDrawForCrimial(_NPC,_CrimeID,_Criminal);
		
		// -------------------------- WeaponsDrawn Crime ----------------------------->
		PROC
		ProcStoreFightMode((CHARACTERGUID)_Npc)
		AND
		NOT DB_FightModeState(_Npc,_)
		AND
		CharacterIsInFightMode(_Npc,_FightMode)
		THEN
		DB_FightModeState(_Npc,_FightMode);
		
		PROC
		ProcRestoreFightMode((CHARACTERGUID)_Npc)
		AND
		DB_FightModeState(_Npc,_State)
		AND
		NOT DB_CombatCharacters(_NPC,_)
		THEN
		CharacterSetFightMode(_Npc,_State,0);
		NOT DB_FightModeState(_Npc,_State);
		
		IF
		StoryEvent(_Npc,"CRIME_RestoreUnsheath")
		AND
		ObjectExists(_Npc,1)
		THEN
		ProcRestoreFightMode((CHARACTERGUID)_Npc);
		
		IF
		CharacterOnCrimeSensibleActionNotification(_NPC,_,_CrimeID,_,_,_Criminal,_Criminal2,_Criminal3,_Criminal4,_)
		AND
		NOT DB_CombatCharacters(_NPC,_)
		AND
		CrimeGetType(_CrimeID,"WeaponsDrawn")
		AND
		NOT DB_NPCSheathWeapon(_NPC,_Criminal)
		THEN
		DB_NPCSheathWeapon(_NPC,_Criminal);
		DB_NPCSheathWeapon(_NPC,_Criminal2);
		DB_NPCSheathWeapon(_NPC,_Criminal3);
		DB_NPCSheathWeapon(_NPC,_Criminal4);
		NOT DB_NPCSheathWeapon(_NPC,NULL_00000000-0000-0000-0000-000000000000);
		ProcStoreFightMode(_Npc);
		CharacterSetFightMode(_NPC,1,0);
		
		IF
		CharacterStatusRemoved(_Player,"UNSHEATHED",_)
		AND
		DB_IsPlayer(_Player)
		AND
		DB_NPCSheathWeapon(_NPC,_Player)
		AND
		NOT DB_CombatCharacters(_NPC,_)
		THEN
		NOT DB_NPCSheathWeapon(_NPC,_Player);
		ProcCrimeCheckIfPlayersWeaponsOut((CHARACTERGUID)_NPC);
		
		PROC
		ProcCrimeCheckIfPlayersWeaponsOut((CHARACTERGUID)_NPC)
		AND
		NOT DB_NPCSheathWeapon(_NPC,_)
		AND
		NOT DB_CombatCharacters(_NPC,_)
		THEN
		ProcRestoreFightMode(_NPC);
		SetStoryEvent(_NPC,"NPCReturnToOrginalPos");
		
		IF
		ObjectLeftCombat((CHARACTERGUID)_NPC,_)
		AND
		DB_NPCSheathWeapon(_NPC,_)
		AND
		ObjectExists(_NPC,1)
		AND
		CharacterIsDead(_NPC,0)
		THEN
		ProcRestoreFightMode(_NPC);
		
		IF
		CharacterLostSightOfCharacter(_NPC,_Player)
		AND
		DB_NPCSheathWeapon(_NPC,_Player)
		THEN
		NOT DB_NPCSheathWeapon(_NPC,_Player);
		ProcCrimeCheckIfPlayersWeaponsOut(_NPC);
		
		IF
		DB_BlockThreatenedDialog((CHARACTERGUID)_Char)
		THEN
		CharacterDisableCrime(_Char,"WeaponsDrawn");
		DB_CheckWeaponsDrawnCrime(_Char);
		
		IF
		DB_CheckWeaponsDrawnCrime((CHARACTERGUID)_Char)
		AND
		NOT DB_BlockThreatenedDialog(_Char)
		AND
		NOT DB_CharacterCrimeDisabled(_Char,"WeaponsDrawn")
		THEN
		CharacterEnableCrime(_Char,"WeaponsDrawn");
		
		//END_REGION
		
		//REGION Sneaking Spotted
		IF
		CharacterSawSneakingCharacter(_NPC,_Player)
		AND
		CharacterIsPlayer(_NPC,0)
		THEN
		CharacterRegisterCrime(_Player,"Sneaking",NULL_00000000-0000-0000-0000-000000000000,_NPC,0);
		//END_REGION
		
		//REGION Vandalise - AttackItem
		
		//--- 1) Item attacked
		IF
		AttackedByObject((ITEMGUID)_Item,(CHARACTERGUID)_Player,(CHARACTERGUID)_Summon,_,_DamageSource)
		AND
		NOT QryIgnoreDamageSource(_DamageSource)
		AND
		ObjectIsItem(_Item,1)
		AND
		CharacterIsPlayer(_Player,1)
		AND
		ItemGetHealthPoints(_Item,_INT)
		AND
		_INT > 0
		THEN
		ProcCrimeVandaliseCheckOwner(_Item,_Player,_Summon);
		
		
		//--- 2) Check if the item has an owner
		PROC
		ProcCrimeVandaliseCheckOwner((ITEMGUID)_Item,(CHARACTERGUID)_Player,(CHARACTERGUID)_Summon)
		AND
		ItemGetOwner(_Item,_Owner)
		AND
		_Owner != NULL_00000000-0000-0000-0000-000000000000
		AND
		CharacterIsPlayer(_Owner,0)
		THEN
		ProcCrimeVandaliseCheckVandal(_Item,_Owner,_Player,_Summon,"");
		
		PROC
		ProcCrimeVandaliseCheckOwner((ITEMGUID)_Item,(CHARACTERGUID)_Player,(CHARACTERGUID)_Summon)
		AND
		ItemGetOwner(_Item,_Owner)
		AND
		_Owner == NULL_00000000-0000-0000-0000-000000000000
		AND
		NOT QryCheckforVandaliseTags(_Item)
		THEN
		ProcCrimeVandaliseCheckVandal(_Item,NULL_00000000-0000-0000-0000-000000000000,_Player,_Summon,"NoOwner");
		
		
		//--- 3) Check if the vandal is a summon
		PROC
		ProcCrimeVandaliseCheckVandal((ITEMGUID)_Item,(CHARACTERGUID)_Owner,(CHARACTERGUID)_Player,(CHARACTERGUID)_Summon,(STRING)_Postfix)
		AND
		NOT QRY_CharacterIsNull(_Summon)
		AND
		CharacterIsSummon(_Summon,1)
		AND
		QryShouldTriggerVandaliseCrime(_Item,_Summon)
		AND
		NOT DB_Crime_Vandalise((CHARACTERGUID)_Summon,(ITEMGUID)_Item,(INTEGER)_)
		THEN
		ProcCrimeRegisterVandalise(_Item,_Owner,_Summon,"Summon",_Postfix);
		
		PROC
		ProcCrimeVandaliseCheckVandal((ITEMGUID)_Item,(CHARACTERGUID)_Owner,(CHARACTERGUID)_Player,(CHARACTERGUID)_Summon,(STRING)_Postfix)
		AND
		_Player == _Summon
		AND
		QryShouldTriggerVandaliseCrime(_Item,_Player)
		AND
		NOT DB_Crime_Vandalise(_Player,_Item,_)
		THEN
		ProcCrimeRegisterVandalise(_Item,_Owner,_Player,"",_Postfix);
		
		
		//--- 4) Concatenate the crime's name & register it
		PROC
		ProcCrimeRegisterVandalise((ITEMGUID)_Item,(CHARACTERGUID)_Owner,(CHARACTERGUID)_Vandal)
		THEN
		ProcCrimeRegisterVandalise(_Item,_Owner,_Vandal,"","");
		
		PROC
		ProcCrimeRegisterVandalise((ITEMGUID)_Item,(CHARACTERGUID)_Owner,(CHARACTERGUID)_Vandal,(STRING)_Prefix,(STRING)_Postfix)
		AND
		StringConcatenate(_Prefix,"Vandalise",_Part1)
		AND
		StringConcatenate(_Part1,_Postfix,_CrimeName)
		AND
		GetPosition(_Item,_x,_y,_z)
		AND
		RealSum(_y,1.0,_yUp)
		AND
		CrimeGetNewID(_CrimeID)
		THEN
		DB_Crime_Vandalise(_Vandal,_Item,_CrimeID);
		CharacterRegisterCrimeWithPosition(_Vandal,_CrimeName,_Item,_Owner,_x,_yUp,_z,_CrimeID);
		
		
		QRY
		QryCheckforVandaliseTags((ITEMGUID)_Item)
		AND
		DB_IgnoreVandaliseTag((STRING)_Tag)
		AND
		IsTagged(_Item,_Tag,1)
		THEN
		DB_NOOP(1);
		
		QRY
		QryShouldTriggerVandaliseCrime((ITEMGUID)_Item,(CHARACTERGUID)_Player)
		AND
		NOT DB_CombatCharacters(_Player,_)
		THEN
		DB_NOOP(1);
		
		QRY
		QryShouldTriggerVandaliseCrime((ITEMGUID)_Item,(CHARACTERGUID)_Player)
		AND
		DB_TriggerVandaliseInCombat(_Item)
		THEN
		DB_NOOP(1);
		
		IF
		OnCrimeMergedWith(_Old,_New)
		AND
		DB_Crime_Vandalise(_Player,_Item,_Old)
		THEN
		NOT DB_Crime_Vandalise(_Player,_Item,_Old);
		DB_Crime_Vandalise(_Player,_Item,_New);
		
		QRY
		QryCheckforVandaliseTags((ITEMGUID)_Item)
		AND
		DB_IgnoreVandaliseTag((STRING)_Tag)
		AND
		IsTagged(_Item,_Tag,1)
		THEN
		DB_NOOP(1);
		
		//REGION Resolve Vandalise
		IF
		OnCrimeRemoved(_CrimeID,_Victim,_Criminal1,_Criminal2,_Criminal3,_Criminal4)
		THEN
		ProcCrimeClearVandaliseDB(_Criminal1,_CrimeID);
		ProcCrimeClearVandaliseDB(_Criminal2,_CrimeID);
		ProcCrimeClearVandaliseDB(_Criminal3,_CrimeID);
		ProcCrimeClearVandaliseDB(_Criminal4,_CrimeID);
		
		IF
		OnCrimeResolved(_CrimeID,_Victim,_Criminal1,_Criminal2,_Criminal3,_Criminal4)
		AND
		CrimeGetType(_CrimeID,"Vandalise")
		THEN
		ProcCrimeClearVandaliseDB(_Criminal1,_CrimeID);
		ProcCrimeClearVandaliseDB(_Criminal2,_CrimeID);
		ProcCrimeClearVandaliseDB(_Criminal3,_CrimeID);
		ProcCrimeClearVandaliseDB(_Criminal4,_CrimeID);
		
		IF
		OnCrimeResolved(_CrimeID,_Victim,_Criminal1,_Criminal2,_Criminal3,_Criminal4)
		AND
		CrimeGetType(_CrimeID,"VandaliseNoOwner")
		THEN
		ProcCrimeClearVandaliseDB(_Criminal1,_CrimeID);
		ProcCrimeClearVandaliseDB(_Criminal2,_CrimeID);
		ProcCrimeClearVandaliseDB(_Criminal3,_CrimeID);
		ProcCrimeClearVandaliseDB(_Criminal4,_CrimeID);
		
		PROC
		ProcCrimeClearVandaliseDB((CHARACTERGUID)_Player,(INTEGER)_CrimeID)
		AND
		DB_Crime_Vandalise(_Player,_Item,_CrimeID)
		THEN
		NOT DB_Crime_Vandalise(_Player,_Item,_CrimeID);
		//END_REGION
		//END_REGION
		
		//REGION Vandalise - Destroy Item
		
		IF
		AttackedByObject((ITEMGUID)_Item,(CHARACTERGUID)_Player,(CHARACTERGUID)_Summon,_,_DamageSource)
		AND
		NOT QryIgnoreDamageSource(_DamageSource)
		AND
		ObjectIsItem(_Item,1)
		AND
		CharacterIsPlayer(_Player,1)
		AND
		NOT DB_CombatCharacters(_Player,_)
		AND
		ItemGetHealthPoints(_Item,_INT)
		AND
		_INT < 1
		AND
		NOT DB_Crime_ItemDestroyed(_Item,_Player)
		AND
		ItemGetOwner(_Item,_Owner)
		AND
		_Owner != NULL_00000000-0000-0000-0000-000000000000
		AND
		CharacterIsPlayer(_Owner,0)
		THEN
		ProcCrimeItemDestroyCheckVandal(_Item,_Owner,_Player,_Summon);
		
		//2. check the criminal
		PROC
		ProcCrimeItemDestroyCheckVandal((ITEMGUID)_Item,(CHARACTERGUID)_Owner,(CHARACTERGUID)_Player,(CHARACTERGUID)_Summon)
		AND
		NOT QRY_CharacterIsNull(_Summon)
		AND
		CharacterIsSummon(_Summon,1)
		AND
		QryShouldTriggerVandaliseCrime(_Item,_Summon)
		AND
		NOT DB_Crime_Vandalise((CHARACTERGUID)_Summon,(ITEMGUID)_Item,(INTEGER)_)
		THEN
		ProcCrimeRegisterItemDestroy(_Item,_Owner,_Summon,"Summon");
		
		PROC
		ProcCrimeItemDestroyCheckVandal((ITEMGUID)_Item,(CHARACTERGUID)_Owner,(CHARACTERGUID)_Player,(CHARACTERGUID)_Summon)
		AND
		_Player == _Summon
		AND
		QryShouldTriggerVandaliseCrime(_Item,_Player)
		AND
		NOT DB_Crime_Vandalise(_Player,_Item,_)
		THEN
		ProcCrimeRegisterItemDestroy(_Item,_Owner,_Player,"");
		
		//3. register the crime
		PROC
		ProcCrimeRegisterItemDestroy((ITEMGUID)_Item,(CHARACTERGUID)_Owner,(CHARACTERGUID)_Vandal,(STRING)_Prefix)
		AND
		StringConcatenate(_Prefix,"ItemDestroy",_CrimeName)
		AND
		GetPosition(_Item,_x,_y,_z)
		AND
		RealSum(_y,1.0,_yUp)
		THEN
		DB_Crime_ItemDestroyed(_Item,_Vandal);
		CharacterRegisterCrimeWithPosition(_Vandal,_CrimeName,_Item,_Owner,_x,_yUp,_z,0);
		
		//END_REGION
		
		//REGION Status Reaction
		IF
		CharacterStatusApplied(_Player,_Status,_)
		AND
		_Status != "UNSHEATHED"
		AND
		DB_IsPlayer(_Player)
		AND
		DB_StatusReaction(_Status,_Crime)
		AND
		HasActiveStatus(_Player,_Status,1)
		THEN
		DB_StatusReactingToPlayer(_Player,_Status);
		CharacterRegisterCrime(_Player,_Crime,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,0);
		
		IF
		CharacterStatusApplied(_Player,_Status,_)
		AND
		_Status == "UNSHEATHED"
		AND
		DB_IsPlayer(_Player)
		AND
		NOT DB_CombatCharacters(_Player,_)
		AND
		DB_StatusReaction(_Status,_Crime)
		AND
		HasActiveStatus(_Player,_Status,1)
		THEN
		DB_StatusReactingToPlayer(_Player,_Status);
		CharacterRegisterCrime(_Player,_Crime,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,0);
		
		
		IF
		CharacterStatusRemoved(_Player, _Status, _)
		AND
		DB_IsPlayer(_Player)
		AND
		DB_StatusReaction(_Status,_Crime)
		THEN
		CharacterStopCrime(_Player,_Crime,NULL_00000000-0000-0000-0000-000000000000);
		NOT DB_StatusReactingToPlayer(_Player,_Status);
		
		//END_REGION
		
		//REGION Is Not Messing Around
		IF
		DB_IsNotMessingAround((CHARACTERGUID)_Char)
		THEN
		DB_AttackOnAssault(_Char);
		SetTag(_Char,"NOT_MESSING_AROUND");
		ProcCharacterEnableCrime(_Char,"Assault");
		
		IF
		DB_RemoveIsNotMessingAround((CHARACTERGUID)_Char)
		THEN
		NOT DB_IsNotMessingAround(_Char);
		NOT DB_RemoveIsNotMessingAround(_Char);
		ClearTag(_Char,"NOT_MESSING_AROUND");
		
		IF
		DB_AttackOnAssault(_Char)
		AND
		NOT DB_IsNotMessingAround(_Char)
		THEN
		NOT DB_AttackOnAssault(_Char);
		ClearTag(_Char,"NOT_MESSING_AROUND");
		//END_REGION
		
		//REGION Attitude Change
		QRY
		QryNPCCaresAboutVictim((CHARACTERGUID)_NPC,(CHARACTERGUID)_Victim,(INTEGER)_)
		AND
		IsTagged(_NPC,"ANIMAL",1)
		AND
		IsTagged(_Victim,"ANIMAL",1)
		THEN
		DB_NOOP(1);
		
		QRY
		QryNPCCaresAboutVictim((CHARACTERGUID)_NPC,(CHARACTERGUID)_Victim,_Primary)
		AND
		IsTagged(_NPC,"ANIMAL",0)
		AND
		QryNonAnimalNPCCaresAboutVictim(_NPC,_Victim,_Primary)
		THEN
		DB_NOOP(1);
		
		
		QRY
		QryNonAnimalNPCCaresAboutVictim((CHARACTERGUID)_NPC,(CHARACTERGUID)_Victim,0)
		AND
		ObjectIsCharacter(_Victim,0)
		THEN
		DB_NOOP(1);
		
		QRY
		QryNonAnimalNPCCaresAboutVictim((CHARACTERGUID)_NPC,(CHARACTERGUID)_Victim,0)
		AND
		ObjectIsCharacter(_Victim,1)
		AND
		CharacterIsAlly(_NPC,_Victim,1)
		THEN
		DB_NOOP(1);
		
		QRY
		QryNonAnimalNPCCaresAboutVictim((CHARACTERGUID)_NPC,(CHARACTERGUID)_Victim,1)
		THEN
		DB_NOOP(1);
		
		IF
		CharacterOnCrimeSensibleActionNotification(_NPC,_Region,_CrimeID,_PriorityName,_Dialog,_Criminal,_Criminal2,_Criminal3,_Criminal4,_Primary)
		AND
		CrimeGetType(_CrimeID,_CrimeName)
		AND
		DB_CrimeAttitudeChange(_CrimeName,_AttitudeAmountToSub)
		AND
		CrimeGetVictim(_CrimeID,_Victim)
		THEN
		ProcCheckAdjustAttitude(_NPC,_Victim,_Criminal,_Criminal2,_Criminal3,_Criminal4,_AttitudeAmountToSub,_Primary);
		
		PROC
		ProcCheckAdjustAttitude((CHARACTERGUID)_NPC,(CHARACTERGUID)_Victim,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(INTEGER)_AttitudeAmountToSub, (INTEGER)_Primary)
		AND
		QryNPCCaresAboutVictim(_NPC,_Victim,_Primary)
		THEN
		ProcCrimeCheckIfAttitudeCauseCombat(_NPC,_Criminal,_AttitudeAmountToSub);
		ProcCrimeCheckIfAttitudeCauseCombat(_NPC,_Criminal2,_AttitudeAmountToSub);
		ProcCrimeCheckIfAttitudeCauseCombat(_NPC,_Criminal3,_AttitudeAmountToSub);
		ProcCrimeCheckIfAttitudeCauseCombat(_NPC,_Criminal4,_AttitudeAmountToSub);
		
		PROC
		ProcCrimeCheckIfAttitudeCauseCombat((CHARACTERGUID)_NPC,(CHARACTERGUID)_Criminal,(INTEGER)_AttitudeAmountToSub)
		AND
		CharacterGetAttitudeTowardsPlayer(_NPC,_Criminal,_NPCCurrentAttitude)
		AND
		IntegerSum(_NPCCurrentAttitude,_AttitudeAmountToSub,_NewNPCAttitude)
		AND
		_NewNPCAttitude > -75 //We Doin't want Lowering Attitude To Start Combat
		THEN
		CharacterAddAttitudeTowardsPlayer(_NPC,_Criminal,_AttitudeAmountToSub);
		
		PROC
		ProcCrimeCheckIfAttitudeCauseCombat((CHARACTERGUID)_NPC,(CHARACTERGUID)_Criminal,(INTEGER)_AttitudeAmountToSub)
		AND
		CharacterGetAttitudeTowardsPlayer(_NPC,_Criminal,_NPCCurrentAttitude)
		AND
		IntegerSum(_NPCCurrentAttitude,_AttitudeAmountToSub,_NewNPCAttitude)
		AND
		_NewNPCAttitude <= -75 //We Doin't want Lowering Attitude To Start Combat
		AND
		IntegerSubtract(-74,_NPCCurrentAttitude,_NewAttitudeToAdd)
		THEN
		CharacterAddAttitudeTowardsPlayer(_NPC,_Criminal,_NewAttitudeToAdd);
		
		//END_REGION
		
		//REGION Dialog interrupting
		
		QRY
		QRY_CrimeNPCUnAvailableForDialog((CHARACTERGUID)_NPC,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		IsSpeakerReserved(_NPC,1)
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_CrimeNPCUnAvailableForDialog((CHARACTERGUID)_NPC,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		_Criminal != NULL_00000000-0000-0000-0000-000000000000
		AND
		IsSpeakerReserved(_Criminal,1)
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_CrimeNPCUnAvailableForDialog((CHARACTERGUID)_NPC,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		_Criminal2 != NULL_00000000-0000-0000-0000-000000000000
		AND
		IsSpeakerReserved(_Criminal2,1)
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_CrimeNPCUnAvailableForDialog((CHARACTERGUID)_NPC,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		_Criminal3 != NULL_00000000-0000-0000-0000-000000000000
		AND
		IsSpeakerReserved(_Criminal3,1)
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_CrimeNPCUnAvailableForDialog((CHARACTERGUID)_NPC,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		_Criminal4 != NULL_00000000-0000-0000-0000-000000000000
		AND
		IsSpeakerReserved(_Criminal4,1)
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_CrimeNPCUnAvailableForDialog((CHARACTERGUID)_NPC,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		CharacterIsDead(_NPC,1)
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_CrimeNPCUnAvailableForDialog((CHARACTERGUID)_NPC,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		GetRegion(_NPC,_Region)
		AND
		NOT DB_CurrentLevel(_Region)
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_CrimeNPCUnAvailableForDialog((CHARACTERGUID)_NPC,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		CombatGetIDForCharacter(_NPC,_ID)
		AND
		_ID!=0
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_CrimeNPCUnAvailableForDialog((CHARACTERGUID)_NPC,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		CharacterIsEnemy(_NPC,_Criminal,1)
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_CrimeNPCUnAvailableForDialog((CHARACTERGUID)_NPC,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		_Criminal2 != NULL_00000000-0000-0000-0000-000000000000
		AND
		CharacterIsEnemy(_NPC,_Criminal2,1)
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_CrimeNPCUnAvailableForDialog((CHARACTERGUID)_NPC,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		_Criminal3 != NULL_00000000-0000-0000-0000-000000000000
		AND
		CharacterIsEnemy(_NPC,_Criminal3,1)
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_CrimeNPCUnAvailableForDialog((CHARACTERGUID)_NPC,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		_Criminal4 != NULL_00000000-0000-0000-0000-000000000000
		AND
		CharacterIsEnemy(_NPC,_Criminal4,1)
		THEN
		DB_NOOP(1);
		
		PROC
		ProcTryStopDialogFor((CHARACTERGUID)_Char)
		AND
		_Char != NULL_00000000-0000-0000-0000-000000000000
		AND
		CharacterIsPlayer(_Char,1)
		AND
		DB_DialogPlayers(_Inst,_Char,_)
		AND
		DB_DialogName(_CurrentDialog,_Inst)
		AND
		NOT DB_Crime_DoNotStopDialog((STRING)_CurrentDialog)
		THEN
		DialogRequestStop(_Char);
		DB_StoppedDialog(1);
		
		PROC
		ProcTryStopDialogFor((CHARACTERGUID)_Char)
		AND
		_Char != NULL_00000000-0000-0000-0000-000000000000
		AND
		CharacterIsPlayer(_Char,0)
		AND
		DB_DialogNPCs(_Inst,_Char,_)
		AND
		DB_DialogName(_CurrentDialog,_Inst)
		AND
		NOT DB_Crime_DoNotStopDialog(_CurrentDialog)
		THEN
		DialogRequestStop(_Char);
		DB_StoppedDialog(1);
		
		PROC
		ProcCrimeInterruptStoryDialogs((INTEGER)_CrimeID,(STRING)_CrimeDialog,1,(CHARACTERGUID)_NPC,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		THEN
		ProcTryStopDialogFor(_NPC);
		ProcTryStopDialogFor(_Criminal);
		ProcTryStopDialogFor(_Criminal2);
		ProcTryStopDialogFor(_Criminal3);
		ProcTryStopDialogFor(_Criminal4);
		
		PROC
		ProcCrimeInterruptStoryDialogs(_,_,1,_,_,_,_,_)
		AND
		DB_StoppedDialog(1)
		THEN
		NOT DB_StoppedDialog(1);
		FireOsirisEvents();
		
		PROC
		ProcCrimeInterruptStoryDialogs((INTEGER)_CrimeID,(STRING)_CrimeDialog,0,(CHARACTERGUID)_NPC,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		DB_DialogNPCs(_Inst,_NPC,_)
		AND
		DB_DialogName(_CurrentDialog,_Inst)
		AND
		NOT DB_Crime_DoNotStopDialog(_CurrentDialog)
		THEN
		DialogRequestStop(_NPC);
		FireOsirisEvents();
		
		PROC
		ProcCrimeInterruptStoryDialogs((INTEGER)_CrimeID,(STRING)_CrimeDialog,0,(CHARACTERGUID)_NPC,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		NOT QRY_CrimeNPCUnAvailableForDialog(_NPC,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000)
		THEN
		ProcStartCrimeDialog(_CrimeID,_CrimeDialog,0,_NPC,_Criminal,_Criminal2,_Criminal3,_Criminal4);
		
		PROC
		ProcCrimeInterruptStoryDialogs((INTEGER)_CrimeID,(STRING)_CrimeDialog,1,(CHARACTERGUID)_NPC,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		NOT QRY_CrimeNPCUnAvailableForDialog(_NPC,_Criminal,_Criminal2,_Criminal3,_Criminal4)
		THEN
		ProcStartCrimeDialog(_CrimeID,_CrimeDialog,1,_NPC,_Criminal,_Criminal2,_Criminal3,_Criminal4);
		
		PROC
		ProcHandleCrimeDialog((CHARACTERGUID)_Warner,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_CrimeDialog,1,_)
		AND
		DB_CheckInterrupt(_CrimeID,_Warner)
		THEN
		DB_Interrupted(_CrimeID,_Warner,1);
		
		PROC
		ProcHandleCrimeDialog((CHARACTERGUID)_Warner,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_CrimeDialog,1,_)
		AND
		DB_CheckInterrupt(_CrimeID,_Warner)
		THEN
		NOT DB_CheckInterrupt(_CrimeID,_Warner);
		
		PROC
		ProcStartCrimeDialog((INTEGER)_CrimeID,(STRING)_CrimeDialog,(INTEGER)_IsInteractive,(CHARACTERGUID)_NPC,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		THEN
		DB_NOOP(1);
		
		PROC
		ProcStartCrimeDialog((INTEGER)_CrimeID,(STRING)_CrimeDialog,1,(CHARACTERGUID)_NPC,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		DialogStartCrimeDialog(_CrimeID,_CrimeDialog,1,_NPC,_Criminal,_Criminal2,_Criminal3,_Criminal4,_Success)
		THEN
		DB_CheckInterrupt(_CrimeID,_NPC);
		DB_CrimeWarner(_CrimeID,_NPC,_CrimeDialog);
		ProcHandleCrimeDialog(_NPC,_Criminal,_Criminal2,_Criminal3,_Criminal4,_CrimeDialog,_Success,1);
		
		PROC
		ProcStartCrimeDialog((INTEGER)_CrimeID,(STRING)_CrimeDialog,0,(CHARACTERGUID)_NPC,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		DialogStartCrimeDialog(_CrimeID,_CrimeDialog,0,_NPC,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,_Success)
		AND
		CrimeGetType(_CrimeID,_CrimeType)
		THEN
		DB_Crime_WarningAD_Target(_CrimeType,_NPC,_Criminal); // in AD we don't have player, so to clear Warning flags, store target player in this DB
		DB_CheckInterrupt(_CrimeID,_NPC);
		CrimeConfrontationDone(_CrimeID,_NPC); // confrontation done for ADs
		ProcHandleCrimeDialog(_NPC,_Criminal,_Criminal2,_Criminal3,_Criminal4,_CrimeDialog,_Success,0);
		DB_Interrupted(_CrimeID,_NPC,1);
		
		PROC
		ProcCrimeInterruptStoryDialogs((INTEGER)_CrimeID,(STRING)_CrimeDialog,(INTEGER)_MarkForInteractive,(CHARACTERGUID)_NPC,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		NOT DB_Interrupted(_CrimeID,_NPC,1)
		THEN
		//NPC not available for dialog anymore
		DB_Crime_FailedToInterruptStoryDialogs((INTEGER)_CrimeId,(STRING)_CrimeDialog,(CHARACTERGUID)_NPC,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4);
		
		PROC
		ProcCrimeInterruptStoryDialogs((INTEGER)_CrimeID,(STRING)_CrimeDialog,(INTEGER)_MarkForInteractive,(CHARACTERGUID)_NPC,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		THEN
		NOT DB_Interrupted(_CrimeID,_NPC,1);
		//END_REGION
		
		//REGION -ForbiddenItem crime. Action Requests handling.
		
		/***************************************/
		//--- Crime reactions & Move crime
		/***************************************/
		IF
		DialogStarted("GEB_Warning_UseForbiddenItem",_Inst)
		AND
		DB_DialogPlayers(_Inst,_Player,1)
		AND
		DB_CRIME_ForbiddenStatus(_Status)
		AND
		HasActiveStatus(_Player,_Status,1)
		THEN
		RemoveStatus(_Player,_Status);
		
		IF
		CharacterUsedSkillOnTarget(_Player,_Item,_,"teleportation")
		AND
		CharacterIsPlayer(_Player,1)
		AND
		ObjectIsItem(_Item,1)
		AND
		ItemCanSitOn((ITEMGUID)_Item,0)
		AND
		ItemGetOwner(_Item,_Owner)
		AND
		NOT QRY_CharacterIsNull(_Owner)
		AND
		CharacterIsPlayer(_Owner,0)
		THEN
		CharacterRegisterCrime(_Player,"MoveForbiddenItem",_Item,(CHARACTERGUID)_Owner,0);
		
		PROC
		ProcCrimeTryRegisteringMoveForbiddenItem((CHARACTERGUID)_Player,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		CharacterIsPlayer(_Player,1)
		AND
		ItemCanSitOn(_Item,0)
		AND
		ItemGetOwner(_Item,_Owner)
		AND
		NOT QRY_CharacterIsNull(_Owner)
		AND
		CharacterIsPlayer(_Owner,0)
		THEN
		ProcSendMoveRequestResult(_Player,_Item,_RequestID);
		CharacterRegisterCrime(_Player,"MoveForbiddenItem",_Item,(CHARACTERGUID)_Owner,0);
		DB_MoveCrimeRegistered(1);
		
		PROC
		ProcSendMoveRequestResult((CHARACTERGUID)_Player,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		GetPosition(_Item,_X,_Y,_Z)
		AND
		CrimeIsAnyNPCGoingToReact(_Player,"MoveForbiddenItem",_X,_Y,_Z,_Result)
		AND
		DB_Negate(_Result,_Inverse)
		THEN
		RequestProcessed(_Player,_RequestID,_Inverse);
		
		PROC
		ProcCrimeTryRegisteringMoveForbiddenItem((CHARACTERGUID)_Player,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		NOT DB_MoveCrimeRegistered(1)
		THEN
		RequestProcessed(_Player,_RequestID,1);
		
		PROC
		ProcCrimeTryRegisteringMoveForbiddenItem((CHARACTERGUID)_Player,(ITEMGUID)_Item,(INTEGER)_RequestID)
		THEN
		NOT DB_MoveCrimeRegistered(1);
		
		/***************************************/
		//--- REQUESTS
		/***************************************/
		IF
		CanUseItem(_Char,_Item,_RequestID)
		THEN
		ProcBlockUseOfItem(_Char,_Item);
		ProcProcessUseOfItemWithStatus(_Char,_Item);
		ProcProcessUseOfItem(_Char,_Item,_RequestID);
		
		IF
		CanMoveItem(_Char,_Item,_RequestID)
		THEN
		ProcBlockMoveOfItem(_Char,_Item);
		ProcProcessMoveOfItem(_Char,_Item,_RequestID);
		
		IF
		CanPickupItem(_Char,_Item,_RequestID)
		THEN
		ProcBlockPickupOfItem(_Char,_Item);
		ProcProcessPickupOfItem(_Char,_Item,_RequestID);
		
		IF
		CanLockpickItem(_Char,_Item,_RequestID)
		THEN
		ProcBlockLockpickItem(_Char,_Item);
		ProcProcessLockpickItem(_Char,_Item,_RequestID);
		
		IF
		CanCombineItem(_Char,_ItemA,_ItemB,_ItemC,_ItemD,_ItemE,_RequestID)
		THEN
		ProcBlockCombineItem(_Char,_ItemA);
		ProcBlockCombineItem(_Char,_ItemB);
		ProcBlockCombineItem(_Char,_ItemC);
		ProcBlockCombineItem(_Char,_ItemD);
		ProcBlockCombineItem(_Char,_ItemE);
		ProcProcessCombineItem(_Char,_ItemA,_ItemB,_ItemC,_ItemD,_ItemE,_RequestID);
		
		
		/***************************************/
		//--- BLOCK ACTIONS
		/***************************************/
		/*	Catch one of the following PROCs to set the appropriate DB:
			DB_CustomUseItemResponse((CHARACTERGUID)_Char,(ITEMGUID)_Item,(INTEGER)_Result)
			DB_CustomMoveItemResponse((CHARACTERGUID)_Char,(ITEMGUID)_Item,(INTEGER)_Result)
			DB_CustomPickupItemResponse((CHARACTERGUID)_Char,(ITEMGUID)_Item,(INTEGER)_Result)
			DB_CustomLockpickItemResponse((CHARACTERGUID)_Char,(ITEMGUID)_Item,(INTEGER)_Result)
			DB_CustomCombineItemResponse((CHARACTERGUID)_Char,(ITEMGUID)_Item,(INTEGER)_Result)
		*/
		
		PROC
		ProcBlockUseOfItem((CHARACTERGUID)_Char,(ITEMGUID)_Item)
		THEN
		DB_NOOP(1);
		
		PROC
		ProcBlockMoveOfItem((CHARACTERGUID)_Char,(ITEMGUID)_Item)
		THEN
		DB_NOOP(1);
		
		PROC
		ProcBlockPickupOfItem((CHARACTERGUID)_Char,(ITEMGUID)_Item)
		THEN
		DB_NOOP(1);
		
		PROC
		ProcBlockLockpickItem((CHARACTERGUID)_Char,(ITEMGUID)_Item)
		THEN
		DB_NOOP(1);
		
		PROC
		ProcBlockCombineItem((CHARACTERGUID)_Char,(ITEMGUID)_Item)
		THEN
		DB_NOOP(1);
		
		
		/***************************************/
		//--- BURNING AND ELECTRIFIED items apply status
		/***************************************/
		PROC
		ProcProcessUseOfItemWithStatus((CHARACTERGUID)_Char,(ITEMGUID)_Item)
		AND
		DB_IsPlayer(_Char) // apply only on player not to break story events with NPCs using items
		AND
		NOT DB_CustomUseItemResponse(_Char,_Item,0) // if handled in story, don't apply effect
		AND
		DB_ItemStatusAffectCharacterOnUse(_Status)
		AND
		HasActiveStatus(_Item,_Status,1)
		AND
		NOT QRYItemStatusIsNotAppliedToUser(_Item,_Status)
		THEN
		ApplyStatus(_Char,_Status,12.0);
		
		QRY
		QRYItemStatusIsNotAppliedToUser((ITEMGUID)_Item,(STRING)_Status)
		AND
		_Status == "BURNING"
		AND
		ItemIsTorch(_Item,1)
		THEN
		DB_NOOP(1);
		
		/***************************************/
		//--- PROCESS
		/***************************************/
		// Use
		PROC
		ProcProcessUseOfItem((CHARACTERGUID)_Char,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		DB_CustomUseItemResponse(_Char,_Item,(INTEGER)_Result)
		THEN
		RequestProcessed(_Char,_RequestID,_Result);
		
		PROC
		ProcProcessUseOfItem((CHARACTERGUID)_Char,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		NOT DB_CustomUseItemResponse(_Char,_Item,_)
		AND
		ItemCanSitOn(_Item,0)
		AND
		ItemIsLadder(_Item,0)
		AND
		ItemIsPublicDomain(_Item,0)
		THEN
		DB_HandledRequest(_Char,_Item,_RequestID);
		ProcCrimeTryRegisteringUseForbiddenItem(_Char,_Item,_RequestID);
		
		PROC
		ProcProcessUseOfItem((CHARACTERGUID)_Char,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		NOT DB_CustomUseItemResponse(_Char,_Item,_)
		AND
		NOT DB_HandledRequest(_Char,_Item,_RequestID)
		THEN
		RequestProcessed(_Char,_RequestID,1);
		
		PROC
		ProcProcessUseOfItem((CHARACTERGUID)_Char,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		DB_HandledRequest(_Char,_Item,_RequestID)
		THEN
		NOT DB_HandledRequest(_Char,_Item,_RequestID);
		
		// Move (registers MoveForbiddenItem instead of UseForbiddenItem)
		PROC
		ProcProcessMoveOfItem((CHARACTERGUID)_Char,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		DB_CustomMoveItemResponse(_Char,_Item,(INTEGER)_Result)
		THEN
		RequestProcessed(_Char,_RequestID,_Result);
		
		PROC
		ProcProcessMoveOfItem((CHARACTERGUID)_Char,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		NOT DB_CustomMoveItemResponse(_Char,_Item,_)
		THEN
		ProcCrimeTryRegisteringMoveForbiddenItem(_Char,_Item,_RequestID);
		
		// Pickup
		PROC
		ProcProcessPickupOfItem((CHARACTERGUID)_Char,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		DB_CustomPickupItemResponse(_Char,_Item,(INTEGER)_Result)
		THEN
		RequestProcessed(_Char,_RequestID,_Result);
		
		PROC
		ProcProcessPickupOfItem((CHARACTERGUID)_Char,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		NOT DB_CustomPickupItemResponse(_Char,_Item,_)
		THEN
		ProcCrimeTryRegisteringStealItem(_Char,_Item,_RequestID);
		
		// Lockpick
		PROC
		ProcProcessLockpickItem((CHARACTERGUID)_Char,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		DB_CustomLockpickItemResponse(_Char,_Item,(INTEGER)_Result)
		THEN
		RequestProcessed(_Char,_RequestID,_Result);
		
		PROC
		ProcProcessLockpickItem((CHARACTERGUID)_Char,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		NOT DB_CustomLockpickItemResponse(_Char,_Item,_)
		THEN
		ProcCrimeTryRegisteringUseForbiddenItem(_Char,_Item,_RequestID);
		
		// Combine
		PROC
		ProcProcessCombineItem(_Player,_ItemA,_ItemB,_ItemC,_ItemD,_ItemE,_RequestID)
		AND
		NOT QryCombineItemHasCustomResult(_Player,_ItemA,_ItemB,_ItemC,_ItemD,_ItemE)
		AND
		CharacterIsPlayer(_Player,1)
		THEN
		ProcCrimeCheckRegisterUseForbiddenItem(_Player,_ItemA,_RequestID);
		ProcCrimeCheckRegisterUseForbiddenItem(_Player,_ItemB,_RequestID);
		ProcCrimeCheckRegisterUseForbiddenItem(_Player,_ItemC,_RequestID);
		ProcCrimeCheckRegisterUseForbiddenItem(_Player,_ItemD,_RequestID);
		ProcCrimeCheckRegisterUseForbiddenItem(_Player,_ItemE,_RequestID);
		
		PROC
		ProcProcessCombineItem((CHARACTERGUID)_Char,(ITEMGUID)_ItemA,(ITEMGUID)_ItemB,(ITEMGUID)_ItemC,(ITEMGUID)_ItemD,(ITEMGUID)_ItemE,(INTEGER)_RequestID)
		AND
		QryCombineItemHasCustomResult(_Char,_ItemA,_ItemB,_ItemC,_ItemD,_ItemE)
		THEN
		ProcProcessCustomCombineResponse(_Char,_ItemA,_ItemB,_ItemC,_ItemD,_ItemE,_RequestID);
		
		PROC
		ProcProcessCustomCombineResponse((CHARACTERGUID)_Char,(ITEMGUID)_ItemA,(ITEMGUID)_ItemB,(ITEMGUID)_ItemC,(ITEMGUID)_ItemD,(ITEMGUID)_ItemE,(INTEGER)_RequestID)
		AND
		QryCombineItemIsBlocked(_Char,_ItemA,_ItemB,_ItemC,_ItemD,_ItemE)
		THEN
		RequestProcessed(_Char,_RequestID,0);
		
		PROC
		ProcProcessCustomCombineResponse((CHARACTERGUID)_Char,(ITEMGUID)_ItemA,(ITEMGUID)_ItemB,(ITEMGUID)_ItemC,(ITEMGUID)_ItemD,(ITEMGUID)_ItemE,(INTEGER)_RequestID)
		AND
		NOT QryCombineItemIsBlocked(_Char,_ItemA,_ItemB,_ItemC,_ItemD,_ItemE)
		THEN
		RequestProcessed(_Char,_RequestID,1);
		
		
		//--- General proc:
		PROC
		ProcCrimeTryRegisteringUseForbiddenItem((CHARACTERGUID)_Char,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		CharacterIsPlayer(_Char,1)
		THEN
		ProcCrimeCheckRegisterUseForbiddenItem(_Char,_Item,_RequestID);
		
		PROC
		ProcCrimeTryRegisteringUseForbiddenItem((CHARACTERGUID)_Char,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		CharacterIsPlayer(_Char,0)
		THEN
		RequestProcessed(_Char,_RequestID,1);
		
		PROC
		ProcCrimeTryRegisteringStealItem((CHARACTERGUID)_Char,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		CharacterIsPlayer(_Char,0)
		THEN
		DB_StealRequestHandled(1);
		RequestProcessed(_Char,_RequestID,1);
		
		PROC
		ProcCrimeTryRegisteringStealItem((CHARACTERGUID)_Char,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		NOT DB_StealRequestHandled(1)
		AND
		NOT QryCrimeItemHasNPCOwner(_Item)
		THEN
		DB_StealRequestHandled(1);
		RequestProcessed(_Char,_RequestID,1);
		
		//we only register a crime here if they're going ot react, sicne we then block the pickup
		//in the case they won't the reaction to the steal event will register the crime
		PROC
		ProcCrimeTryRegisteringStealItem((CHARACTERGUID)_Char,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		NOT DB_StealRequestHandled(1)
		AND
		ItemGetOwner(_Item,_Victim)
		AND
		CharacterIsPlayer(_Victim,0)
		AND
		GetPosition(_Item,_X,_Y,_Z)
		AND
		CrimeIsAnyNPCGoingToReact(_Char,"Steal",_X,_Y,_Z,1)
		THEN
		DB_StealRequestHandled(1);
		RequestProcessed(_Char,_RequestID,0);
		CharacterRegisterCrimeWithPosition(_Char,"Steal",_Item,_Victim,_X,_Y,_Z,0);
		
		PROC
		ProcCrimeTryRegisteringStealItem((CHARACTERGUID)_Char,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		NOT DB_StealRequestHandled(1)
		THEN
		RequestProcessed(_Char,_RequestID,1);
		
		PROC
		ProcCrimeTryRegisteringStealItem(_,_,_)
		THEN
		NOT DB_StealRequestHandled(1);
		
		/***************************************/
		//--- CLEAR custom response facts
		/***************************************/
		PROC
		ProcProcessUseOfItem((CHARACTERGUID)_Char,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		DB_CustomUseItemResponse(_Char,_Item,_Result)
		THEN
		NOT DB_CustomUseItemResponse(_Char,_Item,_Result);
		
		PROC
		ProcProcessMoveOfItem((CHARACTERGUID)_Char,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		DB_CustomMoveItemResponse(_Char,_Item,_Result)
		THEN
		NOT DB_CustomMoveItemResponse(_Char,_Item,_Result);
		
		PROC
		ProcProcessPickupOfItem((CHARACTERGUID)_Char,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		DB_CustomPickupItemResponse(_Char,_Item,_Result)
		THEN
		NOT DB_CustomPickupItemResponse(_Char,_Item,_Result);
		
		PROC
		ProcProcessLockpickItem((CHARACTERGUID)_Char,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		DB_CustomLockpickItemResponse(_Char,_Item,_Result)
		THEN
		NOT DB_CustomLockpickItemResponse(_Char,_Item,_Result);
		
		PROC
		ProcProcessCombineItem((CHARACTERGUID)_Char,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		DB_CustomCombineItemResponse(_Char,_Item,_Result)
		THEN
		NOT DB_CustomCombineItemResponse(_Char,_Item,_Result);
		
		
		/***************************************/
		//--- REGISTERING CRIMES and responding to the requests
		/***************************************/
		PROC
		ProcCrimeCheckRegisterUseForbiddenItem((CHARACTERGUID)_Player,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		NOT QryCrimeItemHasNPCOwner(_Item)
		AND
		NOT DB_DontCreateUseForbiddenItem(_Item)
		THEN
		RequestProcessed(_Player,_RequestID,1);
		
		PROC
		ProcCrimeCheckRegisterUseForbiddenItem((CHARACTERGUID)_Player,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		DB_DontCreateUseForbiddenItem(_Item)
		THEN
		RequestProcessed(_Player,_RequestID,1);
		
		PROC
		ProcCrimeCheckRegisterUseForbiddenItem((CHARACTERGUID)_Player,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		NOT DB_DontCreateUseForbiddenItem(_Item)
		AND
		QryCrimeItemHasNPCOwner(_Item)
		AND
		HasActiveStatus(_Player,"SNEAKING",1)
		THEN
		DB_Crime_UseForbiddenItem(_Player,"SneakUseForbiddenItem",_Item);
		RequestProcessed(_Player,_RequestID,1);
		CharacterRegisterCrime(_Player,"SneakUseForbiddenItem",_Item,NULL_00000000-0000-0000-0000-000000000000,0);
		
		PROC
		ProcCrimeCheckRegisterUseForbiddenItem((CHARACTERGUID)_Player,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		NOT DB_DontCreateUseForbiddenItem(_Item)
		AND
		QryCrimeItemHasNPCOwner(_Item)
		AND
		HasActiveStatus(_Player,"SNEAKING",0)
		AND
		GetPosition(_Item,_X,_Y,_Z)
		AND
		CrimeIsAnyNPCGoingToReact(_Player,"UseForbiddenItem",_X,_Y,_Z,_NPCWillReact)
		THEN
		ProcCrimeRegisterUseForbiddenItem(_Player,_Item,_RequestID,_NPCWillReact);
		
		PROC
		ProcCrimeRegisterUseForbiddenItem((CHARACTERGUID)_Player,(ITEMGUID)_Item,(INTEGER)_RequestID,(INTEGER)_NPCWillReact)
		AND
		DB_Negate(_NPCWillReact,_Result)
		THEN
		DB_Crime_UseForbiddenItem(_Player,"UseForbiddenItem",_Item);
		RequestProcessed(_Player,_RequestID,_Result);
		CharacterRegisterCrime(_Player,"UseForbiddenItem",_Item,NULL_00000000-0000-0000-0000-000000000000,0);
		
		/***************************************/
		//--- CHECK CRIME REACTIONS
		/***************************************/
		/*
		IF
		CharacterOnCrimeSensibleActionNotification(_,_,_CrimeID,_,_,_,_Criminal1,_Criminal2,_Criminal3,_Criminal4)
		AND
		CrimeGetType(_CrimeID,"UseForbiddenItem")
		THEN
		ProcCrimeForbiddenItemGetEvidence(_CrimeID,_Criminal1,"UseForbiddenItem");
		
		IF
		CharacterOnCrimeSensibleActionNotification(_,_,_CrimeID,_,_,_,_Criminal1,_Criminal2,_Criminal3,_Criminal4)
		AND
		CrimeGetType(_CrimeID,"SneakUseForbiddenItem")
		THEN
		ProcCrimeForbiddenItemGetEvidence(_CrimeID,_Criminal1,"SneakUseForbiddenItem");
		*/
		
		IF
		OnCrimeConfrontationDone(_CrimeID,_Investigator,1,_Criminal1,_Criminal2,_Criminal3,_Criminal4)
		AND
		CrimeGetType(_CrimeID,"UseForbiddenItem")
		THEN
		ProcCrimeForbiddenItemGetEvidence(_CrimeID,_Criminal1,"UseForbiddenItem");
		
		IF
		OnCrimeConfrontationDone(_CrimeID,_Investigator,1,_Criminal1,_Criminal2,_Criminal3,_Criminal4)
		AND
		CrimeGetType(_CrimeID,"SneakUseForbiddenItem")
		THEN
		ProcCrimeForbiddenItemGetEvidence(_CrimeID,_Criminal1,"SneakUseForbiddenItem");
		
		PROC
		ProcCrimeForbiddenItemGetEvidence((INTEGER)_CrimeID,(CHARACTERGUID)_Criminal,(STRING)_CrimeType)
		AND
		NOT QRY_CharacterIsNull(_Criminal)
		AND
		CrimeGetNumberOfEvidence(_CrimeID,_NumEvidence)
		AND
		_NumEvidence > 0
		AND
		CrimeGetEvidence(_CrimeID,1,(ITEMGUID)_Item)
		THEN
		ProcCrimeStopForbiddenItem(_Criminal,_CrimeType,_Item);
		
		PROC
		ProcCrimeForbiddenItemGetEvidence((INTEGER)_CrimeID,(CHARACTERGUID)_Criminal,(STRING)_CrimeType)
		AND
		NOT QRY_CharacterIsNull(_Criminal)
		AND
		CrimeGetNumberOfEvidence(_CrimeID,_NumEvidence)
		AND
		_NumEvidence < 1
		THEN
		ProcCrimeStopForbiddenItem(_Criminal,_CrimeType,NULL_00000000-0000-0000-0000-000000000000);
		
		PROC
		ProcCrimeStopForbiddenItem((CHARACTERGUID)_Criminal,(STRING)_CrimeType,(ITEMGUID)_Evidence)
		THEN
		CharacterStopCrime(_Criminal,_CrimeType,_Evidence);
		
		PROC
		ProcCrimeStopForbiddenItem((CHARACTERGUID)_Criminal,(STRING)_CrimeType,(ITEMGUID)_Evidence)
		AND
		DB_Crime_UseForbiddenItem(_Player,_CrimeType,_Evidence)
		THEN
		NOT DB_Crime_UseForbiddenItem(_Player,_CrimeType,_Evidence);
		
		
		/***************************************/
		//--- STOPPING CRIMES
		/***************************************/
		IF
		CharacterStoppedUsingItem(_Player,_Item)
		AND
		DB_Crime_UseForbiddenItem(_Player,_CrimeType,_Item)
		THEN
		NOT DB_Crime_UseForbiddenItem(_Player,_CrimeType,_Item);
		CharacterStopCrime(_Player,_CrimeType,_Item);
		
		/*
		IF
		CharacterMovedItem(_Player,_Item)
		CharacterStoppedMovingItem(_Player,_Item)
		AND
		DB_Crime_UseForbiddenItem(_Player,_CrimeType,_Item)
		THEN
		NOT DB_Crime_UseForbiddenItem(_Player,_CrimeType,_Item);
		CharacterStopCrime(_Player,_CrimeType,_Item);
		
		IF
		CharacterStoppedPickingUpItem(_Player,_Item)
		AND
		DB_Crime_UseForbiddenItem(_Player,_CrimeType,_Item)
		THEN
		NOT DB_Crime_UseForbiddenItem(_Player,_CrimeType,_Item);
		CharacterStopCrime(_Player,_CrimeType,_Item);
		
		IF
		CharacterStoppedLockpickingItem(_Player,_Item)
		AND
		DB_Crime_UseForbiddenItem(_Player,_CrimeType,_Item)
		THEN
		NOT DB_Crime_UseForbiddenItem(_Player,_CrimeType,_Item);
		CharacterStopCrime(_Player,_CrimeType,_Item);
		*/
		
		IF
		CharacterStoppedCombiningItems(_Player,_ItemA,_ItemB,_ItemC,_ItemD,_ItemE)
		THEN
		ProcCrimeStopCombineItemCrime(_Player,_ItemA);
		ProcCrimeStopCombineItemCrime(_Player,_ItemB);
		ProcCrimeStopCombineItemCrime(_Player,_ItemC);
		ProcCrimeStopCombineItemCrime(_Player,_ItemD);
		ProcCrimeStopCombineItemCrime(_Player,_ItemE);
		
		PROC
		ProcCrimeStopCombineItemCrime((CHARACTERGUID)_Player,(ITEMGUID)_Item)
		AND
		DB_Crime_UseForbiddenItem(_Player,_CrimeType,_Item)
		THEN
		CharacterStopCrime(_Player,_CrimeType,_Item);
		
		QRY
		QryCrimeClearCombineItemBD((CHARACTERGUID)_Player,(STRING)_CrimeType)
		AND
		DB_Crime_UseForbiddenItem(_Player,_CrimeType,_Item)
		THEN
		NOT DB_Crime_UseForbiddenItem(_Player,_CrimeType,_Item);
		
		
		/***************************************/
		//--- QUERIES
		/***************************************/
		
		QRY
		QryCrimeIsValidItemRequest((CHARACTERGUID)_Char,(ITEMGUID)_Item)
		AND
		CharacterIsPlayer(_Char,0)
		THEN
		DB_NOOP(1);
		
		QRY
		QryCrimeIsValidItemRequest((CHARACTERGUID)_Char,(ITEMGUID)_Item)
		AND
		CharacterIsPlayer(_Char,1)
		AND
		NOT QryCrimeItemHasNPCOwner((ITEMGUID)_Item)
		THEN
		DB_NOOP(1);
		
		QRY
		QryCrimeCombinedItemsAreValid((ITEMGUID)_ItemA,(ITEMGUID)_ItemB,(ITEMGUID)_ItemC,(ITEMGUID)_ItemD,(ITEMGUID)_ItemE)
		AND
		NOT QryCrimeItemHasNPCOwner(_ItemA)
		AND
		NOT QryCrimeItemHasNPCOwner(_ItemB)
		AND
		NOT QryCrimeItemHasNPCOwner(_ItemC)
		AND
		NOT QryCrimeItemHasNPCOwner(_ItemD)
		AND
		NOT QryCrimeItemHasNPCOwner(_ItemE)
		THEN
		DB_NOOP(1);
		
		QRY
		QryCrimeItemHasNPCOwner((ITEMGUID)_Item)
		AND
		ItemGetOwner(_Item,_Char)
		AND
		NOT QRY_CharacterIsNull(_Char)
		AND
		CharacterIsPlayer(_Char,0)
		THEN
		DB_NOOP(1);
		
		/**** Combine item custom result ****/
		QRY
		QryCombineItemHasCustomResult((CHARACTERGUID)_Player,(ITEMGUID)_ItemA,(ITEMGUID)_ItemB,(ITEMGUID)_ItemC,(ITEMGUID)_ItemD,(ITEMGUID)_ItemE)
		AND
		DB_CustomCombineItemResponse(_Player,_ItemA,_)
		THEN
		DB_NOOP(1);
		
		QRY
		QryCombineItemHasCustomResult((CHARACTERGUID)_Player,(ITEMGUID)_ItemA,(ITEMGUID)_ItemB,(ITEMGUID)_ItemC,(ITEMGUID)_ItemD,(ITEMGUID)_ItemE)
		AND
		DB_CustomCombineItemResponse(_Player,_ItemB,_)
		THEN
		DB_NOOP(1);
		
		QRY
		QryCombineItemHasCustomResult((CHARACTERGUID)_Player,(ITEMGUID)_ItemA,(ITEMGUID)_ItemB,(ITEMGUID)_ItemC,(ITEMGUID)_ItemD,(ITEMGUID)_ItemE)
		AND
		DB_CustomCombineItemResponse(_Player,_ItemC,_)
		THEN
		DB_NOOP(1);
		
		QRY
		QryCombineItemHasCustomResult((CHARACTERGUID)_Player,(ITEMGUID)_ItemA,(ITEMGUID)_ItemB,(ITEMGUID)_ItemC,(ITEMGUID)_ItemD,(ITEMGUID)_ItemE)
		AND
		DB_CustomCombineItemResponse(_Player,_ItemD,_)
		THEN
		DB_NOOP(1);
		
		QRY
		QryCombineItemHasCustomResult((CHARACTERGUID)_Player,(ITEMGUID)_ItemA,(ITEMGUID)_ItemB,(ITEMGUID)_ItemC,(ITEMGUID)_ItemD,(ITEMGUID)_ItemE)
		AND
		DB_CustomCombineItemResponse(_Player,_ItemE,_)
		THEN
		DB_NOOP(1);
		
		
		/**** Combine item is blocked ****/
		QRY
		QryCombineItemIsBlocked((CHARACTERGUID)_Player,(ITEMGUID)_ItemA,(ITEMGUID)_ItemB,(ITEMGUID)_ItemC,(ITEMGUID)_ItemD,(ITEMGUID)_ItemE)
		AND
		DB_CustomCombineItemResponse(_Player,_ItemA,1)
		THEN
		DB_NOOP(1);
		
		QRY
		QryCombineItemIsBlocked((CHARACTERGUID)_Player,(ITEMGUID)_ItemA,(ITEMGUID)_ItemB,(ITEMGUID)_ItemC,(ITEMGUID)_ItemD,(ITEMGUID)_ItemE)
		AND
		DB_CustomCombineItemResponse(_Player,_ItemB,1)
		THEN
		DB_NOOP(1);
		
		QRY
		QryCombineItemIsBlocked((CHARACTERGUID)_Player,(ITEMGUID)_ItemA,(ITEMGUID)_ItemB,(ITEMGUID)_ItemC,(ITEMGUID)_ItemD,(ITEMGUID)_ItemE)
		AND
		DB_CustomCombineItemResponse(_Player,_ItemC,1)
		THEN
		DB_NOOP(1);
		
		QRY
		QryCombineItemIsBlocked((CHARACTERGUID)_Player,(ITEMGUID)_ItemA,(ITEMGUID)_ItemB,(ITEMGUID)_ItemC,(ITEMGUID)_ItemD,(ITEMGUID)_ItemE)
		AND
		DB_CustomCombineItemResponse(_Player,_ItemD,1)
		THEN
		DB_NOOP(1);
		
		QRY
		QryCombineItemIsBlocked((CHARACTERGUID)_Player,(ITEMGUID)_ItemA,(ITEMGUID)_ItemB,(ITEMGUID)_ItemC,(ITEMGUID)_ItemD,(ITEMGUID)_ItemE)
		AND
		DB_CustomCombineItemResponse(_Player,_ItemE,1)
		THEN
		DB_NOOP(1);
		
		//END_REGION
		
		//----------------------------------- CUSTOM -----------------------------------
		//REGION Override Sensible Action
		
		// ------ Setting
		PROC
		ProcCrimeSetAllCustomSensibleAction((CHARACTERGUID)_Character,(STRING)_CrimeName,(STRING)_CustomReactionName)
		THEN
		ProcCrimeSetCustomPrimarySensibleAction(_Character,_CrimeName,_CustomReactionName);
		ProcCrimeSetCustomSecondarySensibleAction(_Character,_CrimeName,_CustomReactionName);
		
		
		// Primary
		PROC
		ProcCrimeSetCustomPrimarySensibleAction((CHARACTERGUID)_Character,(STRING)_CrimeName,(STRING)_CustomReactionName)
		AND
		DB_CrimeReaction_CustomSensibleAction(_Character,_CrimeName,1)
		AND
		StringConcatenate("Setting a custom primary sensible action [",_CustomReactionName,_Part1)
		AND
		StringConcatenate(_Part1,"] on a character that already have one for crime: ",_Part2)
		AND
		StringConcatenate(_Part2,_CrimeName,_Message)
		THEN
		DebugBreak(_Message);
		
		PROC
		ProcCrimeSetCustomPrimarySensibleAction((CHARACTERGUID)_Character,(STRING)_CrimeName,(STRING)_)
		THEN
		DB_CrimeReaction_CustomSensibleAction(_Character,_CrimeName,1);
		
		PROC
		ProcCrimeSetCustomPrimarySensibleAction((CHARACTERGUID)_Character,(STRING)_CrimeName,(STRING)_CustomReactionName)
		AND
		_CustomReactionName == ""
		THEN
		ProcCrimeSetCustomSensibleActionVariable(_Character,_CrimeName,"CRIME_UndefinedSensibleAction","Primary_");
		
		PROC
		ProcCrimeSetCustomPrimarySensibleAction((CHARACTERGUID)_Character,(STRING)_CrimeName,(STRING)_CustomReactionName)
		AND
		_CustomReactionName != ""
		THEN
		ProcCrimeSetCustomSensibleActionVariable(_Character,_CrimeName,_CustomReactionName,"Primary_");
		
		
		// Secondary
		PROC
		ProcCrimeSetCustomSecondarySensibleAction((CHARACTERGUID)_Character,(STRING)_CrimeName,(STRING)_CustomReactionName)
		AND
		DB_CrimeReaction_CustomSensibleAction(_Character,_CrimeName,0)
		AND
		StringConcatenate("Setting a custom secondary sensible action [",_CustomReactionName,_Part1)
		AND
		StringConcatenate(_Part1,"] on a character that already have one for crime: ",_Part2)
		AND
		StringConcatenate(_Part2,_CrimeName,_Message)
		THEN
		DebugBreak(_Message);
		
		PROC
		ProcCrimeSetCustomSecondarySensibleAction((CHARACTERGUID)_Character,(STRING)_CrimeName,(STRING)_)
		THEN
		DB_CrimeReaction_CustomSensibleAction(_Character,_CrimeName,0);
		
		PROC
		ProcCrimeSetCustomSecondarySensibleAction((CHARACTERGUID)_Character,(STRING)_CrimeName,(STRING)_CustomReactionName)
		AND
		_CustomReactionName == ""
		THEN
		ProcCrimeSetCustomSensibleActionVariable(_Character,_CrimeName,"CRIME_UndefinedSensibleAction","Secondary_");
		
		PROC
		ProcCrimeSetCustomSecondarySensibleAction((CHARACTERGUID)_Character,(STRING)_CrimeName,(STRING)_CustomReactionName)
		AND
		_CustomReactionName != ""
		THEN
		ProcCrimeSetCustomSensibleActionVariable(_Character,_CrimeName,_CustomReactionName,"Secondary_");
		
		PROC
		ProcCrimeSetCustomSensibleActionVariable((CHARACTERGUID)_Character,(STRING)_CrimeName,(STRING)_CustomReactionName,(STRING)_Type)
		AND
		StringConcatenate("Custom",_Type,_Prefix)
		AND
		StringConcatenate(_Prefix,_CrimeName,_VarName)
		THEN
		SetVarFixedString(_Character,_VarName,_CustomReactionName);
		
		
		// --- Clearing
		PROC
		ProcCrimeClearCustomPrimarySensibleAction((CHARACTERGUID)_Character,(STRING)_CrimeName)
		AND
		StringConcatenate("CustomPrimary_",_CrimeName,_VarName)
		THEN
		SetVarFixedString(_Character,_VarName,"");
		
		PROC
		ProcCrimeClearCustomPrimarySensibleAction((CHARACTERGUID)_Character,(STRING)_CrimeName)
		AND
		DB_CrimeReaction_CustomSensibleAction(_Character,_CrimeName,1)
		THEN
		NOT DB_CrimeReaction_CustomSensibleAction(_Character,_CrimeName,1);
		
		PROC
		ProcCrimeClearCustomSecondarySensibleAction((CHARACTERGUID)_Character,(STRING)_CrimeName)
		AND
		StringConcatenate("CustomSecondary_",_CrimeName,_VarName)
		THEN
		SetVarFixedString(_Character,_VarName,"");
		
		PROC
		ProcCrimeClearCustomSecondarySensibleAction((CHARACTERGUID)_Character,(STRING)_CrimeName)
		AND
		DB_CrimeReaction_CustomSensibleAction(_Character,_CrimeName,0)
		THEN
		NOT DB_CrimeReaction_CustomSensibleAction(_Character,_CrimeName,0);
		
		PROC
		ProcCrimeClearAllCustomSensibleAction((CHARACTERGUID)_Character,(STRING)_CrimeName)
		AND
		StringConcatenate("CustomPrimary_",_CrimeName,_PrimaryVarName)
		AND
		StringConcatenate("CustomSecondary_",_CrimeName,_SecondaryVarName)
		THEN
		SetVarFixedString(_Character,_PrimaryVarName,"");
		SetVarFixedString(_Character,_SecondaryVarName,"");
		
		PROC
		ProcCrimeClearAllCustomSensibleAction((CHARACTERGUID)_Character,(STRING)_CrimeName)
		AND
		DB_CrimeReaction_CustomSensibleAction(_Character,_CrimeName,_Type)
		THEN
		NOT DB_CrimeReaction_CustomSensibleAction(_Character,_CrimeName,_Type);
		
		
		// --- Throwing a proc to allow reacting in story
		IF
		CharacterOnCrimeSensibleActionNotification(_NPC,_Region,_CrimeID,_PriorityName,_Dialog,_Criminal,_Criminal2,_Criminal3,_Criminal4,_IsPrimary)
		AND
		CrimeGetType(_CrimeID,_CrimeName)
		AND
		DB_CrimeReaction_CustomSensibleAction(_NPC,_CrimeName,_IsPrimary)
		THEN
		ProcCrimeOnCustomSensibleAction(_NPC,_Region,_CrimeID,_PriorityName,_Dialog,_Criminal,_Criminal2,_Criminal3,_Criminal4,_IsPrimary);
		
		PROC
		ProcCrimeOnCustomSensibleAction((CHARACTERGUID)_NPC, (STRING)_RegionID, (INTEGER)_CrimeID, (STRING)_PriorityName, (STRING)_PrimaryDialog, (CHARACTERGUID)_Criminal1, (CHARACTERGUID)_Criminal2, (CHARACTERGUID)_Criminal3, (CHARACTERGUID)_Criminal4, (INTEGER)_IsPrimary)
		THEN
		DB_NOOP(1);
		
		/**
		 * IMPORTANT! Call this event on the NPC who's reacting to the crime:
		
		SetStoryEvent(_NPC,"Crime_CustomSensibleActionDone");
		
		 */
		//END_REGION
		
		//REGION Override investigation
		
		/* Put your character in this fact to disable the interractive interrogation dialog:
			DB_CrimeReaction_DoNotInterrogate(_Interrogator)
		*/
		
		IF
		DB_CrimeReaction_DoNotInterrogate((CHARACTERGUID)_Char)
		THEN
		DB_Crime_CheckInterrogate(_Char);
		CrimeEnableInterrogation(_Char,0);
		
		IF
		DB_Crime_CheckInterrogate(_Char)
		AND
		NOT DB_CrimeReaction_DoNotInterrogate(_Char)
		THEN
		NOT DB_Crime_CheckInterrogate(_Char);
		CrimeEnableInterrogation(_Char,1);
		
		PROC
		ProcCrimeSetCustomInvestigationAD((CHARACTERGUID)_Character,(STRING)_Dialog)
		THEN
		SetVarString(_Character,"CRIME_InvestigateAD",_Dialog);
		
		
		//END_REGION
		
		//REGION Linked crimes
		PROC
		ProcCharacterDisableCrime((CHARACTERGUID)_Char,_Crime)
		AND
		DB_LinkedCrimes(_Crime,_LinkedCrime)
		THEN
		DB_CharacterCrimeDisabled(_Char,_LinkedCrime);
		CharacterDisableCrime(_Char,_LinkedCrime);
		
		PROC
		ProcCharacterEnableCrime((CHARACTERGUID)_Char,_Crime)
		AND
		DB_LinkedCrimes(_Crime,_LinkedCrime)
		THEN
		DB_CharacterCrimeEnabled(_Char,_LinkedCrime);
		CharacterEnableCrime(_Char,_LinkedCrime);
		
		IF
		DB_CrimeAttitudeChange("Assault",_Amount)
		THEN
		DB_CrimeAttitudeChange("IncapacitatedAssault",_Amount);
		
		//END_REGION
		
		
		//REGION Zero-tension crimes without fleeing
		// Zero-tension crimes that don't cause people to flee explicitly should not cause people to
		// return to their starting position at the end (DOSTWO-24283)
		IF
		CharacterOnCrimeSensibleActionNotification(_Char,_,_ID,_Reaction,_,_,_,_,_,_)
		AND
		DB_CRIME_FleeReaction(_Rection)
		AND
		CrimeGetTension(_ID,0)
		THEN
		DB_CRIME_ZeroTensionFlee(_ID,_Char);
		
		IF
		OnCrimeConfrontationDone(_ID,_Investigator,_,_,_,_,_)
		AND
		CrimeGetTension(_ID,0)
		AND
		NOT DB_CRIME_ZeroTensionFlee(_ID,_Investigator)
		THEN
		SetStoryEvent(_Investigator,"ClearCrimeReturnPos");
		
		IF
		OnCrimeConfrontationDone(_ID,_Investigator,_,_,_,_,_)
		THEN
		NOT DB_CRIME_ZeroTensionFlee(_ID,_Investigator);
		//END_REGION
		
	}
	EXIT
	{
		
	}
}
Goal(16).Title("_CRIME_ItemOwnership");
Goal(16)
{
	INIT
	{
		DB_ItemOwnerShipIgnoreTemplates("LTS_Campfire_A_6fee7bbb-4adc-4222-a5b1-82fcfb8d1230");
		DB_ItemOwnerShipIgnoreTemplates("LTS_Campfire_B_130692f2-a065-4168-be66-27cf4df2fff0");
		DB_ItemOwnerShipIgnoreTemplates("LTS_Campfire_C_1086cce2-9164-4746-b3c3-2f8c943cb8fc");
		DB_ItemOwnerShipIgnoreTemplates("FUR_Humans_Camping_Sleepingbag_A_d76d0118-23cd-42af-b693-449c96c71d6d");
		DB_ItemOwnerShipIgnoreTemplates("FUR_Humans_Citz_Mattress_A_DarkBrown_eae64571-4e99-4036-b3e2-1dcc6da78c89");
		DB_ItemOwnerShipIgnoreTemplates("LTS_Candle_A_f21393ff-31bc-46ff-a024-985e72cd83f5");
		DB_ItemOwnerShipIgnoreTemplates("LTS_Candle_B_d5e83188-69f5-428f-8bca-64f00b441aef");
		DB_ItemOwnerShipIgnoreTemplates("LTS_Candle_C_b98b4f53-5cf3-46b1-8ecd-278f178a9816");
		DB_ItemOwnerShipIgnoreTemplates("LTS_Candle_D_511c5c17-2ed0-4b2e-a4b5-425621cb61ac");
		DB_ItemOwnerShipIgnoreTemplates("LTS_Candle_E_f497d3af-8837-4183-9bf4-aef2ef1145d1");
		DB_ItemOwnerShipIgnoreTemplates("LTS_Candle_F_0121d78b-8831-4607-9c2f-db63edcdfbb6");
		DB_ItemOwnerShipIgnoreTemplates("LTS_Candle_G_83e373a2-ca7b-4c35-8761-d04605aaabca");
		DB_ItemOwnerShipIgnoreTemplates("LTS_Candle_H_49acf8f4-946e-4f62-a12e-e85d332f3d96");
		DB_ItemOwnerShipIgnoreTemplates("LTS_Candle_I_728b84a6-3929-48eb-9368-631a0614e38d");
		DB_ItemOwnerShipIgnoreTemplates("LTS_Candle_J_b8b63ed1-7c28-4c68-90b2-e83db433467b");
		DB_ItemOwnerShipIgnoreTemplates("LTS_Candle_K_ef4d1dd9-8d2a-4677-98c3-bb9dd52c0865");
		DB_ItemOwnerShipIgnoreTemplates("BOOK_ARX_Letter_B_ShadyTraderAd_cb5bd6ad-ae01-4ba9-bd95-752f9d659316");
		
	}
	KB
	{
		PROC
		PROC_Init_SetItemOwners((STRING)_Region)
		AND
		DB_ItemOwnerShipTriggers(_Region,_Trigger,_Owner)
		THEN
		TriggerSetItemOwner(_Trigger,_Owner);
		ProcTriggerRegisterForPlayers(_Trigger);
		NOT DB_ItemOwnerShipTriggers(_Region,_Trigger,_Owner);
		DB_TempItemOwnerShipTrigger(_Region,_Trigger);
		DB_OwnershipTrigger(_Trigger);
		
		PROC
		PROC_Init_ClearItemOwners((STRING)_Region)
		AND
		DB_ItemOwnerShipClearItem(_Region,_Item)
		THEN
		ItemClearOwner(_Item);
		NOT DB_ItemOwnerShipClearItem(_Region,_Item);
		
		PROC
		PROC_Init_ClearItemOwners((STRING)_Region)
		AND
		DB_TempItemOwnerShipTrigger((STRING)_Region,(TRIGGERGUID)_Trigger)
		AND
		DB_ItemOwnerShipIgnoreTemplates(_Temp)
		THEN
		NOT DB_TempItemOwnerShipTrigger(_Region,_Trigger);
		TriggerClearItemTemplateOwners(_Trigger,_Temp);
		
		IF
		DB_ItemOwnerShipTriggers(_Region,_Trigger,_Owner)
		AND
		DB_CurrentLevel(_Region)
		THEN
		PROC_Init_SetItemOwners(_Region);
		PROC_Init_ClearItemOwners(_Region);
		
		IF
		RegionStarted(_Region)
		THEN
		PROC_Init_SetItemOwners(_Region);
		PROC_Init_ClearItemOwners(_Region);
		
	}
	EXIT
	{
		
	}
}
Goal(17).Title("_CRIME_Prison");
Goal(17)
{
	INIT
	{
		//Setting up Flags for the Arrest Dialogs
		DB_ArrestDialogFlags("Assault","GEB_Arrest_Assault");
		DB_ArrestDialogFlags("SpiritTalk","GEB_Arrest_Source");
		DB_ArrestDialogFlags("SourceMagic","GEB_Arrest_Source");
		DB_ArrestDialogFlags("Steal","GEB_Arrest_Theft");
		DB_ArrestDialogFlags("PickPocketFailed","GEB_Arrest_Theft");
		DB_ArrestDialogFlags("PickPocket","GEB_Arrest_Theft");
		DB_ArrestDialogFlags("ItemDestroy","GEB_Arrest_Vandalise");
		DB_ArrestDialogFlags("Vandalise","GEB_Arrest_Vandalise");
		DB_ArrestDialogFlags("VandaliseNoOwner","GEB_Arrest_Vandalise");
		DB_ArrestDialogFlags("Trespassing","GEB_Arrest_Trespassing");
		DB_ArrestDialogFlags("UseForbiddenItem","GEB_Arrest_UseForbiddenItem");
		DB_ArrestDialogFlags("SneakUseForbiddenItem","GEB_Arrest_UseForbiddenItem");
		
		DB_ReactOutOfRegion("RED PRINCE");
		DB_ReactOutOfRegion("IFAN");
		DB_ReactOutOfRegion("LOHSE");
		DB_ReactOutOfRegion("SEBILLE");
		DB_ReactOutOfRegion("BEAST");
		DB_ReactOutOfRegion("FANE");
		DB_ReactOutOfRegion("AGGRESSIVEANIMAL");
		
	}
	KB
	{
		IF
		DB_RegionPrison(_RegionName,(TRIGGERGUID)_PrisonTrigger)
		THEN
		ProcTriggerRegisterForPlayers(_PrisonTrigger);
		
		QRY
		QryNPCIsGuard((GUIDSTRING)_NPC)
		AND
		IsTagged(_Npc,"GUARD",1)
		THEN
		DB_Noop(1);
		
		QRY
		QryNPCIsGuard((GUIDSTRING)_NPC)
		AND
		IsTagged(_Npc,"PALADIN",1)
		THEN
		DB_Noop(1);
		
		QRY
		QryNPCIsGuard((GUIDSTRING)_NPC)
		AND
		IsTagged(_Npc,"MAGISTER",1)
		THEN
		DB_Noop(1);
		
		//REGION Start Arrest 
		//Wait for dialog to end to arrest Player // Needs to be removed
		IF
		ObjectFlagSet("Start_Arrest_AfterDialog",(CHARACTERGUID)_Character,_ID)
		THEN
		ObjectClearFlag(_Character,"Start_Arrest_AfterDialog",0);
		DB_ArrestAfterDialog(_Character,_ID);
		
		
		///////// Handle Evidence ////////////
		IF
		ObjectFlagSet("Allow_Arrest",(CHARACTERGUID)_Player,_ID)
		THEN
		DB_ArrestDialog(_Player,_ID);
		
		IF
		DialogEnded(_,_ID)
		AND
		DB_ArrestDialog(_Player,_ID)
		AND
		DB_DialogNPCs(_ID,_NPC,1)
		AND
		ObjectGetFlag((CHARACTERGUID)_NPC,"CRIME_FoundEvidenceCurrentCrime",1)
		AND
		DB_Interrogation(_NPC,_CrimeID)
		THEN
		ProcCrimeHandleEvidence(_Player,_NPC,_CrimeID);
		
		PROC
		ProcCrimeHandleEvidence((CHARACTERGUID)_Player,(CHARACTERGUID)_Arrester,(INTEGER)_CrimeID)
		AND
		CharacterGetCrimeRegion(_Player,_CrimeRegionID)
		AND
		DB_RegionPrison(_CrimeRegionID,_PrisonTrigger)
		AND
		DB_PrisonEvidenceChest((TRIGGERGUID)_PrisonTrigger,(ITEMGUID)_EvidenceChest)
		THEN
		CrimeTransferEvidenceTo(_CrimeID,_EvidenceChest);
		
		PROC
		ProcCrimeHandleEvidence((CHARACTERGUID)_Player,(CHARACTERGUID)_Arrester,(INTEGER)_CrimeID)
		AND
		CharacterGetCrimeRegion(_Player,_CrimeRegionID)
		AND
		DB_RegionPrison(_CrimeRegionID,_PrisonTrigger)
		AND
		NOT DB_PrisonEvidenceChest((TRIGGERGUID)_PrisonTrigger,_)
		THEN
		CrimeTransferEvidenceTo(_CrimeID,_Arrester);
		
		
		///////// Start Arrest ////////////
		IF
		DialogEnded(_,_ID)
		AND
		DB_ArrestAfterDialog(_Character,_ID)
		THEN
		NOT DB_ArrestAfterDialog(_Character,_ID);
		ProcCrimeStartArrest((CHARACTERGUID)_Character,_ID);
		
		PROC
		ProcCrimeStartArrest((CHARACTERGUID)_Character,(INTEGER)_ID)
		AND
		CharacterGetCrimeRegion(_Character,_CrimeRegion)
		THEN
		ProcCrimeDoPerformArrest(_ID,_CrimeRegion);
		
		PROC
		ProcCrimeDoPerformArrest((INTEGER)_Inst,(STRING)_Region)
		AND
		DB_DialogNPCs(_Inst,_Player,_)
		AND
		CharacterIsPlayer((CHARACTERGUID)_Player,1)
		THEN
		ProcCrimePerformArrest(_Player,_Region);
		
		PROC
		ProcCrimeDoPerformArrest((INTEGER)_Inst,(STRING)_Region)
		AND
		DB_DialogPlayers(_Inst,_Player,_)
		AND
		CharacterIsPlayer((CHARACTERGUID)_Player,1)
		THEN
		ProcCrimePerformArrest(_Player,_Region);
		
		PROC
		ProcCrimePerformArrest((CHARACTERGUID)_Character,(STRING)_CrimeRegionID)
		AND
		DB_RegionPrison(_CrimeRegionID,_PrisonTrigger)
		THEN
		ProcCrimeTeleportCharacterToPrison(_Character,_PrisonTrigger);
		
		PROC //--- can be used outside of the Crime System
		ProcCrimeTeleportCharacterToPrison((CHARACTERGUID)_Character,(TRIGGERGUID)_PrisonTrigger)
		THEN
		ObjectSetFlag(_Character,"IsInPrison");
		RemoveStatus(_Character,"FUGITIVE");
		CharacterDetachFromGroup(_Character);
		Proc_TeleportSmoke(_Character);
		TeleportTo(_Character,_PrisonTrigger,"",0);
		Proc_TeleportSmoke(_Character);
		DB_IsArrested(_Character);
		CharacterFlushQueue(_Character);
		LeaveCombat(_Character);
		CharacterRemoveTension(_Character);
		
		PROC
		ProcCrimeTeleportCharacterToPrison((CHARACTERGUID)_Character,(TRIGGERGUID)_PrisonTrigger)
		AND
		DB_PrisonChest((TRIGGERGUID)_PrisonTrigger,(ITEMGUID)_PrisonChest)
		THEN
		MoveAllItemsTo(_Character,_PrisonChest,0,1,1);
		
		//END_REGION
		
		//REGION Arrest dialog starting 
		
		IF
		CharacterOnCrimeSensibleActionNotification(_Arrester,_,_CrimeID,"CRIME_Arrest",_,_,_,_,_,_)
		AND
		CrimeGetType(_CrimeID,_CrimeName)
		AND
		NOT DB_CrimeReaction_CustomSensibleAction(_Arrester,_CrimeName)
		THEN
		Proc_StartArrestDialog(_Arrester);
		
		IF
		StoryEvent(_Arrester,"ArrestOnRequest")
		THEN
		SetVarString(_Arrester,"ArrestDialog","GEB_Arrest");
		Proc_StartArrestDialog((CHARACTERGUID)_Arrester);
		
		IF
		StoryEvent((CHARACTERGUID)_Arrester, "CRIME_Perform_Arrest")
		AND
		GetVarInteger(_Arrester,"CrimeID",_CrimeID)
		THEN
		ProcStartArrest(_Arrester,_CrimeID);
		
		PROC
		ProcStartArrest((CHARACTERGUID)_Arrester,(INTEGER)_CrimeID)
		AND
		GetVarObject(_Arrester,"Criminal1",_Criminal1)
		AND
		GetVarObject(_Arrester,"Criminal2",_Criminal2)
		AND
		GetVarObject(_Arrester,"Criminal3",_Criminal3)
		AND
		GetVarObject(_Arrester,"Criminal4",_Criminal4)
		AND
		GetVarString(_Arrester,"ArrestDialog",_ArrestDialog)
		THEN
		DB_Arresting(_Arrester,_CrimeID,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,_ArrestDialog);
		SetHasDialog(_Arrester,0);
		CharacterDisableAllCrimes(_Arrester);
		DialogRequestStop(_Arrester);
		
		IF
		DialogEnded(_,_Instance)
		AND
		DB_DialogPlayers(_Instance,_Criminal,1)
		AND
		DB_Arresting(_Arrester,_CrimeID,(CHARACTERGUID)_Criminal,_,_,_,_ArrestDialog)
		THEN
		CharacterMoveToAndTalk(_Arrester,_Criminal,"",0,"GEB_ArrestMove",1,10.0);
		
		PROC
		ProcStartArrest((CHARACTERGUID)_Arrester,(INTEGER)_CrimeID)
		AND
		NOT DB_Arresting(_Arrester,_CrimeID,_,_,_,_,_)
		THEN
		CrimeConfrontationDone(_CrimeID,_Arrester);
		
		PROC
		ProcCleanupArrest((CHARACTERGUID)_Arrester)
		AND
		DB_Arresting(_Arrester,_CrimeID,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_ArrestDialog)
		THEN
		ProcRestoreFightMode(_Arrester);
		ProcRestoreGenericBehaviour(_Arrester);
		SetHasDialog(_Arrester,1);
		NOT DB_Arresting(_Arrester,_CrimeID,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_ArrestDialog);
		SetStoryEvent(_Arrester,"CRIME_StartArrest");
		
		IF
		CharacterMoveToAndTalkRequestDialog(_Arrester,(CHARACTERGUID)_Criminal,_,_,"GEB_ArrestMove")
		AND
		DB_Arresting(_Arrester,_CrimeID,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_ArrestDialog)
		THEN
		SetStoryEvent(_Arrester,"CRIME_StartArrest");
		Proc_StartArrestDialog(_Arrester,_CrimeID,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_ArrestDialog);
		
		IF
		CharacterMoveToAndTalkFailed(_Arrester,_,"GEB_ArrestMove")
		AND
		DB_Arresting(_Arrester,_CrimeID,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_ArrestDialog)
		THEN
		CrimeConfrontationDone(_CrimeID,_Arrester);
		ProcCleanupArrest(_Arrester);
		
		IF
		DB_Crime_FailedToInterruptStoryDialogs(_CrimeID,_ArrestDialog,_Arrester,_Criminal,_Criminal2,_Criminal3,_Criminal4)
		AND
		DB_Arresting(_Arrester,_CrimeID,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_ArrestDialog)
		THEN
		CharacterMoveToAndTalkRequestDialogFailed(_Arrester,_Criminal,"GEB_ArrestMove");
		
		IF
		ObjectFlagSet(_ActiveFlag,(CHARACTERGUID)_Arrester,_)
		AND
		DB_ArrestDialogFlags(_CrimeName,_ActiveFlag)
		AND
		DB_Arresting(_Arrester,_CrimeID,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_ArrestDialog)
		THEN
		ProcCleanupArrest(_Arrester);
		
		IF
		ObjectEnteredCombat((CHARACTERGUID)_Arrester,_)
		AND
		DB_Arresting(_Arrester,_,_,_,_,_,_)
		THEN
		ProcCleanupArrest(_Arrester);
		
		PROC 
		Proc_StartArrestDialog((CHARACTERGUID)_Arrester)
		AND
		GetVarObject(_Arrester,"Criminal1",(CHARACTERGUID)_Criminal1)
		AND
		GetVarObject(_Arrester,"Criminal2",(CHARACTERGUID)_Criminal2)
		AND
		GetVarObject(_Arrester,"Criminal3",(CHARACTERGUID)_Criminal3)
		AND
		GetVarObject(_Arrester,"Criminal4",(CHARACTERGUID)_Criminal4)
		AND
		GetVarInteger(_Arrester,"CrimeID",_CrimeID)
		AND
		GetVarString(_Arrester,"ArrestDialog",_ArrestDialog)
		THEN
		Proc_StartArrestDialog(_Arrester,_CrimeID,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_ArrestDialog);
		
		PROC 
		Proc_StartArrestDialog((CHARACTERGUID)_Arrester,(INTEGER)_CrimeID,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_ArrestDialog)
		THEN
		ObjectClearFlag(_Arrester,"GEB_Arrest_HavePrison",0);
		
		PROC
		Proc_StartArrestDialog((CHARACTERGUID)_Arrester,(INTEGER)_CrimeID,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_ArrestDialog)
		AND
		DB_ArrestDialogFlags(_CrimeName,_ActiveFlag)
		AND
		ObjectGetFlag(_Arrester,_ActiveFlag,1)
		THEN
		ObjectClearFlag(_Arrester,_ActiveFlag,0);
		
		PROC 
		Proc_StartArrestDialog((CHARACTERGUID)_Arrester,(INTEGER)_CrimeID,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_ArrestDialog)
		AND
		CrimeGetType(_CrimeID,_CrimeName)
		AND
		DB_ArrestDialogFlags(_CrimeName,_ActiveFlag)
		THEN
		ObjectSetFlag(_Arrester,_ActiveFlag);
		
		
		//--- Setup the Arrester's script
		PROC 
		Proc_StartArrestDialog((CHARACTERGUID)_Arrester,(INTEGER)_CrimeID,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_ArrestDialog)
		AND
		GetVarFixedString(_Arrester,"RegionID",_RegionID)
		AND
		CrimeGetType(_CrimeID,_CrimeType)
		THEN
		ProcCrimeSetupCountFlag(_CrimeID,_Arrester,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_CrimeType,_ArrestDialog);
		ProcCrimeStartRegionArrestInterrogation(_RegionID,_CrimeID,_ArrestDialog,_Arrester,_Criminal1,_Criminal2,_Criminal3,_Criminal4);
		
		PROC
		ProcCheckStartArrestInterrogation((INTEGER)_CrimeID,(STRING)_ArrestDialog,(CHARACTERGUID)_Arrester,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		NOT DB_Crime_FailedToInterruptStoryDialogs(_CrimeID,_ArrestDialog,_Arrester,_Criminal,_Criminal2,_Criminal3,_Criminal4)
		THEN
		ProcCrimeStartArrestInterrogation(_CrimeID,_Arrester,_Criminal,_Criminal2,_Criminal3,_Criminal4,1);
		
		PROC
		ProcCheckStartArrestInterrogation((INTEGER)_CrimeID,(STRING)_ArrestDialog,(CHARACTERGUID)_Arrester,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		DB_Crime_FailedToInterruptStoryDialogs(_CrimeID,_ArrestDialog,_Arrester,_Criminal,_Criminal2,_Criminal3,_Criminal4)
		THEN
		ProcCrimeStartArrestInterrogation(_CrimeID,_Arrester,_Criminal,_Criminal2,_Criminal3,_Criminal4,0);
		NOT DB_Crime_FailedToInterruptStoryDialogs(_CrimeID,_ArrestDialog,_Arrester,_Criminal,_Criminal2,_Criminal3,_Criminal4);
		
		PROC
		ProcCrimeStartRegionArrestInterrogation((STRING)_RegionID,(INTEGER)_CrimeID,(STRING)_ArrestDialog,(CHARACTERGUID)_Arrester,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		DB_RegionPrison(_RegionID,_)
		THEN
		ObjectSetFlag(_Arrester,"GEB_Arrest_HavePrison");
		
		PROC
		ProcCrimeStartRegionArrestInterrogation((STRING)_RegionID,(INTEGER)_CrimeID,(STRING)_ArrestDialog,(CHARACTERGUID)_Arrester,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		_RegionID != ""
		THEN
		ProcCrimeInterruptStoryDialogs(_CrimeID,_ArrestDialog,1,_Arrester,_Criminal,_Criminal2,_Criminal3,_Criminal4);
		ProcCheckStartArrestInterrogation(_CrimeID,_ArrestDialog,_Arrester,_Criminal,_Criminal2,_Criminal3,_Criminal4);
		
		PROC
		ProcCrimeStartRegionArrestInterrogation((STRING)_RegionID,(INTEGER)_CrimeID,(STRING)_ArrestDialog,(CHARACTERGUID)_Arrester,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		_RegionID == ""
		AND
		DB_ReactOutOfRegion(_Tag)
		AND
		IsTagged(_Arrester,_Tag,1)
		AND
		NOT DB_ReactingCharOutOfRegion(_Arrester,_)
		THEN
		ProcCrimeInterruptStoryDialogs(_CrimeID,_ArrestDialog,1,_Arrester,_Criminal,_Criminal2,_Criminal3,_Criminal4);
		ProcCheckStartArrestInterrogation(_CrimeID,_ArrestDialog,_Arrester,_Criminal,_Criminal2,_Criminal3,_Criminal4);
		DB_ReactingCharOutOfRegion(_Arrester,_Tag);
		
		
		// We change crime dialog in the next section, so replace it in the DB which is used to clean some stuff on crime end
		PROC
		ProcCrimeStartRegionArrestInterrogation((STRING)_RegionID,(INTEGER)_CrimeID,(STRING)_ArrestDialog,(CHARACTERGUID)_Arrester,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		_RegionID == ""
		AND
		NOT DB_ReactingCharOutOfRegion(_Arrester,_)
		THEN
		ProcCrimeStartRegionArrestInterrogation_SubActions(_RegionID,_CrimeID,_ArrestDialog,_Arrester,_Criminal,_Criminal2,_Criminal3,_Criminal4);
		
		PROC
		ProcCrimeStartRegionArrestInterrogation_SubActions((STRING)_RegionID,(INTEGER)_CrimeID,(STRING)_ArrestDialog,(CHARACTERGUID)_Arrester,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		DB_Crime_RequestedDialogWithTension(_CrimeName,_ArrestDialog,_Arrester,_Criminal,_Criminal2,_Criminal3,_Criminal4)
		THEN
		NOT DB_Crime_RequestedDialogWithTension(_CrimeName,_ArrestDialog,_Arrester,_Criminal,_Criminal2,_Criminal3,_Criminal4);
		DB_Crime_RequestedDialogWithTension(_CrimeName,"GEB_Attack",_Arrester,_Criminal,_Criminal2,_Criminal3,_Criminal4);
		
		PROC
		ProcCrimeStartRegionArrestInterrogation_SubActions((STRING)_RegionID,(INTEGER)_CrimeID,(STRING)_ArrestDialog,(CHARACTERGUID)_Arrester,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		THEN
		ProcCrimeInterruptStoryDialogs(_CrimeID,"GEB_Attack",1,_Arrester,_Criminal,_Criminal2,_Criminal3,_Criminal4);
		ProcCheckStartArrestInterrogation(_CrimeID,"GEB_Attack",_Arrester,_Criminal,_Criminal2,_Criminal3,_Criminal4);
		
		PROC
		ProcCrimeStartRegionArrestInterrogation((STRING)_RegionID,(INTEGER)_CrimeID,(STRING)_ArrestDialog,(CHARACTERGUID)_Arrester,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		DB_ReactingCharOutOfRegion(_Arrester,_Tag)
		THEN
		NOT DB_ReactingCharOutOfRegion(_Arrester,_Tag);
		
		PROC 
		ProcCrimeStartArrestInterrogation((INTEGER)_CrimeID,(CHARACTERGUID)_Arrester,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,_)
		AND
		DB_EvidenceFound(_CrimeID,_Interrogator)
		AND
		DB_Crime_CallingGuards(_Interrogator,_Criminal,_ID)
		THEN
		NOT DB_Crime_CallingGuards(_Interrogator,_Criminal,_ID);
		NOT DB_EvidenceFound(_CrimeID,_Interrogator);
		DB_EvidenceFound(_CrimeID,_Arrester);
		
		PROC 
		ProcCrimeStartArrestInterrogation((INTEGER)_CrimeID,(CHARACTERGUID)_Arrester,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,1)
		AND
		DB_EvidenceFound(_CrimeID,_Interrogator)
		AND
		DB_Crime_CallingGuards(_Interrogator,_Criminal,_ID)
		THEN
		DB_StopInterrogationAfterDialog(_CrimeID,_Arrester,_Criminal,_Criminal2,_Criminal3,_Criminal4);
		
		PROC 
		ProcCrimeStartArrestInterrogation((INTEGER)_CrimeID,(CHARACTERGUID)_Arrester,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,0)
		AND
		DB_Crime_Interrogation(_CrimeID,_,_,_,_,_,_)
		THEN
		ProcStopInterrogation(_CrimeID,_Arrester,_Criminal,_Criminal2,_Criminal3,_Criminal4);
		
		IF
		DialogEnded(_,_Instance)
		AND
		DB_DialogPlayers(_Instance,_Player,1)
		AND
		DB_DialogNPCs(_Instance,_NPC,1)
		AND
		ObjectGetFlag(_Player,"Resist_Arrest",1)
		AND
		DB_DialogPlayers(_Instance,_Players,_)
		THEN
		ObjectClearFlag(_Player,"Resist_Arrest",0);
		proc_CriminalMakeHostileAfterDialog((CHARACTERGUID)_Players,(CHARACTERGUID)_NPC);
		
		PROC
		proc_CriminalMakeHostileAfterDialog((CHARACTERGUID)_Player,(CHARACTERGUID)_NPC)
		AND
		_Player != NULL_00000000-0000-0000-0000-000000000000
		THEN
		ProcMakeNPCHostile((CHARACTERGUID)_Player,(CHARACTERGUID)_NPC);
		
		IF
		DialogEnded(_,_Instance)
		AND
		DB_ArrestDialog(_Player,_Instance)
		THEN
		ObjectClearFlag(_Player,"Allow_Arrest",0);
		NOT DB_ArrestDialog(_Player,_Instance);
		ProcCrimeStartArrest((CHARACTERGUID)_Player,_Instance);
		
		IF
		DialogEnded(_,_Instance)
		AND
		DB_DialogNPCs(_Instance,_NPC,1)
		AND
		DB_StopInterrogationAfterDialog(_CrimeID,(CHARACTERGUID)_NPC,_Criminal,_Criminal2,_Criminal3,_Criminal4)
		THEN
		ProcStopInterrogation(_CrimeID,_NPC,_Criminal,_Criminal2,_Criminal3,_Criminal4);
		NOT DB_StopInterrogationAfterDialog(_CrimeID,_NPC,_Criminal,_Criminal2,_Criminal3,_Criminal4);
		
		// TODO Remove the DB_ReactingCharOutOfRegion(_Arrester,_Tag) On Tag Removed
		//END_REGION
		
		//REGION Arrest Play As AD 
		IF
		StoryEvent((CHARACTERGUID)_Arrester,"GLO_PlayArrestAsAD")
		AND
		GetVarString(_Arrester,"ArrestDialog",_ArrestDialog)
		THEN
		Proc_StartDialog(1,_ArrestDialog,_Arrester);
		//END_REGION
		
		//REGION Escape Prison
		IF
		CharacterEnteredTrigger(_Player,_PrisonTrigger)
		AND
		DB_IsArrested(_Player)
		AND
		DB_IsPlayer(_Player)
		AND
		DB_PlayerPrison_Door(_PrisonTrigger,(ITEMGUID)_CellDoor,(STRING)_KeyName)
		THEN
		ItemCloseAndLock(_CellDoor,_KeyName);
		
		IF
		CharacterLeftTrigger(_Player,_PrisonTrigger)
		AND
		DB_IsArrested(_Player)
		AND
		DB_IsPlayer(_Player)
		AND
		DB_PlayerPrison((TRIGGERGUID)_PrisonTrigger,(TRIGGERGUID)_CellDoorTrigger,(STRING)_PrisonCrimeName,(STRING)_PrisonCrimeNameAD)
		AND
		GetPosition(_CellDoorTrigger,_x,_y,_z)
		THEN
		//ProcRestoreGenericBehaviourAfterScene(_Player);
		DB_PlayerEscapedPrison(_Player,_PrisonCrimeName,_PrisonCrimeNameAD);
		ApplyStatus(_Player,"FUGITIVE",100.0,1);
		ObjectClearFlag(_Player,"IsInPrison",0);
		CharacterRegisterCrimeWithPosition(_Player,"EscapedPrison",NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,_x,_y,_z,0);
		NOT DB_IsArrested(_Player);
		
		IF
		CharacterStatusApplied(_Player,"FUGITIVE",_)
		AND
		DB_IsPlayer(_Player)
		AND
		DB_PlayerEscapedPrison(_Player,_PrisonCrimeName,_PrisonCrimeNameAD)
		THEN
		ObjectSetFlag(_Player,"IsFugitive"); // This is for Arrest_EscapedPrison Dialog
		CharacterRegisterCrime(_Player,_PrisonCrimeName,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,0);
		
		IF
		CharacterStatusApplied(_Player,"FUGITIVE",_)
		AND
		DB_IsPlayer(_Player)
		AND
		DB_PlayerEscapedPrison(_Player,_PrisonCrimeName,_PrisonCrimeNameAD)
		AND
		_PrisonCrimeNameAD != ""
		THEN
		CharacterRegisterCrime(_Player,_PrisonCrimeNameAD,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,0);
		
		IF
		CharacterStatusRemoved(_Player,"FUGITIVE",_)
		AND
		DB_IsPlayer(_Player)
		AND
		DB_PlayerEscapedPrison(_Player,_PrisonCrimeName,_PrisonCrimeNameAD)
		THEN
		NOT DB_PlayerEscapedPrison(_Player,_PrisonCrimeName,_PrisonCrimeNameAD);
		CharacterStopCrime(_Player,_PrisonCrimeName,NULL_00000000-0000-0000-0000-000000000000);
		CharacterStopCrime(_Player,_PrisonCrimeNameAD,NULL_00000000-0000-0000-0000-000000000000);
		ObjectClearFlag(_Player,"IsFugitive",0);
		
		IF
		ObjectFlagSet("GEB_ClearTag_FUGITIVE",_Player,_) //set in GEB_Arrest_EscapedPrison
		AND
		HasActiveStatus(_Player,"FUGITIVE",1)
		THEN
		RemoveStatus(_Player,"FUGITIVE");
		
		IF
		ObjectFlagSet("GEB_ClearTag_FUGITIVE",_Player,_ID) //set in GEB_Arrest_EscapedPrison
		AND
		DB_DialogNPCs(_ID,_NPC,1)
		THEN
		ProcCrimeBribedGuards(_NPC,_Player);
		
		PROC
		ProcCrimeBribedGuards((GUIDSTRING)_NPC,(GUIDSTRING)_Player)
		THEN
		CrimeIgnoreAllCrimesForCriminal(_Player,_NPC,300000);
		DB_CrimeBribeSource(_Player);
		CharacterLaunchIteratorAroundCharacter((CHARACTERGUID)_Player,20.0,"GEB_CrimeBribeGuards");
		FireOsirisEvents();
		NOT DB_CrimeBribeSource(_Player);
		
		IF
		StoryEvent((CHARACTERGUID)_NPC,"GEB_CrimeBribeGuards")
		AND
		NOT DB_CombatCharacters(_NPC,_)
		AND
		DB_CrimeBribeSource(_Player)
		AND
		NOT DB_Dead(_NPC)
		AND
		CharacterIsPlayer(_NPC,0)
		AND
		QryNPCIsGuard(_NPC)
		THEN
		CrimeIgnoreAllCrimesForCriminal(_Player,_NPC,300000);
		
		IF
		ObjectFlagSet("GEB_ClearTag_FUGITIVE",_Player,_) //set in GEB_Arrest_EscapedPrison
		THEN
		ObjectClearFlag(_Player,"GEB_ClearTag_FUGITIVE",0);
		
		//END_REGION
		
		//REGION GUARD CALLING
		IF
		ObjectFlagSet("GEB_Arrest_Player",_NPC,_Inst)
		AND
		DB_DialogNPCs(_Inst,_OldLead,1)
		THEN
		DB_CrimeArrestCallingGuards((CHARACTERGUID)_OldLead,_Inst);
		
		IF
		ObjectFlagSet("GEB_Arrest_Player",_NPC,_Inst)
		AND
		DB_DialogNPCs(_Inst,_OldLead,1)
		AND
		NOT DB_CombatCharacters((CHARACTERGUID)_NPC,_)
		AND
		NOT DB_PickedLeadToHelp(_,_Inst)
		AND
		GetVarInteger(_OldLead,"CrimeID",_CrimeID)
		AND
		CrimeTransferLeadershipTo((CHARACTERGUID)_OldLead,_CrimeID,_NPC,1)
		AND
		GetVarObject(_OldLead,"Criminal1",_Criminal1)
		AND
		GetVarObject(_OldLead,"Criminal2",_Criminal2)
		AND
		GetVarObject(_OldLead,"Criminal3",_Criminal3)
		AND
		GetVarObject(_OldLead,"Criminal4",_Criminal4)
		AND
		GetVarFixedString(_OldLead,"RegionID",_RegionID)
		THEN
		SetHasDialog(_OldLead,0);
		CharacterDisableAllCrimes(_OldLead);
		CharacterEnableCrime(_OldLead,"Assault");
		CharacterEnableCrime(_OldLead,"SummonAssault");
		CharacterEnableCrime(_OldLead,"IncapacitatedAssault");
		DB_GuardCaller(_CrimeID,_OldLead,_NPC);
		CharacterSetReactionPriority(_OldLead,"CRIME_Flee",2800);
		DB_PickedLeadToHelp(_NPC,_Inst);
		ProcStoreFightMode(_Npc);
		CharacterSetFightMode(_NPC,1,0);
		SetVarObject(_NPC,"Criminal1",_Criminal1); 
		SetVarObject(_NPC,"Criminal2",_Criminal2); 
		SetVarObject(_NPC,"Criminal3",_Criminal3); 
		SetVarObject(_NPC,"Criminal4",_Criminal4); 
		SetVarString(_NPC,"ArrestDialog","GEB_Arrest");
		SetVarFixedString(_NPC,"RegionID",_RegionID);
		SetVarInteger(_NPC,"CrimeID",_CrimeID);
		SetStoryEvent(_NPC,"CRIME_Perform_Arrest");
		
		IF
		DialogEnded(_Dialog,_Inst)
		AND
		DB_CrimeArrestCallingGuards(_OldLead,_Inst)
		AND
		NOT DB_PickedLeadToHelp(_,_Inst)
		AND
		DB_DialogPlayers(_Inst,_Player,1)
		THEN
		NOT DB_CrimeArrestCallingGuards(_OldLead,_Inst);
		//failed to transfer leadership, start combat as fallback
		Proc_StartDialog(1,"GEB_AD_DealWithCrime",_OldLead);
		CharacterSetTemporaryHostileRelation((CHARACTERGUID)_Player,_OldLead);
		
		IF
		DialogEnded(_Dialog,_Inst)
		AND
		DB_PickedLeadToHelp(_NPC,_Inst)
		AND
		DB_DialogNPCs(_Inst,_OldLead,1)
		THEN
		NOT DB_PickedLeadToHelp(_NPC,_Inst);
		NOT DB_CrimeArrestCallingGuards((CHARACTERGUID)_OldLead,_Inst);
		
		IF
		OnCrimeConfrontationDone(_CrimeID,_OldLead,_,_,_,_,_)
		AND
		DB_GuardCaller(_CrimeID,_OldLead,_NPC)
		THEN
		SetHasDialog(_OldLead,1);
		ProcRestoreGenericBehaviour(_OldLead);
		NOT DB_GuardCaller(_CrimeID,_OldLead,_NPC);
		
		
		
		//END_REGION
		
		
		//REGION Debug
		
		IF
		TextEventSet("LookatPrison")
		THEN
		CharacterLookAt(S_FTJ_PrisonGuardTest_0ad9aa6c-c8df-4591-be1a-d4f0a94d89ac,S_FortJoy_PlayerPrisonDoor_2dd80040-28aa-4445-8438-1e2424d7228f);
		
		IF
		TextEventSet("Lookatme")
		THEN
		CharacterLookAt(S_FTJ_PrisonGuardTest_0ad9aa6c-c8df-4591-be1a-d4f0a94d89ac,CHARACTERGUID_Player_Ifan_ad9a3327-4456-42a7-9bf4-7ad60cc9e54f);
		
		//END_REGION
		
	}
	EXIT
	{
		
	}
}
Goal(18).Title("_Global");
Goal(18)
{
	INIT
	{
		
	}
	KB
	{
		///////////////////////////////////////////////////////////////////////
		// Story call to forward the clock to _NewHour.
		// The clock will be advanced with max 24 hours. This happens when you call SetGameClock(_H) AND Time(_,_H,_).
		//
		// DO NOT USE THE ENGINE CALL SetTime DIRECTLY!
		//
		PROC	
		SetGameClock((INTEGER)_NewHour) 
		AND
		DB_Time(_Day,_H,_)
		AND 
		_NewHour > _H
		// day stays today
		THEN
		UpdateTime(_Day,_NewHour);
		
		PROC
		SetGameClock((INTEGER)_NewHour) 
		AND
		DB_Time(_Day,_H,_) 
		AND
		_NewHour <= _H 
		AND
		// day forwards +1
		IntegerSum(_Day,1,_DayP1)
		THEN	
		UpdateTime(_DayP1,_NewHour);
		
		PROC
		ProcDisableFollow((CHARACTERGUID)_Char)
		THEN
		CharacterDetachFromGroup(_Char);
		//CharacterLockGroup(_Char,1);
		
		IF
		CharacterUsedItemFailed(_Player,_Item)
		AND
		_Player.DB_IsPlayer()
		THEN
		ProcShowForbiddenItemText(_Player,_Item);
		
		PROC
		ProcShowForbiddenItemText((CHARACTERGUID)_Player,(ITEMGUID)_Item)
		AND
		ItemIsLocked(_Item, 0)
		AND
		NOT DB_NoForbiddenText(_Item)
		THEN
		Proc_StartDialog(1,"GLO_AD_ForbiddenItem",_Player);
		
		PROC
		ProcShowForbiddenItemText((CHARACTERGUID)_Player,(ITEMGUID)_Item)
		AND
		ItemIsLocked(_Item, 1)
		THEN
		CharacterItemSetEvent(_Player, _Item, "GLO_UsedLockedItem");
		
		PROC
		ProcShowMarker((CHARACTERGUID)_Player,(STRING)_Marker)
		AND
		NOT DB_ActivePlayerMarker(_Player,_Marker)
		THEN
		DB_ActivePlayerMarker(_Player,_Marker);
		ShowMapMarker(_Player,_Marker,1);
		
		PROC
		ProcHideMarker((CHARACTERGUID)_Player,(STRING)_Marker)
		AND
		DB_ActivePlayerMarker(_Player,_Marker)
		THEN
		ShowMapMarker(_Player,_Marker,0);
		
		PROC
		ProcFreezePlayers()
		AND
		_Player.DB_IsPlayer()
		THEN
		CharacterFreeze(_Player);
		
		PROC
		ProcUnfreezePlayers()
		AND
		_Player.DB_IsPlayer()
		THEN
		CharacterUnfreeze(_Player);
		
		//REGION moving items default functions 
		PROC
		MoveAllItemsTo((GUIDSTRING)_Source,(GUIDSTRING)_Target)
		THEN
		MoveAllItemsTo(_Source,_Target,1,1,1);
		//END_REGION
		
	}
	EXIT
	{
		
	}
}
Goal(19).Title("_Global_Autosave");
Goal(19)
{
	INIT
	{
		
	}
	KB
	{
		IF
		DB_AutoSaveTrigger((TRIGGERGUID)_Trigger)
		AND
		NOT DB_Subregion(_Trigger,_,_) //Subregions can function as autosaves the first time they are entered
		THEN
		DB_OneShotPlayerTrigger(_Trigger);
		
		//retro-active check, if a trigger is a sub-region, it should not be oneshot
		IF
		DB_Subregion(_Trigger,_,_)
		AND
		DB_OneShotPlayerTrigger(_Trigger)
		THEN
		NOT DB_OneShotPlayerTrigger(_Trigger);
		
		PROC
		ProcOneShotTriggerEntered(_,_Trigger)
		AND
		DB_AutoSaveTrigger(_Trigger)
		AND
		DB_AutosaveGroup(_Trigger,_Group)
		AND
		DB_AutosaveGroup(_AnotherTrigger,_Group)
		AND
		_AnotherTrigger != _Trigger
		THEN
		NOT DB_AutoSaveTrigger(_AnotherTrigger);
		NOT DB_OneShotPlayerTrigger(_AnotherTrigger);
		ProcTriggerUnregisterForPlayers(_AnotherTrigger);
		
		PROC
		ProcOneShotTriggerEntered(_,_Trigger)
		AND
		DB_AutoSaveTrigger(_Trigger)
		THEN
		NOT DB_AutoSaveTrigger(_Trigger);
		AutoSave();
		
		//For use of Autosave triggers that are attached to non-oneshots such as Subregions
		IF
		CharacterEnteredTrigger((CHARACTERGUID)_Player,(TRIGGERGUID)_Trigger)
		AND
		DB_AutoSaveTrigger(_Trigger)
		AND
		NOT DB_OneShotPlayerTrigger(_Trigger)
		THEN
		NOT DB_AutoSaveTrigger(_Trigger);
		AutoSave();
		
		IF
		DB_AutosaveGroup((TRIGGERGUID)_Trigger,(STRING)_ID)
		THEN
		DB_AutoSaveTrigger(_Trigger);
		
		
		
	}
	EXIT
	{
		
	}
}
Goal(20).Title("_Global_CharacterAnimations");
Goal(20)
{
	INIT
	{
		// Standard animations
		DB_GLO_CharacterAnimation("PlayAnim_attack1","attack1",0);
		DB_GLO_CharacterAnimation("PlayAnim_attack2","attack2",0);
		DB_GLO_CharacterAnimation("PlayAnim_attack3","attack3",0);
		DB_GLO_CharacterAnimation("PlayAnim_attack_ground","attack_ground",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_thrown_loop","thrown_loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_thrown_land","thrown_land",0);
		DB_GLO_CharacterAnimation("PlayAnim_knockdown_fall","knockdown_fall",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_knockdown_loop","knockdown_loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_knockdown_getup","knockdown_getup",0);
		DB_GLO_CharacterAnimation("PlayAnim_barf","barf",0);
		DB_GLO_CharacterAnimation("PlayAnim_die_melee","die_melee",0);
		DB_GLO_CharacterAnimation("PlayAnim_die_slash","die_slash",0);
		DB_GLO_CharacterAnimation("PlayAnim_die_crush","die_crush",0);
		DB_GLO_CharacterAnimation("PlayAnim_die_pierce","die_pierce",0);
		DB_GLO_CharacterAnimation("PlayAnim_die_arrow","die_arrow",0);
		DB_GLO_CharacterAnimation("PlayAnim_die_dot","die_dot",0);
		DB_GLO_CharacterAnimation("PlayAnim_die_incinerate","die_incinerate",0);
		DB_GLO_CharacterAnimation("PlayAnim_die_acid","die_acid",0);
		DB_GLO_CharacterAnimation("PlayAnim_die_electrocution","die_electrocution",0);
		DB_GLO_CharacterAnimation("PlayAnim_die_frozenshatter","die_frozenshatter",0);
		DB_GLO_CharacterAnimation("PlayAnim_die_hang","die_hang",0);
		DB_GLO_CharacterAnimation("PlayAnim_hit","hit",0);
		DB_GLO_CharacterAnimation("PlayAnim_hit_backstab","hit_backstab",0);
		DB_GLO_CharacterAnimation("PlayAnim_hit_magic","hit_magic",0);
		DB_GLO_CharacterAnimation("PlayAnim_block","block",0);
		DB_GLO_CharacterAnimation("PlayAnim_dodge","dodge",0);
		DB_GLO_CharacterAnimation("PlayAnim_dodge_backstab","dodge_backstab",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_idle1","idle1",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_idle2","idle2",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_idle3","idle3",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_walk","walk",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_sneak","sneak",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_run","run",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_still","still",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_stillsneaking","stillsneaking",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_stilldiseased","stilldiseased",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_stillchilled","stillchilled",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_stillcrippled","stillcrippled",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_stillblind","stillblind",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_stilldrunk","stilldrunk",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_stillelectrified","stillelectrified",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_walk_wings","walk_wings",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_run_wings","run_wings",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_still_wings","still_wings",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_stillmental","stillmental",1);
		
		DB_GLO_CharacterAnimation("PlayAnim_Loop_cower","cower",1);
		DB_GLO_CharacterAnimation("PlayAnim_spawn","spawn",0);
		DB_GLO_CharacterAnimation("PlayAnim_polymorphed","polymorphed",0);
		DB_GLO_CharacterAnimation("PlayAnim_resurrect","resurrect",0);
		DB_GLO_CharacterAnimation("PlayAnim_use_inspect","use_inspect",0);
		DB_GLO_CharacterAnimation("PlayAnim_use_activate","use_activate",0);
		DB_GLO_CharacterAnimation("PlayAnim_use_loot","use_loot",0);
		DB_GLO_CharacterAnimation("PlayAnim_use_eat","use_eat",0);
		DB_GLO_CharacterAnimation("PlayAnim_use_drink","use_drink",0);
		DB_GLO_CharacterAnimation("PlayAnim_use_craft","use_craft",0);
		DB_GLO_CharacterAnimation("PlayAnim_use_dig","use_dig",0);
		DB_GLO_CharacterAnimation("PlayAnim_skill_stance_start","skill_stance_start",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_skill_stance_loop","skill_stance_loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_skill_stance_cast","skill_stance_cast",0);
		DB_GLO_CharacterAnimation("PlayAnim_skill_prepare_weapon_01_start","skill_prepare_weapon_01_start",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_skill_prepare_weapon_01_loop","skill_prepare_weapon_01_loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_skill_attack_flurry_01_cast","skill_attack_flurry_01_cast",0);
		DB_GLO_CharacterAnimation("PlayAnim_skill_attack_precision_01_cast","skill_attack_precision_01_cast",0);
		DB_GLO_CharacterAnimation("PlayAnim_skill_attack_power_01_cast","skill_attack_power_01_cast",0);
		DB_GLO_CharacterAnimation("PlayAnim_skill_attack_round_01_cast","skill_attack_round_01_cast",0);
		DB_GLO_CharacterAnimation("PlayAnim_skill_attack_multi_01_cast","skill_attack_multi_01_cast",0);
		DB_GLO_CharacterAnimation("PlayAnim_skill_attack_multi_02_cast","skill_attack_multi_02_cast",0);
		DB_GLO_CharacterAnimation("PlayAnim_skill_attack_aoe_01_cast","skill_attack_aoe_01_cast",0);
		DB_GLO_CharacterAnimation("PlayAnim_skill_attack_offhand_01_cast","skill_attack_offhand_01_cast",0);
		DB_GLO_CharacterAnimation("PlayAnim_skill_attack_stance_01_cast","skill_attack_stance_01_cast",0);
		
		DB_GLO_CharacterAnimation("PlayAnim_skill_attack_projectile_01_cast","skill_attack_projectile_01_cast",0);
		DB_GLO_CharacterAnimation("PlayAnim_skill_attack_projectile_02_cast","skill_attack_projectile_02_cast",0);
		//////////////////////////////////////////////////////////////////////////
		//  Ranger tricks:
		//////////////////////////////////////////////////////////////////////////
		DB_GLO_CharacterAnimation("PlayAnim_skill_arrow_start","skill_arrow_start",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_skill_arrow_loop","skill_arrow_loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_skill_arrow_cast","skill_arrow_cast",0);
		
		DB_GLO_CharacterAnimation("PlayAnim_skill_rainofarrows_start","skill_rainofarrows_start",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_skill_rainofarrows_loop","skill_rainofarrows_loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_skill_rainofarrows_cast","skill_rainofarrows_cast",0);
		
		DB_GLO_CharacterAnimation("PlayAnim_skill_splittingarrows_start","skill_splittingarrows_start",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_skill_splittingarrows_loop","skill_splittingarrows_loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_skill_splittingarrows_cast","skill_splittingarrows_cast",0);
		
		DB_GLO_CharacterAnimation("PlayAnim_skill_multishot_lvl1_cast","skill_multishot_lvl1_cast",0);
		DB_GLO_CharacterAnimation("PlayAnim_skill_multishot_lvl2_cast","skill_multishot_lvl2_cast",0);
		DB_GLO_CharacterAnimation("PlayAnim_skill_multishot_lvl3_cast","skill_multishot_lvl3_cast",0);
		DB_GLO_CharacterAnimation("PlayAnim_skill_multishot_lvl4_cast","skill_multishot_lvl4_cast",0);
		DB_GLO_CharacterAnimation("PlayAnim_skill_multishot_lvl5_cast","skill_multishot_lvl5_cast",0);
		DB_GLO_CharacterAnimation("PlayAnim_skill_multishot_lvl6_cast","skill_multishot_lvl6_cast",0);
		DB_GLO_CharacterAnimation("PlayAnim_skill_multishot_lvl7_cast","skill_multishot_lvl7_cast",0);
		DB_GLO_CharacterAnimation("PlayAnim_skill_multishot_lvl8_cast","skill_multishot_lvl8_cast",0);
		DB_GLO_CharacterAnimation("PlayAnim_skill_multishot_lvl9_cast","skill_multishot_lvl9_cast",0);
		DB_GLO_CharacterAnimation("PlayAnim_skill_multishot_lvl10_cast","skill_multishot_lvl10_cast",0);
		//////////////////////////////////////////////////////////////////////////
		//  Warrior tricks:
		//////////////////////////////////////////////////////////////////////////
		DB_GLO_CharacterAnimation("PlayAnim_skill_flurry_start","skill_flurry_start",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_skill_flurry_loop","skill_flurry_loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_skill_flurry_cast","skill_flurry_cast",0);
		
		DB_GLO_CharacterAnimation("PlayAnim_skill_powerattack_start","skill_powerattack_start",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_skill_powerattack_loop","skill_powerattack_loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_skill_powerattack_cast","skill_powerattack_cast",0);
		
		DB_GLO_CharacterAnimation("PlayAnim_skill_whirlwind_start","skill_whirlwind_start",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_skill_whirlwind_loop","skill_whirlwind_loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_skill_whirlwind_cast","skill_whirlwind_cast",0);
		
		DB_GLO_CharacterAnimation("PlayAnim_skill_fatality_start","skill_fatality_start",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_skill_fatality_loop","skill_fatality_loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_skill_fatality_cast","skill_fatality_cast",0);
		//////////////////////////////////////////////////////////////////////////
		//  Scoundrel tricks:
		//////////////////////////////////////////////////////////////////////////
		DB_GLO_CharacterAnimation("PlayAnim_skill_shadowstrike_start","skill_shadowstrike_start",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_skill_shadowstrike_loop","skill_shadowstrike_loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_skill_shadowstrike_cast","skill_shadowstrike_cast",0);
		
		DB_GLO_CharacterAnimation("PlayAnim_skill_lacerate_start","skill_lacerate_start",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_skill_lacerate_loop","skill_lacerate_loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_skill_lacerate_cast","skill_lacerate_cast",0);
		//////////////////////////////////////////////////////////////////////////
		//  Emotions:
		//////////////////////////////////////////////////////////////////////////
		DB_GLO_CharacterAnimation("PlayAnim_emotion_normal","emotion_normal",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_normal_looping1","emotion_normal_looping1",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_normal_looping2","emotion_normal_looping2",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_normal_looping3","emotion_normal_looping3",1);
		DB_GLO_CharacterAnimation("PlayAnim_emotion_angry","emotion_angry",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_angry_looping1","emotion_angry_looping1",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_angry_looping2","emotion_angry_looping2",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_angry_looping3","emotion_angry_looping3",1);
		DB_GLO_CharacterAnimation("PlayAnim_emotion_boasting_bragging","emotion_boasting_bragging",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_boasting_bragging_looping1","emotion_boasting_bragging_looping1",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_boasting_bragging_looping2","emotion_boasting_bragging_looping2",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_boasting_bragging_looping3","emotion_boasting_bragging_looping3",1);
		DB_GLO_CharacterAnimation("PlayAnim_emotion_clueless","emotion_clueless",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_clueless_looping1","emotion_clueless_looping1",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_clueless_looping2","emotion_clueless_looping2",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_clueless_looping3","emotion_clueless_looping3",1);
		DB_GLO_CharacterAnimation("PlayAnim_emotion_cower_scared","emotion_cower_scared",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_cower_scared_looping1","emotion_cower_scared_looping1",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_cower_scared_looping2","emotion_cower_scared_looping2",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_cower_scared_looping3","emotion_cower_scared_looping3",1);
		DB_GLO_CharacterAnimation("PlayAnim_emotion_greeting","emotion_greeting",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_greeting_looping1","emotion_greeting_looping1",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_greeting_looping2","emotion_greeting_looping2",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_greeting_looping3","emotion_greeting_looping3",1);
		DB_GLO_CharacterAnimation("PlayAnim_emotion_happy_cheerful","emotion_happy_cheerful",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_happy_cheerful_looping1","emotion_happy_cheerful_looping1",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_happy_cheerful_looping2","emotion_happy_cheerful_looping2",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_happy_cheerful_looping3","emotion_happy_cheerful_looping3",1);
		DB_GLO_CharacterAnimation("PlayAnim_emotion_ignore_dismiss","emotion_ignore_dismiss",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_ignore_dismiss_looping1","emotion_ignore_dismiss_looping1",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_ignore_dismiss_looping2","emotion_ignore_dismiss_looping2",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_ignore_dismiss_looping3","emotion_ignore_dismiss_looping3",1);
		DB_GLO_CharacterAnimation("PlayAnim_emotion_panic_distress","emotion_panic_distress",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_panic_distress_looping1","emotion_panic_distress_looping1",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_panic_distress_looping2","emotion_panic_distress_looping2",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_panic_distress_looping3","emotion_panic_distress_looping3",1);
		DB_GLO_CharacterAnimation("PlayAnim_emotion_insulting","emotion_insulting",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_insulting_looping1","emotion_insulting_looping1",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_insulting_looping2","emotion_insulting_looping2",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_insulting_looping3","emotion_insulting_looping3",1);
		DB_GLO_CharacterAnimation("PlayAnim_emotion_sad","emotion_sad",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_sad_looping1","emotion_sad_looping1",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_sad_looping2","emotion_sad_looping2",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_sad_looping3","emotion_sad_looping3",1);
		DB_GLO_CharacterAnimation("PlayAnim_emotion_thankful","emotion_thankful",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_thankful_looping1","emotion_thankful_looping1",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_thankful_looping2","emotion_thankful_looping2",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_thankful_looping3","emotion_thankful_looping3",1);
		DB_GLO_CharacterAnimation("PlayAnim_emotion_sly_scheming","emotion_sly_scheming",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_sly_scheming_looping1","emotion_sly_scheming_looping1",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_sly_scheming_looping2","emotion_sly_scheming_looping2",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_sly_scheming_looping3","emotion_sly_scheming_looping3",1);
		DB_GLO_CharacterAnimation("PlayAnim_emotion_sarcasm_haughty","emotion_sarcasm_haughty",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_sarcasm_haughty_looping1","emotion_sarcasm_haughty_looping1",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_sarcasm_haughty_looping2","emotion_sarcasm_haughty_looping2",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_sarcasm_haughty_looping3","emotion_sarcasm_haughty_looping3",1);
		DB_GLO_CharacterAnimation("PlayAnim_emotion_flirt","emotion_flirt",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_flirt_looping1","emotion_flirt_looping1",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_flirt_looping2","emotion_flirt_looping2",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_flirt_looping3","emotion_flirt_looping3",1);
		//////////////////////////////////////////////////////////////////////////
		//  Climbing
		//////////////////////////////////////////////////////////////////////////
		DB_GLO_CharacterAnimation("PlayAnim_climb_UpAttach","climb_UpAttach",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_climb_Up","climb_Up",1);
		DB_GLO_CharacterAnimation("PlayAnim_climb_UpDetach","climb_UpDetach",0);
		DB_GLO_CharacterAnimation("PlayAnim_climb_DownAttach","climb_DownAttach",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_climb_Down","climb_Down",1);
		DB_GLO_CharacterAnimation("PlayAnim_climb_DownDetach","climb_DownDetach",0);
		DB_GLO_CharacterAnimation("PlayAnim_cast_target_start","cast_target_start",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_cast_target_loop","cast_target_loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_cast_target_cast","cast_target_cast",0);
		DB_GLO_CharacterAnimation("PlayAnim_cast_shout_start","cast_shout_start",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_cast_shout_loop","cast_shout_loop",1);
		
		// Custom animations
		DB_GLO_CharacterAnimation("PlayAnim_Activate_01","Activate_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Annoyed_01","Annoyed_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Attention_01","Attention_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Attention_02","Attention_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Attention_03","Attention_03",0);
		DB_GLO_CharacterAnimation("PlayAnim_Attentive_01","Attentive_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Beg_01","Beg_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_BehindBars_01","BehindBars_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_BehindBars_02","BehindBars_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Bellringer_01","Bellringer_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Blacksmith_01","Blacksmith_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Blacksmith_02","Blacksmith_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Bored_01","Bored_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Bored_02","Bored_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Bored_03","Bored_03",0);
		DB_GLO_CharacterAnimation("PlayAnim_Bow_01","Bow_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Bow_02","Bow_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Bow_03","Bow_03",0);
		DB_GLO_CharacterAnimation("PlayAnim_Bow_04","Bow_04",0);
		DB_GLO_CharacterAnimation("PlayAnim_Bow_05","Bow_05",0);
		DB_GLO_CharacterAnimation("PlayAnim_Cast_Ritual_01","Cast_Ritual_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Check_Neck_01","Check_Neck_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Cheer_01","Cheer_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Cheer_02","Cheer_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Cheer_03","Cheer_03",0);
		DB_GLO_CharacterAnimation("PlayAnim_Chicken_01","Chicken_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Chicken_02","Chicken_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Chicken_03","Chicken_03",0);
		DB_GLO_CharacterAnimation("PlayAnim_Chicken_Idle_01","Chicken_Idle_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Chuckle_01","Chuckle_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Chuckle_02","Chuckle_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Clap_01","Clap_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Clap_02","Clap_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Clap_03","Clap_03",0);
		DB_GLO_CharacterAnimation("PlayAnim_Clap_04","Clap_04",0);
		DB_GLO_CharacterAnimation("PlayAnim_Clean_Floor_01","Clean_Floor_01",0); // With mop & water
		DB_GLO_CharacterAnimation("PlayAnim_Clean_Floor_02","Clean_Floor_02",0); // With broom
		DB_GLO_CharacterAnimation("PlayAnim_Cooking_01","Cooking_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Cower_01","Cower_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Cower_02","Cower_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Crying_01","Crying_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Curtsey_01","Curtsey_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Dance_01","Dance_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Depressed_01","Depressed_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Dust_Off_01","Dust_Off_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Fidget_Book_01","Fidget_Book_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Fidget_Forward_01","Fidget_Forward_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Fidget_Forward_02","Fidget_Forward_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Fidget_High_01","Fidget_High_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Fidget_High_02","Fidget_High_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Fidget_Low_01","Fidget_Low_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Fidget_Low_02","Fidget_Low_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Fidget_Low_03","Fidget_Low_03",0);
		DB_GLO_CharacterAnimation("PlayAnim_Flex_01","Flex_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Flirt_01","Flirt_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Fumble_01","Fumble_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Halt_01","Halt_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Ignore_01","Ignore_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Intimidate_01","Intimidate_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Intimidate_02","Intimidate_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Kneel_01","Kneel_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Kneel_02","Kneel_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Laugh_01","Laugh_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Laugh_02","Laugh_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Listen_01","Listen_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_LoadingCart_01","LoadingCart_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Look_Down_Long_01","Look_Down_Long_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Look_Down_Short_01","Look_Down_Short_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Look_Left_Long_01","Look_Left_Long_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Look_Left_Short_01","Look_Left_Short_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Look_Right_Long_01","Look_Right_Long_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Look_Right_Short_01","Look_Right_Short_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Look_Up_Long_01","Look_Up_Long_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Look_Up_Short_01","Look_Up_Short_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Look_Up_Short_02","Look_Up_Short_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Mindcontrol_01","Mindcontrol_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Mine_01","Mine_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_No_01","No_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_No_02","No_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_No_03","No_03",0);
		DB_GLO_CharacterAnimation("PlayAnim_No_04","No_04",0);
		DB_GLO_CharacterAnimation("PlayAnim_No_05","No_05",0);
		DB_GLO_CharacterAnimation("PlayAnim_No_06","No_06",0);
		DB_GLO_CharacterAnimation("PlayAnim_Perform_01","Perform_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Perform_02","Perform_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Perform_03","Perform_03",0);
		DB_GLO_CharacterAnimation("PlayAnim_Pickpocket_01","Pickpocket_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Point_01","Point_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Potion_Rub_01","Potion_Rub_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Pray_01","Pray_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Pst_01","Pst_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Pst_02","Pst_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Pst_03","Pst_03",0);
		DB_GLO_CharacterAnimation("PlayAnim_Pst_04","Pst_04",0);
		DB_GLO_CharacterAnimation("PlayAnim_Repair_01","Repair_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Revolt_01","Revolt_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Revolt_02","Revolt_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Salute_01","Salute_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Salute_02","Salute_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Salute_03","Salute_03",0);
		DB_GLO_CharacterAnimation("PlayAnim_Salute_04","Salute_04",0);
		DB_GLO_CharacterAnimation("PlayAnim_Salute_05","Salute_05",0);
		DB_GLO_CharacterAnimation("PlayAnim_Salute_06","Salute_06",0);
		DB_GLO_CharacterAnimation("PlayAnim_Salute_07","Salute_07",0);
		DB_GLO_CharacterAnimation("PlayAnim_Shout_01","Shout_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Shrug_01","Shrug_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Sigh_01","Sigh_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Sooth_01","Sooth_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Sow_02","Sow_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Stand_Read_01","Stand_Read_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Surprise_01","Surprise_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Surprise_02","Surprise_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Tapping_Beer_01","Tapping_Beer_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Tapping_Beer_02","Tapping_Beer_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Taunt_01","Taunt_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Taunt_02","Taunt_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Teleport_01","Teleport_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Think_01","Think_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Think_02","Think_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Throw_Away_01","Throw_Away_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Throw_Up_01","Throw_Up_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Throw_Water_01","Throw_Water_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Tired_01","Tired_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Trader_01","Trader_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Trader_02","Trader_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Trader_03","Trader_03",0);
		DB_GLO_CharacterAnimation("PlayAnim_Use_01","Use_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Use_02","Use_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Victory_01","Victory_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Victory_02","Victory_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Warm_Hands_01","Warm_Hands_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Wave_01","Wave_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Wave_02","Wave_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Wave_03","Wave_03",0);
		DB_GLO_CharacterAnimation("PlayAnim_WipeTable_01","WipeTable_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Worship_01","Worship_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Yawn_01","Yawn_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Yes_01","Yes_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Yes_02","Yes_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Yes_03","Yes_03",0);
		DB_GLO_CharacterAnimation("PlayAnim_Yes_04","Yes_04",0);
		DB_GLO_CharacterAnimation("PlayAnim_Yes_05","Yes_05",0);
		DB_GLO_CharacterAnimation("PlayAnim_Sit_Angry_01","Sit_Angry_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Sit_Annoyed_01","Sit_Annoyed_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Sit_Bored_01","Sit_Bored_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Sit_Bored_02","Sit_Bored_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Sit_Chuckle_01","Sit_Chuckle_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Sit_Drink_01","Sit_Drink_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Sit_Laugh_01","Sit_Laugh_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Sit_Laugh_02","Sit_Laugh_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Sit_Look_Left_01","Sit_Look_Left_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Sit_Look_Right_01","Sit_Look_Right_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Sit_No_01","Sit_No_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Sit_No_02","Sit_No_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Sit_Praise_01","Sit_Praise_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Sit_Pray_01","Sit_Pray_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Sit_Read_01","Sit_Read_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Sit_Reject_01","Sit_Reject_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Sit_Salute_01","Sit_Salute_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Sit_Sigh_01","Sit_Sigh_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Sit_Surprise_01","Sit_Surprise_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Sit_Tired_01","Sit_Tired_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Sit_Yes_01","Sit_Yes_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_BarStand_01_Loop","BarStand_01_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Lie_Relax_01_Loop","Lie_Relax_01_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Lie_Suffer_01_Loop","Lie_Suffer_01_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Lie_Suffer_02_Loop","Lie_Suffer_02_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Lie_Suffer_03_Loop","Lie_Suffer_03_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Chained_01_Loop","Chained_01_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Cower_03_Loop","Cower_03_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Crucified_01_Loop","Crucified_01_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Dig_01_Loop","Dig_01_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Lie_Dead_01_Loop","Lie_Dead_01_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Lie_Relax_02_Loop","Lie_Relax_02_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Lie_Wounded_01_Loop","Lie_Wounded_01_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Lie_Wounded_02_Loop","Lie_Wounded_02_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Lie_Wounded_03_Loop","Lie_Wounded_03_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Guard_01_Loop","Guard_01_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Hung_01_Loop","Hung_01_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Hung_02_Loop","Hung_02_Loop",1); // dead
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Hung_03_Loop","Hung_03_Loop",1); // alive & kicking by the neck
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Injured_01_Loop","Injured_01_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Insane_01_Loop","Insane_01_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Kneel_01_Loop","Kneel_01_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Lie_Tied_Up_01_Loop","Lie_Tied_Up_01_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Lie_Tied_Up_01_End","Lie_Tied_Up_01_End",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Rake_01_Loop","Rake_01_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Sing_01_Loop","Sing_01_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Sad_01_Loop","Sad_01_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Search_Book_01_Loop","Search_Book_01_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Sit_Sick_01_Loop","Sit_Sick_01_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Sit_Sleep_01_Loop","Sit_Sleep_01_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Sit_Sleep_02_Loop","Sit_Sleep_02_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Sit_Write_01_Loop","Sit_Write_01_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Sow_01_Loop","Sow_01_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Stand_Drink_01_Loop","Stand_Drink_01_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Stand_Drink_02_Loop","Stand_Drink_02_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Stand_Read_01_Loop","Stand_Read_01_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Stare_01_Loop","Stare_01_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Tied_Up_01_Loop","Tied_Up_01_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Training_2HS_01_Loop","Training_2HS_01_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Training_Bow_01_Loop","Training_Bow_01_Loop",1);
		
		DB_GLO_CharacterAnimation("PlayAnim_skill_cast_throw_arc_02_cast","skill_cast_throw_arc_02_cast");
		
	}
	KB
	{
		//REGION Play animation when flag is set
		IF
		ObjectFlagSet(_Flag,(CHARACTERGUID)_Character,_Dialog)
		AND
		DB_GLO_CharacterAnimation(_Flag,_Animation,_Looping)
		THEN
		ObjectClearFlag(_Character,_Flag);
		PROC_GLO_CharacterAnimationStart(_Character,_Animation,_Dialog,_Looping);
		
		PROC
		PROC_GLO_CharacterAnimationStart((CHARACTERGUID)_Character,(STRING)_Animation,(INTEGER)_Dialog,0)
		AND
		NOT DB_GLO_CharacterAnimationForDialog(_Character,_)
		THEN
		DB_GLO_CharacterAnimationForDialog(_Character,_Dialog);
		PlayAnimation(_Character,_Animation,"GLO_CharacterAnimationFinished");
		
		IF
		StoryEvent((CHARACTERGUID)_Character,"GLO_CharacterAnimationFinished")
		AND
		DB_GLO_CharacterAnimationForDialog(_Character,_Dialog)
		THEN
		NOT DB_GLO_CharacterAnimationForDialog(_Character,_Dialog);
		
		PROC
		PROC_GLO_CharacterAnimationStart((CHARACTERGUID)_Character,(STRING)_Animation,(INTEGER)_Dialog,1)
		THEN
		CharacterSetAnimationOverride(_Character,_Animation);
		
		IF
		ObjectFlagSet("PlayAnim_StopLoop",(CHARACTERGUID)_Character,_)
		THEN
		ObjectClearFlag(_Character,"PlayAnim_StopLoop");
		CharacterSetAnimationOverride(_Character,"");
		
		IF
		ObjectFlagSet("PlayAnim_DrawWeapons",(CHARACTERGUID)_Character,_)
		AND
		HasActiveStatus(_Character,"SITTING",1)
		THEN
		RemoveStatus(_Character,"SITTING");
		
		IF
		ObjectFlagSet("PlayAnim_DrawWeapons",(CHARACTERGUID)_Character,_)
		THEN
		ObjectClearFlag(_Character,"PlayAnim_DrawWeapons");
		CharacterSetFightMode(_Character,1,0);
		
		IF
		ObjectFlagSet("PlayAnim_SheathWeapons",(CHARACTERGUID)_Character,_)
		THEN
		ObjectClearFlag(_Character,"PlayAnim_SheathWeapons");
		CharacterSetFightMode(_Character,0,0);
		//END_REGION
		
	}
	EXIT
	{
		
	}
}
Goal(21).Title("_Global_Counter");
Goal(21)
{
	INIT
	{
		
	}
	KB
	{
		PROC
		ProcRemoveCounter((STRING)_Name)
		AND
		DB_GlobalCounter(_Name,_Count)
		THEN
		NOT DB_GlobalCounter(_Name,_Count);
		
		PROC
		ProcDeclareCounter((STRING)_Name)
		THEN
		ProcRemoveCounter(_Name);
		DB_GlobalCounter(_Name,0);
		
		PROC
		ProcIncreaseCounter((STRING)_Name)
		THEN
		ProcIncreaseCounter(_Name,1);
		
		PROC
		ProcIncreaseCounter((STRING)_Name,(INTEGER)_Amount)
		AND
		DB_GlobalCounter(_Name,_Count)
		AND
		IntegerSum(_Count,_Amount,_NewCount)
		THEN
		NOT DB_GlobalCounter(_Name,_Count);
		DB_GlobalCounter(_Name,_NewCount);
		
		PROC
		ProcDecreaseCounter((STRING)_Name)
		THEN
		ProcDecreaseCounter(_Name,1);
		
		PROC
		ProcDecreaseCounter((STRING)_Name,(INTEGER)_Amount)
		AND
		DB_GlobalCounter(_Name,_Count)
		AND
		IntegerSubtract(_Count,_Amount,_NewCount)
		THEN
		NOT DB_GlobalCounter(_Name,_Count);
		DB_GlobalCounter(_Name,_NewCount);
		
	}
	EXIT
	{
		
	}
}
Goal(22).Title("_GLOBAL_Effects");
Goal(22)
{
	INIT
	{
		PROC_CleanUpEffects();
		
	}
	KB
	{
		//REGION Savegame handle fixes 
		
		IF
		DB_CurrentLevel(_)
		THEN
		PROC_InvalidateLoopEffects();
		PROC_InvalidateLoopBeamEffects();
		
		PROC
		PROC_InvalidateLoopEffects()
		AND
		DB_LoopEffect((GUIDSTRING)_object, (INTEGER64) _fxHandle,(STRING)_ID,(STRING)_Region,(STRING)_effect,(STRING)_BoneName)
		THEN
		NOT DB_LoopEffect(_object, _fxHandle,_ID,_Region,_effect,_BoneName);
		DB_LoopEffect(_object, (INTEGER64)-1,_ID,_Region,_effect,_BoneName);
		
		PROC
		PROC_InvalidateLoopBeamEffects()
		AND
		DB_LoopBeamEffect((GUIDSTRING)_Source,(GUIDSTRING)_Target,(INTEGER64)_EffectHandle,(STRING)_ID,(STRING)_Region,(STRING)_effect,(STRING)_SrcBone,(STRING)_TargetBone)
		THEN
		NOT DB_LoopBeamEffect(_Source,_Target,_EffectHandle,_ID,_Region,_effect,_SrcBone,_TargetBone);
		DB_LoopBeamEffect(_Source,_Target,(INTEGER64)-1,_ID,_Region,_effect,_SrcBone,_TargetBone);
		//END_REGION
		
		/***************************/
		/*** EFFECT REGISTRATION ***/
		/***************************/
		
		PROC
		PROC_LoopEffect((STRING)_effect, (GUIDSTRING)_Source,(STRING)_ID,(STRING)_Region,(STRING)_BoneName)
		AND
		DB_CurrentLevel(_Region)
		AND
		PlayLoopEffect(_Source, _effect, _BoneName, _fxHandle)
		THEN
		DB_LoopEffect(_Source, _fxHandle,_ID,_Region,_effect, _BoneName);
		
		PROC
		PROC_LoopEffect((STRING)_effect, (GUIDSTRING)_Source,(STRING)_ID,(STRING)_Region,(STRING)_BoneName)
		AND
		_Region!="__ANY__"
		AND
		NOT DB_CurrentLevel(_Region)
		THEN
		DB_LoopEffect(_Source, (INTEGER64)-1,_ID,_Region,_effect, _BoneName);
		
		PROC
		PROC_LoopEffect((STRING)_effect, (GUIDSTRING)_Source,(STRING)_ID,"__ANY__",(STRING)_BoneName)
		AND
		DB_CurrentLevel(_)
		AND
		NOT QryBlockEffectInCombat(_effect,_Source)
		AND
		PlayLoopEffect(_Source, _effect, _BoneName, _fxHandle)
		THEN
		DB_LoopEffect(_Source, _fxHandle,_ID,"__ANY__",_effect, _BoneName);
		
		PROC
		PROC_LoopEffect((STRING)_effect, (GUIDSTRING)_Source,(STRING)_ID,"__ANY__",(STRING)_BoneName)
		AND
		DB_CurrentLevel(_)
		AND
		QryBlockEffectInCombat(_effect,_Source)
		THEN
		DB_LoopEffect(_Source, (INTEGER64)-1,_ID,"__ANY__",_effect, _BoneName);
		
		PROC
		PROC_LoopEffect((STRING)_effect, (GUIDSTRING)_Source,(STRING)_ID,"__ANY__",(STRING)_BoneName)
		AND
		NOT DB_CurrentLevel(_)
		THEN
		DB_LoopEffect(_Source, (INTEGER64)-1,_ID,"__ANY__",_effect, _BoneName);
		
		PROC
		PROC_LoopBeamEffect((STRING)_effect, (GUIDSTRING)_Source,(GUIDSTRING)_Target,(STRING)_SrcBone,(STRING)_TargetBone,(STRING)_ID,(STRING)_Region)
		AND
		_Region!="__ANY__"
		AND
		NOT DB_CurrentLevel(_Region)
		THEN
		DB_LoopBeamEffect(_Source,_Target,(INTEGER64)-1,_ID,_Region,_effect,_SrcBone,_TargetBone);
		
		PROC
		PROC_LoopBeamEffect((STRING)_effect, (GUIDSTRING)_Source,(GUIDSTRING)_Target,(STRING)_SrcBone,(STRING)_TargetBone,(STRING)_ID,(STRING)_Region)
		AND
		DB_CurrentLevel(_Region)
		AND
		PlayLoopBeamEffect(_Source,_Target,_effect,_SrcBone,_TargetBone,_EffectHandle)
		THEN
		DB_LoopBeamEffect(_Source,_Target,_EffectHandle,_ID,_Region,_effect,_SrcBone,_TargetBone);
		
		PROC
		PROC_LoopBeamEffect((STRING)_effect, (GUIDSTRING)_Source,(GUIDSTRING)_Target,(STRING)_SrcBone,(STRING)_TargetBone,(STRING)_ID,"__ANY__")
		AND
		PlayLoopBeamEffect(_Source,_Target,_effect,_SrcBone,_TargetBone,_EffectHandle)
		THEN
		DB_LoopBeamEffect(_Source,_Target,_EffectHandle,_ID,"__ANY__",_effect,_SrcBone,_TargetBone);
		
		/***********************/
		/*** EFFECT DELETION ***/
		/***********************/
		
		PROC
		ProcStopLoopEffect((INTEGER64)_fxHandle)
		AND
		_fxHandle!=-1
		THEN
		StopLoopEffect(_fxHandle);
		
		PROC
		PROC_StopLoopEffect((GUIDSTRING)_Source,(STRING)_ID)
		AND
		DB_LoopEffect(_Source, _fxHandle,_ID,_Region,_effect, _BoneName)
		THEN
		ProcStopLoopEffect(_fxHandle);
		NOT DB_LoopEffect(_Source, _fxHandle,_ID,_Region,_effect, _BoneName);
		
		PROC
		PROC_StopLoopBeamEffect((GUIDSTRING)_Source,(STRING)_ID)
		AND
		DB_LoopBeamEffect(_Source,_Target,_EffectHandle,_ID,_Region,_effect,_SrcBone,_TargetBone)
		THEN
		ProcStopLoopEffect(_EffectHandle);
		NOT DB_LoopBeamEffect(_Source,_Target,_EffectHandle,_ID,_Region,_effect,_SrcBone,_TargetBone);
		
		/************************/
		/*** EFFECTS CLEAN-UP ***/
		/************************/
		
		PROC
		PROC_CleanUpEffects()
		THEN
		PROC_CleanUpLoopEffects();
		PROC_CleanUpLoopBeamEffects();
		
		PROC
		PROC_CleanUpLoopEffects()
		AND
		DB_LoopEffect(_Object, _,_ID,_,_,_)
		THEN
		PROC_StopLoopEffect(_Object,_ID);
		
		PROC
		PROC_CleanUpLoopBeamEffects()
		AND
		DB_LoopBeamEffect(_Source,_Target,_EffectHandle,_ID,_Region,_effect,_SrcBone,_TargetBone)
		THEN
		PROC_StopLoopBeamEffect(_Source,_ID);
		
		
		
		/************************/
		
		//REGION stopping effects for a region 
		
		PROC
		ProcStopEffectsForRegion((STRING)_Region)
		THEN
		ProcStopLoopEffectsForRegion(_Region);
		ProcStopLoopBeamEffectsForRegion(_Region);
		
		PROC
		ProcStopLoopEffectsForRegion((STRING)_Region)
		AND
		DB_LoopEffect(_Source, _fxHandle,_ID,_Region,_effect, _BoneName)
		THEN
		ProcStopLoopEffect(_fxHandle);
		NOT DB_LoopEffect(_Source, _fxHandle,_ID,_Region,_effect, _BoneName);
		DB_LoopEffect(_Source,(INTEGER64)-1,_ID,_Region,_effect, _BoneName);
		
		PROC
		ProcStopLoopBeamEffectsForRegion((STRING)_Region)
		AND
		DB_LoopBeamEffect(_Source,_Target,_EffectHandle,_ID,_Region,_effect,_SrcBone,_TargetBone)
		THEN
		ProcStopLoopEffect(_EffectHandle);
		NOT DB_LoopBeamEffect(_Source,_Target,_EffectHandle,_ID,_Region,_effect,_SrcBone,_TargetBone);
		DB_LoopBeamEffect(_Source,_Target,(INTEGER64)-1,_ID,_Region,_effect,_SrcBone,_TargetBone);
		
		PROC
		ProcStopLoopEffectsForRegion((STRING)_)
		AND
		DB_LoopEffect(_Source, _fxHandle,_ID,"__ANY__",_effect, _BoneName)
		THEN
		ProcStopLoopEffect(_fxHandle);
		NOT DB_LoopEffect(_Source, _fxHandle,_ID,"__ANY__",_effect, _BoneName);
		DB_LoopEffect(_Source, (INTEGER64)-1,_ID,"__ANY__",_effect, _BoneName);
		
		PROC
		ProcStopLoopBeamEffectsForRegion((STRING)_)
		AND
		DB_LoopBeamEffect(_Source,_Target,_EffectHandle,_ID,"__ANY__",_effect,_SrcBone,_TargetBone)
		THEN
		ProcStopLoopEffect(_EffectHandle);
		NOT DB_LoopBeamEffect(_Source,_Target,_EffectHandle,_ID,"__ANY__",_effect,_SrcBone,_TargetBone);
		DB_LoopBeamEffect(_Source,_Target,(INTEGER64)-1,_ID,"__ANY__",_effect,_SrcBone,_TargetBone);
		//END_REGION
		
		//REGION starting effects for a region 
		
		PROC
		ProcStartEffectsForRegion((STRING)_Region)
		THEN
		ProcStartLoopEffectsForRegion(_Region);
		ProcStartLoopBeamEffectsForRegion(_Region);
		
		PROC
		ProcStartLoopEffectsForRegion((STRING)_Region)
		AND
		DB_LoopEffect(_Source, _fxHandle,_ID,_Region,_effect, _BoneName)
		AND
		NOT QryBlockEffectInCombat(_effect,_Source)
		AND
		PlayLoopEffect(_Source, _effect, _BoneName, _NewfxHandle)
		THEN
		ProcStopLoopEffect(_fxHandle);
		NOT DB_LoopEffect(_Source, _fxHandle,_ID,_Region,_effect, _BoneName);
		DB_LoopEffect(_Source, _NewfxHandle,_ID,_Region,_effect, _BoneName);
		
		PROC
		ProcStartLoopBeamEffectsForRegion((STRING)_Region)
		AND
		DB_LoopBeamEffect(_Source,_Target,_EffectHandle,_ID,_Region,_effect,_SrcBone,_TargetBone)
		AND
		PlayLoopBeamEffect(_Source,_Target,_effect,_SrcBone,_TargetBone,_NewEffectHandle)
		THEN
		ProcStopLoopEffect(_EffectHandle);
		NOT DB_LoopBeamEffect(_Source,_Target,_EffectHandle,_ID,_Region,_effect,_SrcBone,_TargetBone);
		DB_LoopBeamEffect(_Source,_Target,_NewEffectHandle,_ID,_Region,_effect,_SrcBone,_TargetBone);
		
		///////
		
		PROC
		ProcStartLoopEffectsForRegion((STRING)_)
		AND
		DB_LoopEffect(_Source, _fxHandle,_ID,"__ANY__",_effect, _BoneName)
		AND
		NOT QryBlockEffectInCombat(_effect,_Source)
		AND
		PlayLoopEffect(_Source, _effect, _BoneName, _NewfxHandle)
		THEN
		ProcStopLoopEffect(_fxHandle);
		NOT DB_LoopEffect(_Source, _fxHandle,_ID,"__ANY__",_effect, _BoneName);
		DB_LoopEffect(_Source, _NewfxHandle,_ID,"__ANY__",_effect, _BoneName);
		
		PROC
		ProcStartLoopBeamEffectsForRegion((STRING)_Region)
		AND
		DB_LoopBeamEffect(_Source,_Target,_EffectHandle,_ID,"__ANY__",_effect,_SrcBone,_TargetBone)
		AND
		PlayLoopBeamEffect(_Source,_Target,_effect,_SrcBone,_TargetBone,_NewEffectHandle)
		THEN
		ProcStopLoopEffect(_EffectHandle);
		NOT DB_LoopBeamEffect(_Source,_Target,_EffectHandle,_ID,"__ANY__",_effect,_SrcBone,_TargetBone);
		DB_LoopBeamEffect(_Source,_Target,_NewEffectHandle,_ID,"__ANY__",_effect,_SrcBone,_TargetBone);
		
		//END_REGION
		
		IF
		RegionEnded(_Region)
		THEN
		ProcStopEffectsForRegion(_Region);
		
		// At GameStarted instead of RegionStarted, because sometimes characters are teleported to the current region
		// only during RegionStarted, and this RegionStarted handled may be exectuted before the one doing that
		// (which results in playing the effect on the character while they are still in the previous level, and that
		//  triggers an assert)
		IF
		GameStarted(_Region,_)
		THEN
		ProcStartEffectsForRegion(_Region);
		
		//REGION Special case: Some effects should stop during combat
		IF
		ObjectEnteredCombat(_Character,_)
		AND
		DB_LoopEffect(_Character, _fxHandle,_ID,_Region,_EffectName,_BoneName)
		AND
		DB_LoopEffectDisabledInCombat(_EffectName)
		THEN
		ProcStopLoopEffect(_fxHandle);
		NOT DB_LoopEffect(_Character, _fxHandle,_ID,_Region,_EffectName,_BoneName);
		DB_LoopEffect(_Character, (INTEGER64)-1, _ID,_Region,_EffectName,_BoneName);
		
		IF
		ObjectLeftCombat((CHARACTERGUID)_Character,_)
		AND
		NOT DB_Dead(_Character)
		AND
		DB_LoopEffect(_Character, (INTEGER64)-1, _ID,_Region,_EffectName,_BoneName)
		AND
		DB_LoopEffectDisabledInCombat(_EffectName)
		AND
		PlayLoopEffect(_Character, _EffectName, _BoneName,_NewfxHandle)
		THEN
		NOT DB_LoopEffect(_Character, (INTEGER64)-1, _ID,_Region,_EffectName,_BoneName);
		DB_LoopEffect(_Character,_NewfxHandle,_ID,_Region,_EffectName,_BoneName);
		
		QRY
		QryBlockEffectInCombat((STRING)_EffectName,(GUIDSTRING)_Object)
		AND
		DB_LoopEffectDisabledInCombat(_EffectName)
		AND
		DB_CombatObjects(_Object,_)
		THEN
		DB_NOOP(1);
		
		//END_REGION
		
	}
	EXIT
	{
		
	}
}
Goal(23).Title("_Global_Homestead");
Goal(23)
{
	INIT
	{
		
	}
	KB
	{
		//REGION Character creation mirror (respec)
		IF
		CharacterItemEvent(_Player,_Mirror,"GEN_Homestead_CharCreationMirror")
		AND
		CharacterAddToCharacterCreation(_Player,2,1)
		THEN
		DB_Illusionist(_Player,_Mirror);
		
		IF
		CharacterItemEvent(_Player,_Mirror,"GEN_Homestead_CharCreationMirror")
		AND
		HasActiveStatus(_Player,"PLAY_DEAD",1)
		THEN
		RemoveStatus(_Player,"PLAY_DEAD");
		
		//REGION Save while using the mirror -> re-add to character creation after loading (DOSTWO-9410)
		IF
		SavegameLoaded(_,_,_,_)
		AND
		DB_Illusionist(_Player,_Mirror)
		AND
		CharacterAddToCharacterCreation(_Player,2,0)
		THEN
		DebugBreak("Failed to re-add player to character creation after reload");
		//END_REGION
		
		//REGION Handle teleportation pyramids
		// Avoid other players teleporting into the character creation "level"
		IF
		DB_Illusionist(_Player,_)
		AND
		DB_TeleporterPyramid(_Pyramid)
		AND
		ItemIsInCharacterInventory(_Pyramid,_Player,1)
		THEN
		DisablePyramid(_Pyramid);
		
		IF
		ItemAddedToCharacter(_Pyramid,_Player)
		AND
		DB_TeleporterPyramid(_Pyramid)
		AND
		DB_Illusionist(_Player,_Mirror)
		THEN
		DisablePyramid(_Pyramid);
		
		IF
		CharacterCreationFinished(_Player)
		AND
		DB_Illusionist(_Player,_Mirror)
		AND
		DB_TeleporterPyramid(_Pyramid)
		AND
		ItemIsInCharacterInventory(_Pyramid,_Player,1)
		THEN
		EnablePyramid(_Pyramid);
		//END_REGION
		
		//REGION Finished respec
		PROC
		Proc_HomesteadTeleportAfterMirror((CHARACTERGUID)_Player,(ITEMGUID)_Mirror,(TRIGGERGUID)_Trigger)
		AND
		_Trigger!=NULL_00000000-0000-0000-0000-000000000000
		THEN
		TeleportTo(_Player,_Trigger,"",0);
		
		PROC
		Proc_HomesteadTeleportAfterMirror((CHARACTERGUID)_Player,(ITEMGUID)_Mirror,(TRIGGERGUID)_Trigger)
		AND
		_Trigger==NULL_00000000-0000-0000-0000-000000000000
		THEN
		TeleportTo(_Player,_Mirror,"",0);
		
		IF
		CharacterCreationFinished(_Player)
		AND
		DB_Illusionist(_Player,_Mirror)
		AND
		GetVarObject(_Mirror,"PlayerPositionAfterCreation",_Trigger)
		THEN
		NOT DB_Illusionist(_Player,_Mirror);
		Proc_HomesteadTeleportAfterMirror(_Player,_Mirror,(TRIGGERGUID)_Trigger);
		//END_REGION
		
		//END_REGION
		
	}
	EXIT
	{
		
	}
}
Goal(24).Title("_GLOBAL_ItemEvents");
Goal(24)
{
	INIT
	{
		/*
		Databases used for this events
		DB_HasStoryEvent((ITEMGUID)_Item,_HasItemEvent);
		DB_GiveItemToEvent(_Item,_GiveItemToStoryEvent);
		*/
		///Please Add any Item tags that you want to be tracked HERE!!
		//when declaredo n the fly only players will be checked
		DB_TaggedItemInitialSetup(1);
		DB_TaggedItemTracker("HEALING_POTION");
		DB_TaggedItemTracker("BODYPART");
		DB_TaggedItemTracker("MEAT");
		DB_TaggedItemTracker("FISH");
		DB_TaggedItemTracker("BOOK");
		DB_TaggedItemTracker("QUEST_ANCESTOR_TREE_BRANCH");
		DB_TaggedItemTracker("FOOD");
		DB_TaggedItemTracker("BONE");
		DB_TaggedItemTracker("TOY");
		DB_TaggedItemTracker("ALCOHOL");
		DB_TaggedItemTracker("CHEESE");
		DB_TaggedItemTracker("VEGETABLE");
		DB_TaggedItemTracker("DRUDANAE");
		NOT DB_TaggedItemInitialSetup(1);
		
		DB_ItemEvents_TransferFlagToMoneyVarIndex("GEN_TransferNPCPayment",1);
		DB_ItemEvents_TransferFlagToMoneyVarIndex("GEN_TransferNPCPayment_2",2);
		DB_ItemEvents_TransferFlagToMoneyVarIndex("GEN_TransferNPCPayment_3",3);
		DB_ItemEvents_TransferFlagToMoneyVarIndex("GEN_TransferNPCPayment_4",4);
		DB_ItemEvents_TransferFlagToMoneyVarIndex("GEN_TransferNPCPayment_5",5);
		
	}
	KB
	{
		//REGION Event Recheck triggers
		//see also ZZZ_ItemEvents for a trigger
		IF
		CharacterMadePlayer(_Player)
		THEN
		DB_IgnoreReservedChanged(_Player);
		
		IF
		DB_CharacterCreationDummy((CHARACTERGUID)_Char)
		THEN
		DB_IgnoreReservedChanged(_Char);
		
		IF
		CharacterReservedUserIDChanged(_Char,_)
		AND
		DB_IsPlayer(_Char)
		AND
		NOT DB_IgnoreReservedChanged(_Char)
		THEN
		Proc_ItemEventCheck();
		
		IF
		CharacterReservedUserIDChanged(_Char,_)
		THEN
		NOT DB_IgnoreReservedChanged(_Char);
		
		IF
		SavegameLoaded(_,_,_,_)
		THEN
		Proc_ItemEventCheck();
		
		PROC
		PROC_GLO_PartyMembers_Add((CHARACTERGUID)_Origin,(CHARACTERGUID)_)
		THEN
		Proc_ItemEventCheck();
		
		//END_REGION
		
		//REGION Private
		PROC
		ProcSetMagicPocketsItemTemplatecount((CHARACTERGUID)_Player,(STRING)_Template,(INTEGER)_)
		AND
		DB_MagicPocketsItemTemplateCount(_Player,_Template,_Count)
		THEN
		NOT DB_MagicPocketsItemTemplateCount(_Player,_Template,_Count);
		
		PROC
		ProcSetMagicPocketsItemTemplatecount((CHARACTERGUID)_Player,(STRING)_Template,(INTEGER)_Count)
		THEN
		DB_MagicPocketsItemTemplateCount(_Player,_Template,_Count);
		//END_REGION
		
		//REGION Magic Pockets procedures
		QRY
		QryItemInMagicPockets((CHARACTERGUID)_Char,(ITEMGUID)_Item)
		AND
		ItemIsInUserInventory(_Item,_Char,0,1)
		THEN
		DB_NOOP(1);
		
		QRY
		QryItemTemplateInMagicPockets((CHARACTERGUID)_Char,(STRING)_ItemTemplate)
		AND
		ItemTemplateIsInUserInventory(_Char,_ItemTemplate,0,_Count)
		AND
		_Count > 0
		THEN
		DB_NOOP(1);
		
		QRY
		QryTaggedItemInMagicPockets((CHARACTERGUID)_Character,(STRING)_Tag)
		AND
		UserFindTaggedItem(_Character,_Tag,0,_Item)
		THEN
		DB_NOOP(1);
		
		QRY
		QryItemTemplateInMagicPocketsCount((CHARACTERGUID)_Player,(STRING)_Template)
		AND
		ItemTemplateIsInUserInventory(_Player,_Template,0,_Count)
		AND
		_Count > 0
		THEN
		ProcSetMagicPocketsItemTemplatecount(_Player,_Template,_Count);
		
		QRY
		QryRemoveTaggedLocalItemsFromMagicPockets((CHARACTERGUID)_Player,(STRING)_Tag,(INTEGER)_Amount)
		AND
		UserRemoveTaggedLocalItems(_Player,_Tag,_Amount,_Count)
		AND
		_Count == _Amount
		THEN
		DB_NOOP(1);
		
		QRY
		QryTakeItemFromMagicPockets((CHARACTERGUID)_Player,(ITEMGUID)_Item,(CHARACTERGUID)_TargetCharacter)
		AND
		ItemIsInUserInventory(_Item,_Player, 1, 1)
		THEN
		ItemToInventory(_Item,_TargetCharacter);
		
		QRY
		QryTakeItemTemplateFromMagicPockets((CHARACTERGUID)_Character,(STRING)_ItemTemplate,(INTEGER)_Amount,(CHARACTERGUID)_TargetCharacter)
		AND
		ItemTemplateIsInUserInventory(_Character,_ItemTemplate,1,_Amount)
		THEN
		ItemTemplateRemoveFromUser(_ItemTemplate,_Character,_Amount);
		ItemTemplateAddTo(_ItemTemplate,_TargetCharacter,_Amount);
		
		QRY
		QryRemoveItemTemplateFromMagicPockets((CHARACTERGUID)_Character,(STRING)_ItemTemplate,(INTEGER)_Amount)
		AND
		ItemTemplateIsInUserInventory(_Character,_ItemTemplate,1,_HaveAmount)
		AND
		_HaveAmount >= _Amount
		THEN
		ItemTemplateRemoveFromUser(_ItemTemplate,_Character,_Amount);
		
		//TODO: take amount into account
		QRY
		QryRemoveTaggedItemFromMagicPockets((CHARACTERGUID)_Character,(STRING)_Tag, (INTEGER)_Amount)
		AND
		UserFindTaggedItem(_Character,_Tag,1,_Item)
		THEN
		ItemRemove(_Item);
		
		QRY
		QryEvaluateMagicPocketGold((CHARACTERGUID)_Character,"<",(INTEGER)_Amount)
		AND
		UserGetGold(_Character,_Gold)
		AND
		_Gold < _Amount
		THEN
		DB_NOOP(1);
		
		QRY
		QryEvaluateMagicPocketGold((CHARACTERGUID)_Character,"<=",(INTEGER)_Amount)
		AND
		UserGetGold(_Character,_Gold)
		AND
		_Gold <= _Amount
		THEN
		DB_NOOP(1);
		
		QRY
		QryEvaluateMagicPocketGold((CHARACTERGUID)_Character,">",(INTEGER)_Amount)
		AND
		UserGetGold(_Character,_Gold)
		AND
		_Gold > _Amount
		THEN
		DB_NOOP(1);
		
		QRY
		QryEvaluateMagicPocketGold((CHARACTERGUID)_Character,">=",(INTEGER)_Amount)
		AND
		UserGetGold(_Character,_Gold)
		AND
		_Gold >= _Amount
		THEN
		DB_NOOP(1);
		
		QRY
		QryEvaluateMagicPocketGold((CHARACTERGUID)_Character,"==",(INTEGER)_Amount)
		AND
		UserGetGold(_Character,_Gold)
		AND
		_Gold == _Amount
		THEN
		DB_NOOP(1);
		
		PROC
		ProcEvaluateMagicPocketGold((CHARACTERGUID)_Character,"<",(INTEGER)_Amount,(STRING)_ObjectFlag)
		AND
		UserGetGold(_Character,_Gold)
		AND
		_Gold < _Amount
		THEN
		ObjectSetFlag(_Character,_ObjectFlag);
		
		PROC
		ProcEvaluateMagicPocketGold((CHARACTERGUID)_Character,"<=",(INTEGER)_Amount,(STRING)_ObjectFlag)
		AND
		UserGetGold(_Character,_Gold)
		AND
		_Gold <= _Amount
		THEN
		ObjectSetFlag(_Character,_ObjectFlag);
		
		PROC
		ProcEvaluateMagicPocketGold((CHARACTERGUID)_Character,"==",(INTEGER)_Amount,(STRING)_ObjectFlag)
		AND
		UserGetGold(_Character,_Gold)
		AND
		_Gold == _Amount
		THEN
		ObjectSetFlag(_Character,_ObjectFlag);
		
		PROC
		ProcEvaluateMagicPocketGold((CHARACTERGUID)_Character,">",(INTEGER)_Amount,(STRING)_ObjectFlag)
		AND
		UserGetGold(_Character,_Gold)
		AND
		_Gold > _Amount
		THEN
		ObjectSetFlag(_Character,_ObjectFlag);
		
		PROC
		ProcEvaluateMagicPocketGold((CHARACTERGUID)_Character,">=",(INTEGER)_Amount,(STRING)_ObjectFlag)
		AND
		UserGetGold(_Character,_Gold)
		AND
		_Gold >= _Amount
		THEN
		ObjectSetFlag(_Character,_ObjectFlag);
		
		PROC
		ProcAddGoldToMagicPockets((CHARACTERGUID)_Char,(INTEGER)_Gold)
		THEN
		UserAddGold(_Char,_Gold);
		
		PROC
		ProcLaunchMagicPocketIterator((CHARACTERGUID)_Character,(STRING)_Event, (STRING)_CompletionEvent)
		AND
		CharacterGetReservedUserID(_Character,_OwnerUser)
		AND
		DB_IsPlayer(_Player)
		AND
		CharacterGetReservedUserID(_Player,_OwnerUser)
		THEN
		InventoryLaunchIterator(_Player, _Event, "");
		
		PROC
		ProcLaunchMagicPocketIterator((CHARACTERGUID)_Character,(STRING)_Event, (STRING)_CompletionEvent)
		AND
		_CompletionEvent != ""
		THEN
		GlobalSetFlag(_CompletionEvent);
		
		PROC
		ProcLaunchMagicPocketTagIterator((CHARACTERGUID)_Character,(STRING)_TagA,(STRING)_TagB,(STRING)_Event,(STRING)_CompletionEvent)
		AND
		CharacterGetReservedUserID(_Character,_OwnerUser)
		AND
		DB_IsPlayer(_Player)
		AND
		CharacterGetReservedUserID(_Player,_OwnerUser)
		THEN
		InventoryLaunchTagIterator(_Player,_TagA,_TagB,_Event,"");
		
		PROC
		ProcLaunchMagicPocketTagIterator((CHARACTERGUID)_Character,(STRING)_TagA,(STRING)_TagB,(STRING)_Event,(STRING)_CompletionEvent)
		AND
		_CompletionEvent != ""
		THEN
		GlobalSetFlag(_CompletionEvent);
		
		PROC
		ProcSetMagicPocketsOwnershipFlag((CHARACTERGUID)_Char,(STRING)_Flag)
		AND
		DB_IsPlayer(_Char)
		THEN
		UserSetFlag(_Char,_Flag,0);
		
		PROC
		ProcSetMagicPocketsOwnershipFlag((CHARACTERGUID)_Char,(STRING)_Flag)
		AND
		NOT DB_IsPlayer(_Char)
		THEN
		ObjectSetFlag(_Char,_Flag); 
		
		PROC
		ProcClearMagicPocketsOwnershipFlag((CHARACTERGUID)_Char,(STRING)_Flag)
		AND
		DB_IsPlayer(_Char)
		THEN
		UserClearFlag(_Char,_Flag,0);
		
		PROC
		ProcClearMagicPocketsOwnershipFlag((CHARACTERGUID)_Char,(STRING)_Flag)
		AND
		NOT DB_IsPlayer(_Char)
		THEN
		ObjectClearFlag(_Char,_Flag,0); 
		
		//REGION General Give - Take Gold in dialogs
		
		// Usage:
		//   DB_DialogMoneyTransfer(_MoneyVarIndex,_Dialog,_Amount)
		//   DB_DialogMoneyTransfer(_MoneyVarIndex,_Dialog,_Amount,_CheckSpeakerIndex)
		//   DB_DialogMoneyTransfer(_MoneyVarIndex,_Dialog,_Amount,_CheckSpeakerIndex,_TargetDBIndex)
		//
		// Paramters:
		//   - _MoneyVarIndex: 1 - 5 (use different GEN_CheckMagicPocketGold variables)
		//   - _Dialog: name of the dialog
		//   - _Amount: amount of money transfer
		//   - _CheckSpeakerIndex: the speaker index on which the money should be checked by the
		//     GEN_CheckPocketGold* script flags. If not specified, defaults to 2 (player in most cases).
		//      ** NOTE: this Speaker index is a dialog speaker index, as assigned in the dialog
		//   - _TargetDBIndex: when the GEN_TransferNPCPayment/GEN_TransferNPCPayment_2/../GEN_TransferNPCPayment_5 flag
		//     is set on a player in a dialog, transfer the money from that player to DB_DialogNPCs(_ID,_NPC,_TargetDBIndex).
		//     When set on an NPC in a dialog, transfer from that NPC to DB_DialogPlayers(_ID,_Player,_TargetDBIndex).
		//     If not specified, defaults to 1 (first NPC/player in dialog)
		//      ** NOTE: this index is an index in DB_DialogNPCs resp. DB_DialogPlayers, and hence is unrelated to the
		//               the speaker indices in the dialog editor!
		//
		//  If someone does not have enough gold and a transfer is requested, all of their gold will be transferred instead.
		
		//REGION Default speaker to check and target Player/NPC for the money transfer if unspecified
		PROC
		Proc_ItemEvents_DialogMoneyTransfer_New((INTEGER)_MoneyVarIndex,(STRING)_Dialog,(INTEGER)_Amount,(INTEGER)_CheckSpeakerIndex,(INTEGER)_TargetDBIndex)
		AND
		DB_DialogMoneyTransfer(_MoneyVarIndex,_Dialog,_AnyAmount,_AnyCheckSpeakerIndex,_AnyTargetDBIndex)
		THEN
		NOT DB_DialogMoneyTransfer(_MoneyVarIndex,_Dialog,_AnyAmount,_AnyCheckSpeakerIndex,_AnyTargetDBIndex);
		
		PROC
		Proc_ItemEvents_DialogMoneyTransfer_New((INTEGER)_MoneyVarIndex,(STRING)_Dialog,(INTEGER)_Amount,(INTEGER)_CheckSpeakerIndex,(INTEGER)_TargetDBIndex)
		THEN
		DB_DialogMoneyTransfer(_MoneyVarIndex,_Dialog,_Amount,_CheckSpeakerIndex,_TargetDBIndex);
		
		// Default to most common player speaker index (2) and transfer to the first NPC or Player in the dialog (1)
		IF
		DB_DialogMoneyTransfer((INTEGER)_MoneyVarIndex,(STRING)_Dialog,(INTEGER)_Amount)
		THEN
		Proc_ItemEvents_DialogMoneyTransfer_New(_MoneyVarIndex,_Dialog,_Amount,2,1);
		
		IF
		DB_DialogMoneyTransfer((INTEGER)_MoneyVarIndex,(STRING)_Dialog,(INTEGER)_Amount,(INTEGER)_CheckSpeakerIndex)
		THEN
		Proc_ItemEvents_DialogMoneyTransfer_New(_MoneyVarIndex,_Dialog,_Amount,_CheckSpeakerIndex,1);
		//END_REGION
		
		//REGION Transfer gold between player and NPC
		// If the transfer flag is set on a player, transfer from player to NPC. Otherwise vice versa.
		
		PROC
		Proc_GiveNPCGold((CHARACTERGUID)_Player,(CHARACTERGUID)_NPC,(INTEGER)_Amount)
		AND
		IntegerSubtract(0,_Amount,_RemoveGold)
		THEN
		ProcAddGoldToMagicPockets(_Player,_RemoveGold);
		CharacterAddGold(_NPC,_Amount);
		
		PROC
		Proc_TakeNPCGold((CHARACTERGUID)_Player,(CHARACTERGUID)_NPC,(INTEGER)_Amount)
		AND
		IntegerSubtract(0,_Amount,_RemoveGold)
		THEN
		ProcAddGoldToMagicPockets(_Player,_Amount);
		CharacterAddGold(_NPC,_RemoveGold);
		
		PROC
		Proc_ItemEventsTransferMoney((INTEGER)_ID,(INTEGER)_Amount,(CHARACTERGUID)_Source,(INTEGER)_TargetIndex)
		AND
		DB_DialogPlayers(_ID,_Source,_)
		AND
		DB_DialogNPCs(_ID,_NPC,_TargetIndex)
		THEN
		Proc_GiveNPCGold(_Source,(CHARACTERGUID)_NPC,_Amount);
		
		PROC
		Proc_ItemEventsTransferMoney(_ID,_Amount,_Source,_TargetIndex)
		AND
		DB_DialogNPCs(_ID,_Source,_)
		AND
		DB_DialogPlayers(_ID,_Player,_TargetIndex)
		AND
		CharacterGetGold(_Source,_NPCGold)
		AND
		IntegerMin(_NPCGold,_Amount,_TransferAmount)
		THEN
		Proc_TakeNPCGold((CHARACTERGUID)_Player,_Source,_TransferAmount);
		
		IF
		ObjectFlagSet(_TransferFlag,_Source,_ID)
		AND
		DB_ItemEvents_TransferFlagToMoneyVarIndex(_TransferFlag,_MoneyVarIndex)
		AND
		DB_DialogName(_Dialog,_ID)
		AND
		DB_DialogMoneyTransfer(_MoneyVarIndex,_Dialog,_Amount,_CheckSpeakerIndex,_TargetDBIndex)
		THEN
		Proc_ItemEventsTransferMoney(_ID,_Amount,(CHARACTERGUID)_Source,_TargetDBIndex);
		
		//END_REGION
		
		//REGION Reset transfer flag
		IF
		ObjectFlagSet(_TransferFlag,_Char,_ID)
		AND
		DB_ItemEvents_TransferFlagToMoneyVarIndex(_TransferFlag,_)
		THEN
		ObjectClearFlag(_Char,_TransferFlag);
		//END_REGION
		
		//END_REGION
		
		//REGION Has, lose and give items
		IF
		ItemAddedToCharacter(_Item,_Char)
		AND
		DB_HasStoryEvent((ITEMGUID)_Item,_Event)
		THEN
		SetOnStage(_Item,1);
		ProcSetMagicPocketsOwnershipFlag(_Char,_Event);
		
		IF
		ItemRemovedFromCharacter(_Item,_Char)
		AND
		DB_HasStoryEvent((ITEMGUID)_Item,_Event)
		THEN
		ProcClearMagicPocketsOwnershipFlag(_Char,_Event);
		
		IF
		DB_HasStoryEvent((ITEMGUID)_Item,(STRING)_Event)
		AND
		ItemGetOwner(_Item,_Owner)
		AND
		_Owner != NULL_00000000-0000-0000-0000-000000000000
		AND
		ItemIsInCharacterInventory(_Item,_Owner,1)
		THEN
		ProcSetMagicPocketsOwnershipFlag(_Owner,_Event);
		
		IF
		ObjectFlagSet(_Event,_Char,_)
		AND
		DB_GiveItemToEvent((ITEMGUID)_Item,_Event)
		THEN
		ItemToInventory(_Item,_Char,1);
		
		//For giving the same item multiple times
		IF
		ObjectFlagSet(_Event,_Char,_)
		AND
		DB_GiveItemToEventWithClear((ITEMGUID)_Item,_Event)
		THEN
		ItemToInventory(_Item,_Char,1);
		ObjectClearFlag(_Char,_Event,0);
		
		PROC
		Proc_ItemEventCheck()
		AND
		DB_IsPlayer(_Char)
		AND
		DB_HasStoryEvent(_,_Event)
		THEN
		ProcClearMagicPocketsOwnershipFlag(_Char,_Event);
		
		PROC
		Proc_ItemEventCheck()
		AND
		DB_HasStoryEvent((ITEMGUID)_Item,_Event)
		AND
		ObjectExists(_Item,1)
		AND
		ItemIsInInventory(_Item,1)
		AND
		ItemGetOwner(_Item,_Char)
		AND
		DB_IsPlayer(_Char)
		THEN
		ProcSetMagicPocketsOwnershipFlag(_Char,_Event);
		
		//END_REGION
		
		//REGION Check for Tagged Items in Characters Inventory
		//If You want to Keep track of a specific Item tag going in and out of the inventory, add that tag to DB_TaggedItemTracker(_String)
		
		IF
		ItemAddedToCharacter(_Item,_Char)
		AND
		ObjectExists(_Item,1)		//prevent stacked items from asserting all over the place
		AND
		DB_TaggedItemTracker((STRING)_Tag)
		AND
		IsTagged(_Item,_Tag,1)
		AND
		StringConcatenate("Has_TaggedItem_",_Tag,_Flag)
		THEN
		ProcSetMagicPocketsOwnershipFlag(_Char,_Flag);
		DB_HasTaggedItem(_Char,_Item,_Tag,_Flag);
		
		IF
		DB_TaggedItemInitialSetup(1)
		THEN
		DB_TaggedItemRecheck(1);
		
		IF
		DB_TaggedItemRecheck(1)
		AND
		NOT DB_TaggedItemInitialSetup(1)
		THEN
		NOT DB_TaggedItemRecheck(1);
		ProcCheckItemTags();
		
		PROC
		ProcCheckItemTags()
		AND
		DB_IsPlayer(_Player)
		AND
		DB_TaggedItemTracker(_Tag)
		THEN
		DB_ItemTagCheckingPlayer((CHARACTERGUID)_Player,_Tag);
		InventoryLaunchTagIterator(_Player,_Tag,"","_Check_Item_Tags_","");
		FireOsirisEvents();
		NOT DB_ItemTagCheckingPlayer(_Player,_Tag);
		
		IF
		StoryEvent((ITEMGUID)_Item,"_Check_Item_Tags_")
		AND
		DB_ItemTagCheckingPlayer(_Player,_Tag)
		AND
		StringConcatenate("Has_TaggedItem_",_Tag,_Flag)
		THEN
		ProcSetMagicPocketsOwnershipFlag(_Player,_Flag);
		DB_HasTaggedItem(_Player,_Item,_Tag,_Flag);
		
		IF
		DB_TaggedItemTracker(_Tag)
		AND
		NOT DB_TaggedItemInitialSetup(1)
		THEN
		ProcCheckInventoriesForTag(_Tag);
		
		PROC
		ProcCheckInventoriesForTag((STRING)_Tag)
		AND
		DB_IsPlayer(_Player)
		THEN
		DB_ItemTagCheckingPlayer(_Player,_Tag);
		InventoryLaunchTagIterator(_Player,_Tag,"","_Check_Item_Tag_","");
		FireOsirisEvents();
		NOT DB_ItemTagCheckingPlayer(_Player,_Tag);
		
		IF
		StoryEvent((ITEMGUID)_Item, "_Check_Item_Tag_")
		AND
		DB_ItemTagCheckingPlayer(_Char,_Tag)
		AND
		StringConcatenate("Has_TaggedItem_",_Tag,_Flag)
		THEN
		ProcSetMagicPocketsOwnershipFlag(_Char,_Flag);
		DB_HasTaggedItem(_Char,_Item,_Tag,_Flag);
		
		
		IF
		ItemStackedWith(_Item,_)
		AND
		DB_HasTaggedItem(_Char,_Item,_String,_Flag)
		THEN
		NOT DB_HasTaggedItem(_Char,_Item,_String,_Flag);
		
		IF
		ItemRemovedFromCharacter(_Item,_Char)
		AND
		DB_HasTaggedItem((CHARACTERGUID)_Char,_Item,_String,_Flag)
		THEN
		NOT DB_HasTaggedItem(_Char,_Item,_String,_Flag);
		Proc_CheckForItemTagInMagicPockets(_Char,_String);
		
		PROC
		Proc_CheckForItemTagInMagicPockets((CHARACTERGUID)_Char,(STRING)_Tag)
		AND
		NOT QryTaggedItemInMagicPockets(_Char,_Tag)
		AND
		StringConcatenate("Has_TaggedItem_",_Tag,_Flag)
		THEN
		ProcClearMagicPocketsOwnershipFlag(_Char,_Flag);
		
		PROC
		Proc_ItemEventCheck()
		AND
		DB_HasTaggedItem(_,_,_Tag,_Flag)
		AND
		DB_IsPlayer(_Char)
		THEN
		ProcClearMagicPocketsOwnershipFlag(_Char,_Flag);
		
		IF
		RegionStarted(_)
		AND
		DB_HasTaggedItem(_Char,_Item,_Tag,_Flag)
		AND
		ObjectExists(_Char,0)
		THEN
		NOT DB_HasTaggedItem(_Char,_Item,_Tag,_Flag);
		
		PROC
		Proc_ItemEventCheck()
		AND
		DB_HasTaggedItem(_Char,_Item,_Tag,_Flag)
		THEN
		ProcSetMagicPocketsOwnershipFlag(_Char,_Flag);
		
		//END_REGION
		
		
		//REGION On item template on gain and lose
		//DB_HasTemplateItem((STRING)_template,(STRING)_HasItemFlag)
		//If item is added to inventory
		IF
		ItemTemplateAddedToCharacter(_templateGUID,_item,_char)
		AND
		String(_templateGUID,_template)
		AND
		DB_HasTemplateItem((STRING)_template,(STRING)_flag)
		THEN
		Proc_OnAddItemTemplateToChar(_char,_template,_flag);
		
		//If item is removed from inventory
		IF
		ItemTemplateRemovedFromCharacter(_template,_item,_char)
		AND
		DB_HasTemplateItem((STRING)_template,(STRING)_flag)
		THEN
		Proc_OnRemoveItemTemplateFromChar(_char,_template,_flag);
		
		IF
		DB_HasTemplateItem((STRING)_template,(STRING)_flag)
		AND
		DB_IsPlayer(_Player)
		THEN
		Proc_OnAddItemTemplateToChar(_Player,_template,_flag);
		
		PROC
		Proc_ItemEventCheck()
		AND
		DB_HasTemplateItem((STRING)_template,(STRING)_flag)
		AND
		DB_IsPlayer(_Player)
		THEN
		ProcClearMagicPocketsOwnershipFlag(_Player,_flag);
		Proc_OnAddItemTemplateToChar(_Player,_template,_flag);
		
		//Proc on template add
		PROC
		Proc_OnAddItemTemplateToChar((CHARACTERGUID)_char,(STRING)_template,(STRING)_flag)
		AND
		ItemTemplateIsInUserInventory(_char,_template,0,_amount)
		AND
		_amount > 0
		THEN
		ProcSetMagicPocketsOwnershipFlag(_char,_flag);
		
		//Proc on template remove
		PROC
		Proc_OnRemoveItemTemplateFromChar((CHARACTERGUID)_char,(STRING)_template,(STRING)_flag)
		AND
		ItemTemplateIsInUserInventory(_char,_template,0,_amount)
		AND
		_amount < 1
		THEN
		ProcClearMagicPocketsOwnershipFlag(_char,_flag);
		
		//END_REGION
		
		//REGION Give/remove Item template
		//Gives item when flag is set
		IF
		ObjectFlagSet(_event,(CHARACTERGUID)_target,_inst)
		AND
		DB_GiveTemplateFromPlayerDialogEvent((STRING)_template,(STRING)_event,(STRING)_success)
		AND
		DialogGetInvolvedPlayer(_inst, 1, (CHARACTERGUID)_player)
		THEN
		ObjectClearFlag(_target,_event,0); //Flag is cleared again
		Proc_PlayerGivesItemFromTemplate(_player,_target,_template,_success);
		
		
		//Gives item when flag is set
		IF
		ObjectFlagSet(_event,(CHARACTERGUID)_target,_inst)
		AND
		DB_GiveTemplateFromNpcToPlayerDialogEvent((STRING)_template,(STRING)_event,(STRING)_success)
		AND
		DialogGetInvolvedPlayer(_inst, 1, (CHARACTERGUID)_player)
		THEN
		ObjectClearFlag(_target,_event,0); //Flag is cleared again
		Proc_NPCGivesItemFromTemplate(_target,_player,_template,_success);
		
		
		//Gives item when flag is set
		IF
		ObjectFlagSet(_event,_char,_)
		AND
		DB_GiveNewItemFromTemplateEvent((STRING)_template,(STRING)_event)
		THEN
		ObjectClearFlag((CHARACTERGUID)_char,(STRING)_event,0); //Flag is cleared again
		ItemTemplateAddTo(_template,_char,1);
		
		
		//Remove item when flag set
		IF
		ObjectFlagSet(_event,(CHARACTERGUID)_char,_)
		AND
		DB_RemoveItemFromTemplateEvent((STRING)_template,(STRING)_event,(STRING)_success)
		THEN
		ObjectClearFlag(_char,_event,0); //Flag is cleared again
		Proc_RemoveItemFromTemplate(_char,_template,_success);
		
		//END_REGION
		
		//REGION Give/Remove Template Proc
		//Giving Item
		PROC
		Proc_PlayerGivesItemFromTemplate((CHARACTERGUID)_Player,(CHARACTERGUID)_target,(STRING)_template,(STRING)_success)
		AND
		QryRemoveItemTemplateFromMagicPockets(_Player,_Template,1)
		THEN
		ItemTemplateAddTo(_template,_target,1);
		ObjectSetFlag(_target,_success);
		
		//Mirrored Give to set _success on NPC instead of player
		PROC
		Proc_NPCGivesItemFromTemplate((CHARACTERGUID)_giver,(CHARACTERGUID)_target,(STRING)_template,(STRING)_success)
		AND
		ItemTemplateIsInCharacterInventory(_giver,_template,_amount)
		AND
		_amount > 0
		THEN
		ItemTemplateRemoveFrom(_template,_giver,1);
		ItemTemplateAddTo(_template,_target,1);
		ObjectSetFlag(_giver,_success);
		
		//Remove Item
		PROC
		Proc_RemoveItemFromTemplate((CHARACTERGUID)_char,(STRING)_template,(STRING)_success)
		AND
		DB_IsPlayer(_Char)
		AND
		QryRemoveItemTemplateFromMagicPockets(_char,_template,1)
		THEN
		ObjectSetFlag(_char,_success);
		
		PROC
		Proc_RemoveItemFromTemplate((CHARACTERGUID)_char,(STRING)_template,(STRING)_success)
		AND
		NOT DB_IsPlayer(_Char)
		AND
		ItemTemplateIsInCharacterInventory(_char,_template,_amount)
		AND
		_amount > 0
		THEN
		ItemTemplateRemoveFrom(_template,_char,1);
		ObjectSetFlag(_char,_success);
		//END_REGION
		
		IF
		DialogEnded(_,_ID)
		AND
		DialogGetInvolvedNPC(_ID,1,(ITEMGUID)_Item)
		AND
		ObjectIsItem(_Item,1)
		AND
		ObjectGetFlag(_Item,"ItemPickup",1)
		AND
		DialogGetInvolvedPlayer(_ID,1,(CHARACTERGUID)_Player)
		THEN
		CharacterPickupItem(_Player,_Item,"");
		ObjectClearFlag(_Item,"ItemPickup",0);
		
		//REGION Play Activate animation from Script
		
		IF
		StoryEvent((CHARACTERGUID)_Player,"GEN_Animation_Activate")
		THEN
		PlayAnimation(_Player,"use_activate");
		
		//END_REGION
		
		
		
	}
	EXIT
	{
		
	}
}
Goal(25).Title("_Global_JournalHelper");
Goal(25)
{
	INIT
	{
		
	}
	KB
	{
		//REGION Init
		
		PROC
		ProcCheckDefaultQuestAdd((STRING)_QuestName)
		AND
		NOT DB_QuestDef_AddEvent(_QuestName,_)
		AND
		StringConcatenate("QuestAdd_",_QuestName,_AddEvent)
		THEN
		DB_QuestDef_AddEvent(_QuestName,_AddEvent);
		
		PROC
		ProcCheckDefaultQuestClose((STRING)_QuestName)
		AND
		NOT DB_QuestDef_CloseEvent(_QuestName,_)
		AND
		StringConcatenate("QuestClose_",_QuestName,_CloseEvent)
		THEN
		DB_QuestDef_CloseEvent(_QuestName,_CloseEvent);
		
		IF
		DB_QuestDef_State((STRING)_QuestName,(STRING)_QuestState, 1) //Indices allow you to define multiple start and end events for every quest.
		AND
		StringConcatenate("QuestUpdate_",_QuestName,_String1)
		AND
		StringConcatenate(_String1,"_",_String2)
		AND
		StringConcatenate(_String2,_QuestState,_AddEvent)
		THEN
		DB_QuestDef_AddEvent(_QuestName,_AddEvent);
		DB_QuestDef_State((STRING)_QuestName,(STRING)_QuestState);
		
		IF
		DB_QuestDef_State((STRING)_QuestName,(STRING)_QuestState, -1)
		AND
		StringConcatenate("QuestUpdate_",_QuestName,_String1)
		AND
		StringConcatenate(_String1,"_",_String2)
		AND
		StringConcatenate(_String2,_QuestState,_CloseEvent)
		THEN
		DB_QuestDef_CloseEvent(_QuestName,_CloseEvent);
		DB_QuestDef_State((STRING)_QuestName,(STRING)_QuestState);
		
		IF
		DB_QuestDef_State((STRING)_QuestName,(STRING)_QuestState)
		AND
		NOT DB_QuestDef_UpdateEvent(_QuestName,_QuestState, _)
		AND
		StringConcatenate("QuestUpdate_",_QuestName,_String1)
		AND
		StringConcatenate(_String1,"_",_String2)
		AND
		StringConcatenate(_String2,_QuestState,_UpdateEvent)
		THEN
		ProcCheckDefaultQuestAdd(_QuestName);
		ProcCheckDefaultQuestClose(_QuestName);
		DB_QuestDef_UpdateEvent(_QuestName,_QuestState,_UpdateEvent);
		//END_REGION
		
		//REGION Unlocking quests
		IF
		ObjectFlagSet(_QuestAddEvent,(CHARACTERGUID)_Player, _)
		AND
		DB_QuestDef_AddEvent(_QuestName,_QuestAddEvent)
		AND
		DB_IsPlayer(_Player)
		THEN
		QuestAdd(_Player,_QuestName);
		DB_ActivatedQuests(_QuestName);
		ProcSetQuestNPCFlag(_QuestName,_QuestAddEvent);
		ProcCheckMigrateQuestAddFlag(_Player,_QuestName,_QuestAddEvent);
		
		//don't migrate quest add flags that also trigger an update, since we'll be trying ot share the update already before the original player
		//had a chance to get the update
		PROC
		ProcCheckMigrateQuestAddFlag((CHARACTERGUID)_Player,(STRING)_QuestName,(STRING)_QuestAddEvent)
		AND
		NOT DB_QuestDef_UpdateEvent(_QuestName,_,_QuestAddEvent)
		THEN
		ProcMigrateQuestFlag(_Player,_QuestName,_QuestAddEvent);
		
		IF
		ObjectFlagSet(_QuestUpdateEvent,(CHARACTERGUID)_Player, _)
		AND
		DB_QuestDef_UpdateEvent(_QuestName,_QuestState,_QuestUpdateEvent)
		AND
		DB_IsPlayer(_Player)
		AND
		QuestIsClosed(_Player,_QuestName,0)
		THEN
		QuestUpdate(_Player,_QuestName,_QuestState);
		ProcMigrateQuestFlag(_Player,_QuestName,_QuestUpdateEvent);
		ProcSetQuestNPCFlag(_QuestName,_QuestUpdateEvent);
		
		IF
		ObjectFlagSet(_QuestCloseEvent,(CHARACTERGUID)_Player, _)
		AND
		DB_QuestDef_CloseEvent(_QuestName,_QuestCloseEvent)
		AND
		DB_IsPlayer(_Player)
		THEN
		QuestClose(_Player,_QuestName);
		ProcMigrateQuestFlag(_Player,_QuestName,_QuestCloseEvent);
		ProcSetQuestNPCFlag(_QuestName,_QuestCloseEvent);
		
		PROC
		ProcSetQuestNPCFlag((STRING)_QuestName,(STRING)_QuestEvent)
		AND
		DB_QuestNPC(_QuestName,(CHARACTERGUID)_NPC)
		THEN
		ObjectSetFlag(_NPC,_QuestEvent,0);
		
		
		//END_REGION
		
		//REGION Merging quests
		
		IF
		CharacterMadePlayer(_Player)
		THEN
		DB_JournalIgnoreReservedChanged(_Player);
		
		IF
		CharacterReservedUserIDChanged(_Char,_NewUser)
		AND
		DB_IsPlayer(_Char)
		AND
		NOT DB_JournalIgnoreReservedChanged(_Char)
		THEN
		ProcMigrateQuestsForUser(_NewUser,_Char);
		
		IF
		CharacterReservedUserIDChanged(_Char,_)
		THEN
		NOT DB_JournalIgnoreReservedChanged(_Char);
		
		IF
		CharacterJoinedParty(_Joiner)
		AND
		DB_IsPlayer(_Joiner)
		AND
		DB_ActivatedQuests(_Quest)
		THEN
		ProcMigrateQuest(_Joiner,_Quest);
		
		IF
		CharacterJoinedParty(_Joiner)
		AND
		DB_IsPlayer(_Joiner)
		AND
		DB_IsPlayer(_Player)
		AND
		NOT DB_MigratedNewPartyFlags(1)
		AND
		_Player != _Joiner
		AND
		CharacterIsInPartyWith(_Player,_Joiner,1)
		AND
		DB_ActivatedQuests(_Quest)
		AND
		DB_SharedQuestFlag(_Player,_Quest,_QuestFlag)
		THEN
		DB_MigratedNewPartyFlags(1);
		ProcShareQuestflagWith(_Player,_Quest,_QuestFlag,_Joiner);
		
		//always share quests with the owning user
		IF
		CharacterJoinedParty(_Joiner)
		AND
		DB_IsPlayer(_Joiner)
		AND
		CharacterGetReservedUserID(_Joiner,_User)
		THEN
		ProcMigrateQuestsForUser(_User,_Joiner);
		
		//handle the case where an MP savegame is loaded in SP
		IF
		SavegameLoaded(_,_,_,_)
		AND
		DB_IsPlayer(_Joiner)
		AND
		CharacterGetReservedUserID(_Joiner,_User)
		THEN
		ProcMigrateQuestsForUser(_User,_Joiner);
		
		PROC
		ProcMigrateQuestsForUser((INTEGER)_User,(CHARACTERGUID)_Joiner)
		AND
		DB_IsPlayer(_Other)
		AND
		CharacterGetReservedUserID(_Other,_User)
		AND
		DB_ActivatedQuests(_Quest)
		AND
		QuestGetBroadcastLevel(_Quest,_Level)
		AND
		_Level != "Character"
		AND
		DB_PrivateQuestFlag(_Other,_Quest,_QuestFlag)
		THEN
		ProcShareQuestflagWith(_Other,_Quest,_QuestFlag,_Joiner);
		
		IF
		CharacterJoinedParty(_)
		THEN
		NOT DB_MigratedNewPartyFlags(1);
		
		IF
		QuestShared(_SrcCharacter,"",1)
		AND
		DB_IsPlayer(_SrcCharacter)
		AND
		DB_ActivatedQuests(_Quest)
		THEN
		ProcMigrateQuest(_SrcCharacter,_Quest);
		
		IF
		QuestShared(_SrcCharacter,_Quest,1)
		AND
		_Quest != ""
		THEN
		ProcMigrateQuestFlagsFor(_SrcCharacter,_Quest);
		
		PROC
		ProcMigrateQuest((CHARACTERGUID)_SrcPlayer,(STRING)_Quest)
		AND
		QuestAccepted(_SrcPlayer,_Quest,1)
		AND
		QuestIsShared(_SrcPlayer,_Quest,1)
		THEN
		ProcMigrateQuestFlagsFor(_SrcPlayer,_Quest);
		
		PROC
		ProcMigrateQuestFlagsFor((CHARACTERGUID)_SrcPlayer,(STRING)_Quest)
		AND
		DB_PrivateQuestFlag(_SrcPlayer,_Quest,_QuestFlag)
		THEN
		DB_SharedQuestFlag(_SrcPlayer,_Quest,_QuestFlag);
		NOT DB_PrivateQuestFlag(_SrcPlayer,_Quest,_QuestFlag);
		
		PROC
		ProcMigrateQuestFlagsFor((CHARACTERGUID)_SrcChar,(STRING)_Quest)
		AND
		DB_SharedQuestFlag(_SrcChar,_Quest,_QuestFlag)
		THEN
		ProcShareQuestFlag(_SrcChar,_Quest,_QuestFlag);
		
		PROC
		ProcShareQuestFlag((CHARACTERGUID)_SrcPlayer,(STRING)_Quest,(STRING)_QuestFlag)
		AND
		DB_IsPlayer(_Player)
		AND
		_Player!=_SrcPlayer
		AND
		CharacterIsInPartyWith(_Player,_SrcPlayer,1)
		AND			
		ObjectGetFlag(_Player,_QuestFlag,0)	//checked for when story gives the flag to several players in a row. Otherwise you won't have a chance to give the update in case someone shares the quest
		THEN
		ProcShareQuestflagWith(_SrcPlayer,_Quest,_QuestFlag,_Player);
		
		PROC
		ProcShareQuestflagWith((CHARACTERGUID)_SrcPlayer,(STRING)_Quest,(STRING)_QuestFlag,(CHARACTERGUID)_Player)
		THEN
		ProcStoreFlagState(_Player,_QuestFlag);
		ProcShareQuestUpdate(_SrcPlayer,_Quest,_QuestFlag,_Player);
		ObjectShareFlag(_Player,_QuestFlag);
		ProcStoreSharedQuestFlag(_SrcPlayer,_Quest,_QuestFlag,_Player);
		ProcVerifyFlagState(_SrcPlayer,_Player,_QuestFlag);
		
		PROC
		ProcStoreSharedQuestFlag((CHARACTERGUID)_SrcPlayer,(STRING)_Quest,(STRING)_QuestFlag,(CHARACTERGUID)_Player)
		AND
		DB_SharedQuestFlag(_SrcPlayer,_Quest,_QuestFlag)
		THEN
		DB_SharedQuestFlag(_Player,_Quest,_QuestFlag);
		
		PROC
		ProcStoreSharedQuestFlag((CHARACTERGUID)_SrcPlayer,(STRING)_Quest,(STRING)_QuestFlag,(CHARACTERGUID)_Player)
		AND
		DB_PrivateQuestFlag(_SrcPlayer,_Quest,_QuestFlag)
		THEN
		DB_PrivateQuestFlag(_Player,_Quest,_QuestFlag);
		
		PROC
		ProcShareQuestUpdate((CHARACTERGUID)_SrcPlayer,(STRING)_Quest,(STRING)_QuestFlag,(CHARACTERGUID)_Player)
		AND
		QuestAccepted(_SrcPlayer,_Quest,1)
		AND
		QuestAccepted(_Player,_Quest,0)
		THEN
		QuestAdd(_Player,_Quest);
		ProcMigrateQuestFlagsFor(_Player,_Quest);
		
		PROC
		ProcShareQuestUpdate((CHARACTERGUID)_SrcPlayer,(STRING)_Quest,(STRING)_QuestFlag,(CHARACTERGUID)_Player)
		AND
		DB_QuestDef_UpdateEvent(_Quest,_QuestState,_QuestFlag)
		AND
		QuestHasUpdate(_SrcPlayer,_Quest,_QuestState,1)
		THEN
		QuestReceiveSharedUpdate(_SrcPlayer,_Player,_Quest,_QuestState);
		
		PROC
		ProcShareQuestUpdate((CHARACTERGUID)_SrcPlayer,(STRING)_Quest,(STRING)_QuestFlag,(CHARACTERGUID)_Player)
		AND
		DB_QuestDef_CloseEvent(_Quest,_QuestFlag)
		THEN
		QuestClose(_Player,_Quest);
		
		PROC
		ProcMigrateQuestFlag((CHARACTERGUID)_SrcPlayer,(STRING)_Quest,(STRING)_QuestFlag)
		AND
		QuestIsShared(_SrcPlayer,_Quest,0)
		THEN
		DB_PrivateQuestFlag(_SrcPlayer,_Quest,_QuestFlag);
		ProcSharePrivateFlags(_SrcPlayer,_Quest,_QuestFlag);
		
		PROC
		ProcMigrateQuestFlag((CHARACTERGUID)_SrcPlayer,(STRING)_Quest,(STRING)_QuestFlag)
		AND
		QuestIsShared(_SrcPlayer,_Quest,1)
		THEN
		DB_SharedQuestFlag(_SrcPlayer,_Quest,_QuestFlag);
		ProcShareQuestFlag(_SrcPlayer,_Quest,_QuestFlag);
		
		PROC
		ProcSharePrivateFlags((CHARACTERGUID)_SrcPlayer,(STRING)_Quest,(STRING)_QuestFlag)
		AND
		QuestGetBroadcastLevel(_Quest,"User")
		AND
		CharacterGetReservedUserID(_SrcPlayer,_User)
		AND
		DB_IsPlayer(_Char)
		AND
		_Char != _SrcPlayer
		AND
		CharacterGetReservedUserID(_Char,_User)
		THEN
		DB_PrivateQuestFlag(_SrcPlayer,_Quest,_QuestFlag);
		ObjectShareFlag(_Char,_QuestFlag);
		
		PROC
		ProcStoreFlagState((CHARACTERGUID)_Player,(STRING)_QuestFlag)
		AND
		ObjectGetFlag(_Player,_Questflag,_State)
		THEN
		DB_TargetQuestFlagState(_Player,_QuestFlag,_State);
		
		//if a quest flag was cleared and we didn't have it set before sharing clear it as well
		//this will make flags couple to inventory events work correctly
		PROC
		ProcVerifyFlagState((CHARACTERGUID)_SrcPlayer,(CHARACTERGUID)_Player,(STRING)_QuestFlag)
		AND
		ObjectGetFlag(_SrcPlayer,_Questflag,0)
		AND
		DB_TargetQuestFlagState(_Player,_QuestFlag,0)
		THEN
		ObjectClearFlag(_Player,_QuestFlag,0);
		
		PROC
		ProcVerifyFlagState((CHARACTERGUID)_SrcPlayer,(CHARACTERGUID)_Player,(STRING)_QuestFlag)
		AND
		ObjectGetFlag(_SrcPlayer,_Questflag,1)
		AND
		DB_HasStoryEvent((ITEMGUID)_Item,_Questflag)
		AND
		NOT QryItemInMagicPockets(_Player,_Item)
		THEN
		ObjectClearFlag(_Player,_QuestFlag,0);
		
		PROC
		ProcVerifyFlagState((CHARACTERGUID)_SrcPlayer,(CHARACTERGUID)_Player,(STRING)_QuestFlag)
		AND
		ObjectGetFlag(_SrcPlayer,_Questflag,1)
		AND
		DB_HasTemplateItem(_Template,_Questflag)
		AND
		NOT QryItemTemplateInMagicPockets(_Player,_Template)
		THEN
		ObjectClearFlag(_Player,_QuestFlag,0);
		
		//TODO: this does not handle events outside of the DB_HasStoryEvent or the TaggedItemTracker
		
		PROC
		ProcVerifyFlagState(_,_Player,_QuestFlag)
		AND
		DB_TargetQuestFlagState(_Player,_QuestFlag,_State)
		THEN
		NOT DB_TargetQuestFlagState(_Player,_QuestFlag,_State);
		//END_REGION
		
		PROC
		ProcSetFlagOnAll((STRING)_Flag)
		AND
		DB_IsPlayer(_Player)
		THEN
		ObjectSetFlag(_Player,_Flag);
		
		//REGION end of region
		
		PROC
		ProcRegionEnded(_Region)
		AND
		DB_QuestDef_CloseAtRegionEnded((STRING)_Quest,(STRING)_Flag,(STRING)_Region)
		AND
		DB_IsPlayer(_Char)
		AND
		QuestAccepted(_Char,_Quest,1)
		THEN
		ObjectSetFlag(_Char,_Flag);
		QuestArchive(_Char,_Quest,1);
		
		PROC
		ProcRegionEnded(_Region)
		AND
		DB_QuestDef_CloseAtRegionEnded_Conditions_FalseGlobalFlag_TrueObjFlag((STRING)_Quest,(STRING)_SetFlag,_Region,(STRING)_GloFlag,(STRING)_ObjFlag)
		AND
		GlobalGetFlag(_GloFlag,0)
		AND
		DB_IsPlayer(_Char)
		AND
		QuestAccepted(_Char,_Quest,1)
		AND
		UserGetFlag(_Char,_ObjFlag,1)
		AND
		ObjectGetFlag(_Char,_SetFlag,0)
		THEN
		ObjectSetFlag(_Char,_SetFlag);
		QuestArchive(_Char,_Quest,1);
		
		PROC
		ProcRegionEnded(_Region)
		AND
		DB_QuestDef_CloseAtRegionEnded_Conditions_FalseGlobalFlag_FalseObjFlag((STRING)_Quest,(STRING)_SetFlag,_Region,(STRING)_GloFlag,(STRING)_ObjFlag)
		AND
		GlobalGetFlag(_GloFlag,0)
		AND
		DB_IsPlayer(_Char)
		AND
		QuestAccepted(_Char,_Quest,1)
		AND
		UserGetFlag(_Char,_ObjFlag,0)
		AND
		ObjectGetFlag(_Char,_SetFlag,0)
		THEN
		ObjectSetFlag(_Char,_SetFlag);
		QuestArchive(_Char,_Quest,1);
		
		PROC
		ProcRegionEnded(_Region)
		AND
		DB_QuestDef_CloseAtRegionEnded_Condition_FalseGlobalFlag_OrClose((STRING)_Quest,(STRING)_SetFlag,_Region,(STRING)_GlobalFlag)
		AND
		DB_IsPlayer(_Char)
		AND
		QuestAccepted(_Char,_Quest,1)
		AND
		GlobalGetFlag(_GlobalFlag,0)
		THEN
		ObjectSetFlag(_Char,_SetFlag);
		QuestArchive(_Char,_Quest,1);
		
		PROC
		ProcRegionEnded(_Region)
		AND
		DB_QuestDef_CloseAtRegionEnded_Condition_FalseGlobalFlag_OrClose((STRING)_Quest,(STRING)_SetFlag,_Region,(STRING)_GlobalFlag)
		AND
		DB_IsPlayer(_Char)
		AND
		QuestAccepted(_Char,_Quest,1)
		AND
		GlobalGetFlag(_GlobalFlag,1)
		THEN
		QuestClose(_Char,_Quest);
		QuestArchive(_Char,_Quest,1);
		
		PROC
		ProcRegionEnded(_Region)
		AND
		DB_QuestDef_CloseAtRegionEnded_Condition_FalseGlobalFlag((STRING)_Quest,(STRING)_SetFlag,_Region,(STRING)_GlobalFlag)
		AND
		DB_IsPlayer(_Char)
		AND
		QuestAccepted(_Char,_Quest,1)
		AND
		GlobalGetFlag(_GlobalFlag,0)
		THEN
		ObjectSetFlag(_Char,_SetFlag);
		QuestArchive(_Char,_Quest,1);
		
		PROC
		ProcRegionEnded(_Region)
		AND
		DB_QuestDef_CloseAtRegionEnded_Condition_TrueGlobalFlag((STRING)_Quest,(STRING)_SetFlag,_Region,(STRING)_GlobalFlag)
		AND
		DB_IsPlayer(_Char)
		AND
		QuestAccepted(_Char,_Quest,1)
		AND
		GlobalGetFlag(_GlobalFlag,1)
		THEN
		ObjectSetFlag(_Char,_SetFlag);
		QuestArchive(_Char,_Quest,1);
		
		
		PROC
		ProcRegionEnded(_Region)
		AND
		DB_QuestDef_CloseAtRegionEnded_Conditions_FalseObjFlag((STRING)_Quest,(STRING)_SetFlag,_Region,(STRING)_ObjFlag)
		AND
		DB_IsPlayer(_Char)
		AND
		QuestAccepted(_Char,_Quest,1)
		AND
		UserGetFlag(_Char,_ObjFlag,0)
		AND
		ObjectGetFlag(_Char,_SetFlag,0)
		THEN
		ObjectSetFlag(_Char,_SetFlag);
		QuestArchive(_Char,_Quest,1);
		
		PROC
		ProcRegionEnded(_Region)
		AND
		DB_QuestDef_CloseAtRegionEnded_Conditions_TrueObjFlag((STRING)_Quest,(STRING)_SetFlag,_Region,(STRING)_ObjFlag)
		AND
		DB_IsPlayer(_Char)
		AND
		QuestAccepted(_Char,_Quest,1)
		AND
		UserGetFlag(_Char,_ObjFlag,1)
		AND
		ObjectGetFlag(_Char,_SetFlag,0)
		THEN
		ObjectSetFlag(_Char,_SetFlag);
		QuestArchive(_Char,_Quest,1);
		
		PROC
		ProcRegionEnded(_Region)
		AND
		DB_QuestDef_CloseAtRegionEnded_Conditions_FalseObjFlag_TrueObjFlag((STRING)_Quest,(STRING)_SetFlag,_Region,(STRING)_FalseObjFlag,(STRING)_TrueObjFlag)
		AND
		DB_IsPlayer(_Char)
		AND
		QuestAccepted(_Char,_Quest,1)
		AND
		UserGetFlag(_Char,_FalseObjFlag,0)
		AND
		UserGetFlag(_Char,_TrueObjFlag,1)
		AND
		ObjectGetFlag(_Char,_SetFlag,0)
		THEN
		ObjectSetFlag(_Char,_SetFlag);
		QuestArchive(_Char,_Quest,1);
		
		/*
		PROC
		ProcRegionEnded(_Region)
		AND
		DB_QuestDef_CloseAtRegionEnded_Conditions_FalseObjFlag_FalseObjFlag(_Quest,_SetFlag,_Region,_FalseObjFlag1,_FalseObjFlag2)
		AND
		DB_IsPlayer(_Char)
		AND
		QuestAccepted(_Char,_Quest,1)
		AND
		UserGetFlag(_Char,_FalseObjFlag1,0)
		AND
		UserGetFlag(_Char,_FalseObjFlag2,0)
		AND
		ObjectGetFlag(_Char,_SetFlag,0)
		THEN
		ObjectSetFlag(_Char,_SetFlag);
		QuestArchive(_Char,_Quest,1);
		*/
		
		//END_REGION
		
		//REGION set category on region started
		
		PROC
		ProcRegionStarted((STRING)_Region)
		AND
		DB_RegionQuestCategory(_Region,(STRING)_Category)
		AND
		DB_RegionQuestCategory_Swapped((STRING)_Quest)
		THEN
		ProcQuestSetCategory(_Quest,_Category);
		
		
		PROC
		ProcQuestSetCategory((STRING)_Quest,(STRING)_Category)
		AND
		DB_IsPlayer(_Char)
		AND
		QuestIsClosed(_Char,_Quest,0)
		THEN
		QuestSetCategory(_Quest,_Category);
		ProcQuestCategorySet(_Quest,_Category,_Char);
		
		
		PROC
		ProcQuestCategorySet((STRING)_Quest,(STRING)_Category,(CHARACTERGUID)_Char)
		THEN
		DB_NOOP(1);
		
		//END_REGION
		
		//REGION QuestReward
		
		IF
		ObjectFlagSet(_Flag,(CHARACTERGUID)_Player,_Inst)
		AND
		DB_IsPlayer(_Player)
		AND
		DB_QuestDef_QuestReward((STRING)_Quest,(STRING)_RewardState,_Flag)
		AND
		QuestAccepted(_Player,_Quest,1)
		AND
		_Inst != 0
		THEN
		DB_GiveQuestRewardAfterDialog(_Player,_Quest,_RewardState,_Inst);
		
		IF
		DialogEnded(_,_Inst)
		AND
		DB_GiveQuestRewardAfterDialog(_Player,_Quest,_RewardState,_Inst)
		THEN
		ProcGiveQuestReward(_Player,_Quest,_RewardState);
		NOT DB_GiveQuestRewardAfterDialog(_Player,_Quest,_RewardState,_Inst);
		
		PROC
		ProcGiveQuestReward((CHARACTERGUID)_Player,(STRING)_Quest,(STRING)_RewardState)
		AND
		NOT DB_QuestRewardGiven(_Player,_Quest,_RewardState)
		THEN
		CharacterGiveQuestReward(_Player,_Quest,_RewardState);
		ProcMarkPartyAsGivenReward(_Player,_Quest,_RewardState);
		
		PROC
		ProcMarkPartyAsGivenReward((CHARACTERGUID)_Player,(STRING)_Quest,(STRING)_RewardState)
		AND
		DB_IsPlayer(_OtherPlayer)
		AND
		CharacterIsInPartyWith(_Player,_OtherPlayer,1)
		THEN
		DB_QuestRewardGiven(_OtherPlayer,_Quest,_RewardState);
		
		//END_REGION
		
	}
	EXIT
	{
		
	}
}
Goal(26).Title("_Global_Procedure");
Goal(26)
{
	INIT
	{
		
	}
	KB
	{
		//REGION Character DB_KillCounter
		PROC
		ProcCheckCounter((INTEGER)_Count,(STRING)_CounterDB)
		AND
		DB_KillCounterCounts(_CounterDB,_OldCount)
		THEN
		NOT DB_KillCounterCounts(_CounterDB,_OldCount);
		DB_KillCounterCounts(_CounterDB,_Count);
		
		PROC
		ProcClearCounterDB((STRING)_CounterDB)
		AND
		DB_KillCounter_Internal(_Character,_CounterDB)
		THEN
		NOT DB_KillCounter_Internal(_Character,_CounterDB);
		
		PROC
		ProcClearCounterDB((STRING)_CounterDB)
		AND
		DB_KillCounterDied(_Char,_CounterDB)
		THEN
		NOT DB_KillCounterDied(_Char,_CounterDB);
		
		PROC
		ProcCheckCounter(_Count,_CounterDB)
		AND
		DB_KillCounter((STRING)_CounterDB,(INTEGER)_TargetCount)
		AND
		_Count == _TargetCount 
		THEN
		//NOT DB_KillCounter(_CounterDB,_TargetCount);
		ProcClearCounterDB(_CounterDB);
		ProcKillCounterReached(_CounterDB);
		NOT DB_KillCounterCounterDefined(_CounterDB);
		//NOT DB_KillCounterCounts(_CounterDB,_TargetCount);
		
		PROC
		ProcCheckCounter(_Count, _CounterDB)
		AND
		DB_KillCounter((STRING)_CounterDB,(INTEGER)_TargetCount)
		AND
		IntegerSubtract(_TargetCount, 1, _New)
		AND
		_Count == _New
		AND
		DB_KillCounter_Internal(_LastCharacter, _CounterDB)
		THEN
		DB_LastManStanding((CHARACTERGUID)_LastCharacter, (STRING)_CounterDB);
		
		IF
		CharacterDying(_Character)
		AND
		DB_KillCounter_Internal(_Character,_CounterDB)
		AND
		DB_CombatCharacters(_Character,_ID)
		THEN
		ProcSetCounterCombatID(_CounterDB,_ID);
		
		PROC
		ProcClearCounterCombatID((STRING)_Counter)
		AND
		DB_CounterCombatID(_Counter,_OldID)
		THEN
		NOT DB_CounterCombatID(_Counter,_OldID);
		
		PROC
		ProcSetCounterCombatID((STRING)_Counter,(INTEGER)_ID)
		THEN
		ProcClearCounterCombatID(_Counter);
		DB_CounterCombatID(_Counter,_ID);
		
		IF
		ObjectEnteredCombat((CHARACTERGUID)_Char, _ID)
		AND
		DB_KillCounter_Internal(_Char, _Counter)
		THEN
		ProcClearCounterCombatID(_Counter);
		
		IF
		ObjectEnteredCombat((CHARACTERGUID)_LastMan, _ID)
		AND
		DB_KillCounter_Internal(_LastMan, _Counter)
		AND
		DB_KillCounter(_Counter,1)
		THEN
		DB_LastManStanding((CHARACTERGUID)_LastMan, (STRING)_Counter);
		
		IF
		CharacterKilledBy(_Defender,_Attacker,_AttackerOwner)
		AND
		DB_LastManStanding(_Defender, _CounterDB)
		THEN
		NOT DB_LastManStanding(_Defender, _CounterDB);
		DB_LastManInCombatKilledBy(_AttackerOwner, (STRING)_CounterDB);
		
		IF
		CharacterDied(_Character)
		AND
		DB_KillCounter_Internal(_Character,_CounterDB)
		AND
		DB_KillCounterCounts(_CounterDB,_Count)
		AND
		IntegerSum(_Count,1,_NewCount)
		THEN
		NOT DB_KillCounter_Internal(_Character,_CounterDB);
		DB_KillCounterDied(_Character,_CounterDB);
		ProcCheckCounter(_NewCount,_CounterDB);
		
		IF
		CharacterResurrected(_Character)
		AND
		DB_KillCounterDied(_Character,_CounterDB)
		AND
		DB_KillCounterCounts(_CounterDB,_Count)
		AND
		IntegerSubtract(_Count,1,_NewCount)
		THEN
		DB_KillCounter_Internal(_Character,_CounterDB);
		NOT DB_KillCounterDied(_Character,_CounterDB);
		ProcCheckCounter(_NewCount,_CounterDB);
		
		IF
		DB_KillCounter_Internal(_Character,_CounterDB)
		AND
		NOT DB_KillCounterCounterDefined(_CounterDB)
		THEN
		DB_KillCounterCounts(_CounterDB,0);
		DB_KillCounterCounterDefined(_CounterDB);
		
		IF
		CombatEnded(_CombatID)
		AND
		DB_CounterCombatID(_CounterDB,_CombatID)
		AND
		DB_KillCounterCounts(_CounterDB,_Count)
		THEN
		ProcCheckCounterCombatOver(_CounterDB,_CombatID);
		ProcCheckCounter(_Count,_CounterDB);
		
		IF
		DB_CombatCharacters(_Char, _CombatID)
		AND
		DB_KillCounter_Internal(_Char,_CounterDB)
		THEN
		ProcClearCombatOverDB(_CounterDB);
		
		PROC
		ProcClearCombatOverDB((STRING)_CounterDB)
		AND
		DB_KillCounterCombatOver(_OldCombatID, _CounterDB)
		THEN
		NOT DB_KillCounterCombatOver(_OldCombatID, _CounterDB);
		
		//killed people outside of combat
		PROC
		ProcKillCounterReached((STRING)_CounterDB)
		AND
		NOT DB_CounterCombatID(_CounterDB,_)
		THEN
		ReactOnKillCounter(_CounterDB);
		
		PROC
		ProcKillCounterReached((STRING)_CounterDB)
		AND
		DB_KillCounterCombatOver(_CombatID, _CounterDB)
		THEN
		ReactOnKillCounter(_CounterDB);
		NOT DB_KillCounterCombatOver(_CombatID, _CounterDB);
		
		//Wasn't involved in combat
		PROC
		ProcCheckCounterCombatOver((STRING)_CounterDB,(INTEGER)_CombatID)
		THEN
		NOT DB_KillCounterCombatOver(_CombatID, _CounterDB);
		
		PROC
		ProcCheckCounterCombatOver((STRING)_CounterDB,(INTEGER)_CombatID)
		AND
		CombatGetNumberOfInvolvedPartyMembers(_CombatID, 0)
		THEN
		DB_KillCounterCombatOver(_CombatID, _CounterDB);
		
		
		PROC
		ReactOnKillCounter((STRING)_CounterDB)
		AND
		DB_KillCounterCounts(_CounterDB,_Count)
		AND
		DB_KillCounter(_CounterDB,_TargetCount)
		THEN
		NOT DB_KillCounterCounts(_CounterDB,_Count);
		NOT DB_KillCounter(_CounterDB,_TargetCount);
		
		//END_REGION
		
		//REGION Item Destroy Counter
		PROC
		CheckItemCounter((INTEGER)_Count,(STRING)_CounterDB)
		AND
		DB_ItemDestroyCounterCounts(_CounterDB,_OldCount)
		THEN
		NOT DB_ItemDestroyCounterCounts(_CounterDB,_OldCount);
		DB_ItemDestroyCounterCounts(_CounterDB,_Count);
		
		PROC
		ClearDB_ItemDestroyCounter_Internal((STRING)_CounterDB)
		AND
		DB_ItemDestroyCounter_Internal(_Item,_CounterDB)
		THEN
		NOT DB_ItemDestroyCounter_Internal(_Item,_CounterDB);
		
		PROC
		CheckItemCounter(_Count,_CounterDB)
		AND
		DB_ItemDestroyCounter((STRING)_CounterDB,(INTEGER)_TargetCount)
		AND
		_Count == _TargetCount 
		THEN
		NOT DB_ItemDestroyCounter(_CounterDB,_TargetCount);
		ClearDB_ItemDestroyCounter_Internal(_CounterDB);
		NOT DB_ItemDestroyCounterCounterDefined(_CounterDB);
		NOT DB_ItemDestroyCounter(_CounterDB,_TargetCount);
		
		IF
		ItemDestroyed(_Item)
		AND
		DB_ItemDestroyCounter_Internal(_Item,_CounterDB)
		AND
		DB_ItemDestroyCounterCounts(_CounterDB,_Count)
		AND
		IntegerSum(_Count,1,_NewCount)
		THEN
		NOT DB_ItemDestroyCounter_Internal(_Item,_CounterDB);
		CheckItemCounter(_NewCount,_CounterDB);
		
		IF
		DB_ItemDestroyCounter_Internal(_Item,_CounterDB)
		AND
		NOT DB_ItemDestroyCounterCounterDefined(_CounterDB)
		THEN
		DB_ItemDestroyCounterCounts(_CounterDB,0);
		DB_ItemDestroyCounterCounterDefined(_CounterDB);
		//END_REGION
		
		//REGION Comment for hidden effect
		PROC
		PROC_CommentHiddenEffect((CHARACTERGUID)_Player)
		THEN
		Proc_StartDialog(1,"GLO_AD_ActivatedSwitch", _Player);
		//END_REGION
		
		//REGION SneakTrigger
		IF
		DB_SneakTriggerSpotter((TRIGGERGUID)_Trigger, (CHARACTERGUID)_Char)
		THEN
		SetVarObject(_Char, "SpottedTrigger", _Trigger);
		ProcTriggerRegisterForPlayers(_Trigger);
		
		PROC
		ProcHandleSneakSpotted((CHARACTERGUID)_Char)
		THEN
		DB_NOOP(1);
		
		IF
		StoryEvent((CHARACTERGUID)_Char, "GLO_SpotterSneaker")
		AND
		DB_SneakTriggerSpotter(_Trigger, _Char)
		AND
		GetVarObject(_Char, "SpottedDude", _Player)
		THEN
		ProcCharInTriggerSpotted((CHARACTERGUID)_Player,_Trigger);
		ProcCharInTriggerSpottedByChar((CHARACTERGUID)_Player,_Trigger,_Char);
		ProcHandleSneakSpotted(_Char);
		ProcCleanUpSneakTrigger(_Trigger);
		
		PROC
		ProcCharInTriggerSpottedByChar((CHARACTERGUID)_Player,(TRIGGERGUID)_Trigger,(CHARACTERGUID)_Spotter)
		THEN
		DB_NOOP(1);
		
		PROC
		ProcCleanUpSneakTrigger((TRIGGERGUID)_Trigger)
		AND
		DB_SneakTriggerSpotter((TRIGGERGUID)_Trigger, (CHARACTERGUID)_Char)
		THEN
		SetVarInteger(_Char, "SpottedCounter", 1);
		NOT DB_SneakTriggerSpotter(_Trigger, _Char);
		
		PROC
		ProcTriggerUnregisterForPlayers((TRIGGERGUID)_Trigger)
		AND
		DB_SneakTriggerSpotter(_Trigger, _Char)
		THEN
		NOT DB_SneakTriggerSpotter(_Trigger, _Char);
		//END_REGION
		
		//REGION DB_AmbushTrigger
		IF
		DB_AmbushTrigger((TRIGGERGUID)_Trigger, (ITEMGUID)_Helper)
		THEN
		ProcTriggerRegisterForPlayers(_Trigger);
		SetOnStage(_Helper, 1);
		
		IF
		CharacterEnteredTrigger(_Player,_Trigger)
		AND
		DB_AmbushTrigger(_Trigger, _)
		AND
		HasActiveStatus(_Player, "INVISIBLE", 0)
		AND
		HasActiveStatus(_Player, "SNEAKING", 0)
		THEN
		ProcLaunchAmbush(_Trigger, _Player);
		
		IF
		CharacterStatusRemoved(_Player, "INVISIBLE",_)
		AND
		DB_InRegion(_Player, _Trigger)
		AND
		DB_AmbushTrigger(_Trigger, _)
		THEN
		ProcLaunchAmbush(_Trigger, _Player);
		
		IF
		CharacterStatusRemoved(_Player, "SNEAKING",_)
		AND
		DB_InRegion(_Player, _Trigger)
		AND
		DB_AmbushTrigger(_Trigger, _Helper)
		THEN
		ProcLaunchAmbush(_Trigger, _Player);
		
		PROC
		ProcLaunchAmbush((TRIGGERGUID)_Trigger, (CHARACTERGUID)_Player)
		AND
		DB_AmbushTrigger(_Trigger, _Helper)
		THEN
		ProcTriggerUnregisterForPlayers(_Trigger);
		NOT DB_AmbushTrigger(_Trigger, _Helper);
		SetOnStage(_Helper, 0);
		//END_REGION
		
		//REGION Queuing Dialog
		//1 Speaker
		PROC
		PROC_MandatoryOneSpeakerDialog((STRING)_Dialog,(CHARACTERGUID)_Player)
		AND
		NOT QRY_SpeakerIsAvailable(_Player)
		THEN
		DB_QueuedOneSpeakerDialog(_Player,_Dialog);
		
		PROC
		PROC_MandatoryOneSpeakerDialog((STRING)_Dialog,(CHARACTERGUID)_Player)
		AND
		QRY_SpeakerIsAvailable(_Player)
		THEN
		MakePlayerActive(_Player);
		Proc_StartDialog(0,_Dialog,_Player);
		
		IF
		DialogEnded(_,_)
		AND
		DB_QueuedOneSpeakerDialog(_Player,_Dialog)
		AND
		DB_IsPlayer(_Player)
		AND
		QRY_SpeakerIsAvailable(_Player)
		THEN
		NOT DB_QueuedOneSpeakerDialog(_Player,_Dialog);
		MakePlayerActive(_Player);
		Proc_StartDialog(0,_Dialog,_Player);
		
		IF
		ObjectLeftCombat((CHARACTERGUID)_Player,_)
		AND
		DB_QueuedOneSpeakerDialog(_Player,_Dialog)
		AND
		DB_IsPlayer(_Player)
		AND
		QRY_SpeakerIsAvailable(_Player)
		THEN
		NOT DB_QueuedOneSpeakerDialog(_Player,_Dialog);
		MakePlayerActive(_Player);
		Proc_StartDialog(0,_Dialog,_Player);
		
		//END_REGION
		
		//REGION Quest Reward
		PROC
		ProcRewardQuestMedium((TRIGGERGUID)_Trigger)
		THEN
		ItemCreateAtTrigger(_Trigger, "Quest_Reward_Small_94e12298-5e59-405a-9e93-95833e648ce2");
		PlayEffect(_Trigger,"RS3_FX_GP_ScriptedEvent_Teleport_GenericSmoke_01");
		
		PROC
		ProcRewardQuestBig((TRIGGERGUID)_Trigger)
		THEN
		ItemCreateAtTrigger(_Trigger, "Quest_Reward_Big_b67596ec-18ca-4790-9273-8af23d8a7a43");
		PlayEffect(_Trigger,"RS3_FX_GP_ScriptedEvent_Teleport_GenericSmoke_01");
		//END_REGION
		
		
		//REGION secret regions
		IF
		DB_SecretRegions_OnOpenedDoor(_Trig,_)
		THEN
		LockSecretRegion(_Trig);
		
		IF
		DB_SecretRegions_OnEnteredTrig(_Trig,_OtherTrig)
		THEN
		ProcTriggerRegisterForPlayers(_OtherTrig);
		LockSecretRegion(_Trig);
		
		IF
		CharacterUsedItem(_,_Door)
		AND
		DB_SecretRegions_OnOpenedDoor(_Trig,_Door)
		AND
		DoorIsOpening(_Door,1)
		THEN
		UnlockSecretRegion(_Trig);
		NOT DB_SecretRegions_OnOpenedDoor(_Trig,_Door);
		
		IF
		ItemOpened(_Door)
		AND
		DB_SecretRegions_OnOpenedDoor(_Trig,_Door)
		THEN
		UnlockSecretRegion(_Trig);
		NOT DB_SecretRegions_OnOpenedDoor(_Trig,_Door);
		
		IF
		ItemDestroyed(_Door)
		AND
		DB_SecretRegions_OnOpenedDoor(_Trig,_Door)
		THEN
		UnlockSecretRegion(_Trig);
		NOT DB_SecretRegions_OnOpenedDoor(_Trig,_Door);
		
		
		IF
		CharacterEnteredTrigger(_Char,_EnteredTrig)
		AND
		DB_SecretRegions_OnEnteredTrig(_Trig,(TRIGGERGUID)_EnteredTrig)
		AND
		DB_IsPlayer(_Char)
		THEN
		UnlockSecretRegion(_Trig);
		NOT DB_SecretRegions_OnEnteredTrig(_Trig,_EnteredTrig);
		
		IF
		StoryEvent(_,_Event)
		AND
		DB_SecretRegions_OnStoryEvent(_Trig,_Event)
		THEN
		UnlockSecretRegion(_Trig);
		NOT DB_SecretRegions_OnStoryEvent(_Trig,_Event);
		
		
		//END_REGION
		
	}
	EXIT
	{
		
	}
}
Goal(27).Title("_Global_RunUpAndChat");
Goal(27)
{
	INIT
	{
		
	}
	KB
	{
		//REGION MoveToAndTalk
		
		//Start Walking
		PROC
		ProcCharacterMoveToAndTalk((CHARACTERGUID)_Character,(GUIDSTRING)_Target,(STRING)_Dialog,(INTEGER)_IsAutomated,(STRING)_MoveEvent,(INTEGER)_Running,(REAL)_TimeOut)
		THEN
		ProcCharacterMoveToAndTalk((CHARACTERGUID)_Character,(GUIDSTRING)_Target,(STRING)_Dialog,(INTEGER)_IsAutomated,(STRING)_MoveEvent,(INTEGER)_Running,(REAL)_TimeOut,0,0);
		
		PROC
		ProcCharacterMoveToAndTalk((CHARACTERGUID)_Character,(GUIDSTRING)_Target,(STRING)_Dialog,(INTEGER)_IsAutomated,(STRING)_MoveEvent,(INTEGER)_Running,(REAL)_TimeOut,(INTEGER)_CheckForFallBackPlayers,(INTEGER)_ForcePartyCheck)
		AND
		DB_CharacterMoveToAndTalk_CharacerIsMoving(_Character,_Target,_Dialog,_MoveEvent)
		THEN
		NOT DB_CharacterMoveToAndTalk_CharacerIsMoving(_Character,_Target,_Dialog,_MoveEvent);
		
		PROC
		ProcCharacterMoveToAndTalk((CHARACTERGUID)_Character,(GUIDSTRING)_Target,(STRING)_Dialog,(INTEGER)_IsAutomated,(STRING)_MoveEvent,(INTEGER)_Running,(REAL)_TimeOut,(INTEGER)_CheckForFallBackPlayers,(INTEGER)_ForcePartyCheck)
		AND
		DB_CharacterMoveToAndTalk_CheckForFallBackCharacters(_Character,_Target,_Dialog,_CheckForFallBackPlayers,_ForcePartCheck)
		THEN
		NOT DB_CharacterMoveToAndTalk_CheckForFallBackCharacters(_Character,_Target,_Dialog,_CheckForFallBackPlayers,_ForcePartCheck);
		
		PROC
		ProcCharacterMoveToAndTalk((CHARACTERGUID)_Character,(GUIDSTRING)_Target,(STRING)_Dialog,(INTEGER)_IsAutomated,(STRING)_MoveEvent,(INTEGER)_Running,(REAL)_TimeOut,(INTEGER)_CheckForFallBackPlayers,(INTEGER)_ForcePartyCheck)
		THEN
		CharacterMoveToAndTalk(_Character,_Target,_Dialog,_IsAutomated,_MoveEvent,_Running,_TimeOut);
		DB_CharacterMoveToAndTalk_CharacerIsMoving(_Character,_Target,_Dialog,_MoveEvent);
		DB_CharacterMoveToAndTalk_CheckForFallBackCharacters(_Character,_Target,_Dialog,_CheckForFallBackPlayers,_ForcePartyCheck);
		
		//Movement Failed
		IF
		CharacterMoveToAndTalkFailed((CHARACTERGUID)_Character,(GUIDSTRING)_Target,(STRING)_MoveEvent)
		AND
		DB_CharacterMoveToAndTalk_CharacerIsMoving(_Character,_Target,_Dialog,_MoveEvent)
		THEN
		NOT DB_CharacterMoveToAndTalk_CharacerIsMoving(_Character,_Target,_Dialog,_MoveEvent);
		
		IF
		AttackedByObject(_Character,_Source,_Summon,_DamageType,_)
		AND
		DB_CharacterMoveToAndTalk_CharacerIsMoving((CHARACTERGUID)_Character,_Target,_Dialog,_MoveEvent)
		THEN
		CharacterMoveToAndTalkRequestDialogFailed(_Character,_Target,_MoveEvent);
		
		IF
		RegionEnded(_)
		AND
		DB_CharacterMoveToAndTalk_CharacerIsMoving((CHARACTERGUID)_Character,_Target,_Dialog,_MoveEvent)
		THEN
		CharacterMoveToAndTalkRequestDialogFailed(_Character,_Target,_MoveEvent);
		
		IF
		CharacterLeftRegion(_Characrer,_Region)
		AND
		DB_CurrentLevel(_Region)
		AND
		DB_CharacterMoveToAndTalk_CharacerIsMoving((CHARACTERGUID)_Character,_Target,_Dialog,_MoveEvent)
		THEN
		CharacterMoveToAndTalkRequestDialogFailed(_Character,_Target,_MoveEvent);
		
		IF
		CharacterLeftRegion(_Target,_Region)
		AND
		DB_CurrentLevel(_Region)
		AND
		DB_CharacterMoveToAndTalk_CharacerIsMoving((CHARACTERGUID)_Character,_Target,_Dialog,_MoveEvent)
		THEN
		CharacterMoveToAndTalkRequestDialogFailed(_Character,_Target,_MoveEvent);
		
		IF
		CharacterDied(_Target)
		AND
		DB_CharacterMoveToAndTalk_CharacerIsMoving((CHARACTERGUID)_Character,_Target,_Dialog,_MoveEvent)
		THEN
		CharacterMoveToAndTalkRequestDialogFailed(_Character,_Target,_MoveEvent);
		
		IF
		CharacterDied(_Character)
		AND
		DB_CharacterMoveToAndTalk_CharacerIsMoving((CHARACTERGUID)_Character,_Target,_Dialog,_MoveEvent)
		THEN
		CharacterMoveToAndTalkRequestDialogFailed(_Character,_Target,_MoveEvent);
		
		IF
		DialogStarted(_,_ID)
		AND
		DB_DialogNPCS(_ID,_Character,_)
		AND
		DB_CharacterMoveToAndTalk_CharacerIsMoving((CHARACTERGUID)_Character,_Target,_Dialog,_MoveEvent)
		THEN
		CharacterMoveToAndTalkRequestDialogFailed(_Character,_Target,_MoveEvent);
		
		IF
		CombatStarted(_ID)
		AND
		DB_CombatCharacters(_Character, _ID)
		AND
		DB_CharacterMoveToAndTalk_CharacerIsMoving((CHARACTERGUID)_Character,_Target,_Dialog,_MoveEvent)
		THEN
		CharacterMoveToAndTalkRequestDialogFailed(_Character,_Target,_MoveEvent);
		
		
		// Movement Finished
		IF
		CharacterMoveToAndTalkRequestDialog((CHARACTERGUID)_Character,(GUIDSTRING)_Target,(STRING)_Dialog,(INTEGER)_IsAutomated,(STRING)_MoveEvent)
		AND
		DB_CharacterMoveToAndTalk_CharacerIsMoving(_Character,_Target,_Dialog,_MoveEvent)
		THEN
		NOT DB_CharacterMoveToAndTalk_CharacerIsMoving(_Character,_Target,_Dialog,_MoveEvent);
		
		IF
		CharacterMoveToAndTalkRequestDialog((CHARACTERGUID)_Character,(GUIDSTRING)_Target,(STRING)_Dialog,(INTEGER)_IsAutomated,(STRING)_MoveEvent)
		THEN
		SetStoryEvent(_Character,_MoveEvent);
		
		// Dialog Failed
		IF
		CharacterMoveToAndTalkRequestDialog((CHARACTERGUID)_Character,(GUIDSTRING)_Target,(STRING)_Dialog,(INTEGER)_IsAutomated,(STRING)_MoveEvent)
		AND
		NOT QRY_SpeakerIsAvailable(_Target)
		AND 
		DB_CharacterMoveToAndTalk_CheckForFallBackCharacters(_Character,_Target,_Dialog,0,_ForcePartyCheck)
		THEN
		CharacterMoveToAndTalkRequestDialogFailed(_Character,_Target,_MoveEvent);
		
		IF
		CharacterMoveToAndTalkRequestDialog((CHARACTERGUID)_Character,(GUIDSTRING)_Target,(STRING)_Dialog,(INTEGER)_IsAutomated,(STRING)_MoveEvent)
		AND
		NOT QRY_SpeakerIsAvailable(_Target)
		AND 
		DB_CharacterMoveToAndTalk_CheckForFallBackCharacters(_Character,(CHARACTERGUID)_Target,_Dialog,1,0)
		AND
		DB_IsPlayer(_Target)
		THEN
		ProcGetClosestAvailableCharacterTo(_Target,1);
		PROC_CharacterMoveToAndTalkRequestDialog_Closest(_Character,_Target,_Dialog,_IsAutomated,_MoveEvent);
		
		IF
		CharacterMoveToAndTalkRequestDialog((CHARACTERGUID)_Character,(GUIDSTRING)_Target,(STRING)_Dialog,(INTEGER)_IsAutomated,(STRING)_MoveEvent)
		AND
		NOT QRY_SpeakerIsAvailable(_Target)
		AND 
		DB_CharacterMoveToAndTalk_CheckForFallBackCharacters(_Character,(CHARACTERGUID)_Target,_Dialog,1,1)
		AND
		DB_IsPlayer(_Target)
		THEN
		ProcGetClosestAvailableCharacterTo(_Target,1,1,_Target);
		PROC_CharacterMoveToAndTalkRequestDialog_Closest(_Character,_Target,_Dialog,_IsAutomated);
		
		// Dialog Success
		
		IF
		CharacterMoveToAndTalkRequestDialog((CHARACTERGUID)_Character,(GUIDSTRING)_Target,(STRING)_Dialog,(INTEGER)_IsAutomated,(STRING)_MoveEvent)
		AND
		_Dialog!=""
		AND
		QRY_SpeakerIsAvailable(_Target)
		THEN
		Proc_StartDialog(_IsAutomated,_Dialog,_Character,_Target);
		
		PROC
		PROC_CharacterMoveToAndTalkRequestDialog_Closest((CHARACTERGUID)_Character,(GUIDSTRING)_Target,(STRING)_Dialog,(INTEGER)_IsAutomated)
		AND
		NOT QRY_SpeakerIsAvailable(_Target)
		AND
		DB_ClosestAvailablePlayer(_Player,(CHARACTERGUID)_Target)
		THEN
		Proc_StartDialog(_IsAutomated,_Dialog,_Character,_Player);
		
		PROC
		PROC_CharacterMoveToAndTalkRequestDialog_Closest((CHARACTERGUID)_Character,(GUIDSTRING)_Target,(STRING)_Dialog,(INTEGER)_IsAutomated,(STRING)_MoveEvent)
		AND
		NOT QRY_SpeakerIsAvailable(_Target)
		AND
		NOT DB_ClosestAvailablePlayer(_,(CHARACTERGUID)_Target)
		THEN
		CharacterMoveToAndTalkRequestDialogFailed(_Character,_Target,_MoveEvent);
		
		//END_REGION
		
		
	}
	EXIT
	{
		
	}
}
Goal(28).Title("_Global_SavegamePatching");
Goal(28)
{
	INIT
	{
		
	}
	KB
	{
		//REGION Remove destroyed items that came back
		IF
		SavegameLoaded(_Major,_Minor,_Rev,_Build)
		AND
		QRY_VersionIsOlderThan(_Major,_Minor,_Rev,_Build,3,1,5,1)
		AND
		DB_DestroyedItems((GUIDSTRING)_Item)
		AND
		ObjectExists((ITEMGUID)_Item,1)
		AND
		ItemIsDestroyed(_Item,0)
		THEN
		ItemRemove(_Item);
		//END_REGION
		
	}
	EXIT
	{
		
	}
}
Goal(29).Title("_GLOBAL_Subregions");
Goal(29)
{
	INIT
	{
		
	}
	KB
	{
		IF
		DB_Subregion((TRIGGERGUID)_Trigger,(STRING)_,(INTEGER)_)
		THEN
		ProcTriggerRegisterForPlayers(_Trigger);
		
		IF
		CharacterEnteredTrigger(_Character,_Trigger)
		AND
		DB_Subregion(_Trigger,_Message,_ShowMarker)
		THEN
		CharacterEnteredSubRegion(_Character,_Message);
		ProcCheckSetRegionMarker(_Message,_ShowMarker);
		
		PROC
		ProcCheckSetRegionMarker((STRING)_Message,1)
		AND
		DB_IsPlayer(_Player)
		THEN
		ProcShowMarker(_Player,_Message);
		
		
		
		
		
	}
	EXIT
	{
		
	}
}
Goal(30).Title("_GLOBAL_TeleporterPyramids");
Goal(30)
{
	INIT
	{
		// PUBLIC PROCs:
		//   Proc_PyramidBlockerTriggerAdd	    - add trigger that blocks pyramid usage
		//   Proc_PyramidBlockerTriggerRemove   - remove trigger from blocking list
		//   Proc_PyramidGlobalBlockerOn        - global pyramids blocker turn on
		//   Proc_PyramidGlobalBlockerOff       - global pyramids blocker turn off
		//   Proc_PyramidCustomBlockAdd         - add custom blocker of a pyramid (used for Tenebrium chests)
		//   Proc_PyramidCustomBlockRemove      - remove custom blocker of a pyramid (used for Tenebrium chests)
		
		
		// Inner DBs:
		//   DB_TeleporterPyramidUnlocked((ITENGUID)_Pyramid) - the ones found by players
		//   DB_PyramidBlockerTrigger((TRIGGERGUID)_Trigger) 	- trigger blockers of pyramid usage
		//   DB_PyramidUsageBlocked(1) 						- global pyramid blocker
		//   DB_PyramidInBlockerTrigger((ITEMGUID)_Pyramid,(TRIGGERGUID)_Trigger)  - used to store which pyramids are in blocking triggers
		//   DB_PyramidCustomBlock((ITEMGUID)_Pyramid,(STRING)_Reason)             - used to store which pyramids are customly blocked
		
	}
	KB
	{
		//REGION Debug
		//END_REGION
		
		IF
		DB_TeleporterPyramid(_Pyramid)
		THEN
		ItemSetForceSynch(_Pyramid,1);
		
		//REGION Unlock pyramids that were found by player
		IF
		ItemAddedToCharacter(_Pyramid,_Player)
		AND
		DB_TeleporterPyramid(_Pyramid)
		AND
		NOT DB_TeleporterPyramidUnlocked(_Pyramid)
		AND
		_Player.DB_IsPlayer()
		THEN
		DB_TeleporterPyramidUnlocked(_Pyramid);
		
		IF
		CharacterUsedItem(_Player,_Pyramid)
		AND
		DB_TeleporterPyramid(_Pyramid)
		AND
		NOT DB_TeleporterPyramidUnlocked(_Pyramid)
		AND
		_Player.DB_IsPlayer()
		THEN
		PROC_CheckPlayTut(_Player,"TUT_PyramidsPickup");
		//END_REGION
		
		
		//REGION Pyramid blockers
		PROC
		Proc_PyramidGlobalBlockerOn()
		THEN
		DB_PyramidUsageBlocked(1);
		
		PROC
		Proc_PyramidGlobalBlockerOn()
		AND
		DB_TeleporterPyramid(_Pyramid)
		THEN
		DisablePyramid(_Pyramid);
		
		PROC
		Proc_PyramidGlobalBlockerOff()
		THEN
		NOT DB_PyramidUsageBlocked(1);
		
		PROC
		Proc_PyramidGlobalBlockerOff()
		AND
		DB_TeleporterPyramid(_Pyramid)
		THEN
		Proc_PyramidCheckEnabled(_Pyramid);
		
		
		PROC
		Proc_PyramidBlockerTriggerAdd((TRIGGERGUID)_Trigger)
		THEN
		DB_PyramidBlockerTrigger(_Trigger);
		TriggerRegisterForItems(_Trigger);
		ProcTriggerRegisterForPlayers(_Trigger);
		
		PROC
		Proc_PyramidBlockerTriggerRemove((TRIGGERGUID)_Trigger)
		THEN
		NOT DB_PyramidBlockerTrigger(_Trigger);
		TriggerUnregisterForItems(_Trigger);
		ProcTriggerUnregisterForPlayers(_Trigger);
		
		PROC
		Proc_PyramidCustomBlockAdd((ITEMGUID)_Pyramid,(STRING)_Reason)
		THEN
		DisablePyramid(_Pyramid);
		DB_PyramidCustomBlock(_Pyramid,_Reason);
		
		PROC
		Proc_PyramidCustomBlockRemove((ITEMGUID)_Pyramid,(STRING)_Reason)
		THEN
		NOT DB_PyramidCustomBlock(_Pyramid,_Reason);
		Proc_PyramidCheckEnabled(_Pyramid);
		
		
		// Pyramid entered/left blocking trigger inside of character's inventory
		IF
		CharacterEnteredTrigger(_Char,_Trigger)
		AND
		DB_PyramidBlockerTrigger(_Trigger)
		AND
		DB_TeleporterPyramid(_Pyramid)
		AND
		ItemIsInCharacterInventory(_Pyramid,_Char,1)
		THEN
		Proc_PyramidEnterBlockerTrigger(_Pyramid,_Trigger);
		
		IF
		CharacterLeftTrigger(_Char,_Trigger)
		AND
		DB_PyramidBlockerTrigger(_Trigger)
		AND
		DB_TeleporterPyramid(_Pyramid)
		AND
		ItemIsInCharacterInventory(_Pyramid,_Char,1)
		AND
		DB_PyramidInBlockerTrigger(_Pyramid,_Trigger)
		THEN
		Proc_PyramidLeaveBlockerTrigger(_Pyramid,_Trigger);
		
		
		// Pyramid entered/left blocking trigger
		IF
		ItemEnteredTrigger(_Pyramid,_Trigger,_)
		AND
		DB_TeleporterPyramid(_Pyramid)
		AND
		DB_PyramidBlockerTrigger(_Trigger)
		THEN
		Proc_PyramidEnterBlockerTrigger(_Pyramid,_Trigger);
		
		IF
		ItemLeftTrigger(_Pyramid,_Trigger,_)
		AND
		DB_PyramidInBlockerTrigger(_Pyramid,_Trigger)
		THEN
		Proc_PyramidLeaveBlockerTrigger(_Pyramid,_Trigger);
		
		
		// Pyramid entered/left blocking trigger inside of another container
		IF
		ItemEnteredTrigger(_Container,_Trigger,_)
		AND
		DB_PyramidBlockerTrigger(_Trigger)
		AND
		DB_TeleporterPyramid(_Pyramid)
		AND
		GetInventoryOwner(_Pyramid,_Container)
		THEN
		Proc_PyramidEnterBlockerTrigger(_Pyramid,_Trigger);
		
		IF
		ItemLeftTrigger(_Container,_Trigger,_)
		AND
		DB_PyramidInBlockerTrigger(_Pyramid,_Trigger)
		AND
		GetInventoryOwner(_Pyramid,_Container)
		THEN
		Proc_PyramidLeaveBlockerTrigger(_Pyramid,_Trigger);
		
		
		// Added to container - remove old triggers that this container is not inside
		IF
		ItemAddedToContainer(_Pyramid,_)
		AND
		DB_TeleporterPyramid(_Pyramid)
		AND
		GetInventoryOwner(_Pyramid,_TopCont)
		AND
		DB_PyramidInBlockerTrigger(_Pyramid,_Trigger)
		AND
		ObjectIsInTrigger(_TopCont,_Trigger,0)
		THEN
		Proc_PyramidLeaveBlockerTrigger(_Pyramid,_Trigger);
		
		IF
		ItemAddedToContainer(_Pyramid,_)
		AND
		DB_TeleporterPyramid(_Pyramid)
		AND
		GetInventoryOwner(_Pyramid,_TopCont)
		AND
		DB_PyramidBlockerTrigger(_Trigger)
		AND
		ObjectIsInTrigger(_TopCont,_Trigger,1)
		THEN
		Proc_PyramidEnterBlockerTrigger(_Pyramid,_Trigger);
		
		IF
		ItemRemovedFromContainer(_Pyramid,_Container)
		AND
		DB_TeleporterPyramid(_Pyramid)
		AND
		DB_PyramidInBlockerTrigger(_Pyramid,_Trigger)
		AND
		ObjectIsInTrigger(_Container,_Trigger,1)
		THEN
		Proc_PyramidLeaveBlockerTrigger(_Pyramid,_Trigger);
		
		IF
		ItemRemovedFromContainer(_Pyramid,_Container)
		AND
		DB_TeleporterPyramid(_Pyramid)
		AND
		DB_PyramidInBlockerTrigger(_Pyramid,_Trigger)
		AND
		GetInventoryOwner(_Container,_TopCont)
		AND
		ObjectIsInTrigger(_TopCont,_Trigger,1)
		THEN
		Proc_PyramidLeaveBlockerTrigger(_Pyramid,_Trigger);
		
		IF
		ItemAddedToCharacter(_Pyramid,_Character)
		AND
		DB_TeleporterPyramid(_Pyramid)
		AND
		DB_PyramidBlockerTrigger(_Trigger)
		AND
		ObjectIsInTrigger(_Character,_Trigger,1)
		THEN
		Proc_PyramidEnterBlockerTrigger(_Pyramid,_Trigger);
		
		IF
		ItemRemovedFromCharacter(_Pyramid,_Character)
		AND
		DB_TeleporterPyramid(_Pyramid)
		AND
		DB_PyramidBlockerTrigger(_Trigger)
		AND
		ObjectIsInTrigger(_Character,_Trigger,1)
		THEN
		Proc_PyramidLeaveBlockerTrigger(_Pyramid,_Trigger);
		
		
		PROC
		Proc_PyramidEnterBlockerTrigger((ITEMGUID)_Pyramid,(TRIGGERGUID)_Trigger)
		THEN
		DisablePyramid(_Pyramid);
		DB_PyramidInBlockerTrigger(_Pyramid,_Trigger);
		
		PROC
		Proc_PyramidLeaveBlockerTrigger((ITEMGUID)_Pyramid,(TRIGGERGUID)_Trigger)
		THEN
		NOT DB_PyramidInBlockerTrigger(_Pyramid,_Trigger);
		Proc_PyramidCheckEnabled(_Pyramid);
		
		
		PROC
		Proc_PyramidCheckEnabled((ITEMGUID)_Pyramid)
		AND
		NOT DB_PyramidUsageBlocked(1)
		AND
		DB_TeleporterPyramid(_Pyramid)
		AND
		NOT DB_PyramidInBlockerTrigger(_Pyramid,_)
		AND
		NOT DB_PyramidCustomBlock(_Pyramid,_)
		THEN
		EnablePyramid(_Pyramid);
		//END_REGION
		
		
		//REGION Level transitions
		IF
		RegionEnded(_Region)
		AND
		DB_TeleporterPyramidUnlocked(_Pyramid)
		AND
		GetRegion(_Pyramid,_Region)
		AND
		GetInventoryOwner(_Pyramid,_TopContainer)
		AND
		NOT DB_IsPlayer((CHARACTERGUID)_TopContainer)
		AND
		ItemGetOriginalOwner(_Pyramid,_Owner)
		THEN
		ItemToInventory(_Pyramid,_Owner,-1);
		
		IF
		RegionEnded(_Region)
		AND
		DB_TeleporterPyramidUnlocked(_Pyramid)
		AND
		GetRegion(_Pyramid,_Region)
		AND
		NOT GetInventoryOwner(_Pyramid,_)
		AND
		ItemGetOriginalOwner(_Pyramid,_Owner)
		THEN
		ItemToInventory(_Pyramid,_Owner,-1);
		
		/*
		IF
		ItemWentOnStage(_Container,0)
		AND
		DB_TeleporterPyramidUnlocked(_Pyramid)
		AND
		//TODO: implement this: ItemIsInItemInventory(_Pyramid,_Container,1)
		AND
		GetPosition(_Container,_X,_Y,_Z)
		THEN
		TeleportToPosition(_Pyramid,_X,_Y,_Z,"",0);
		ItemClearOwner(_Pyramid);
		*/
		
		// Prevent NPCs leaving with Pyramids in their inventory
		IF
		CharacterWentOnStage(_NPC,0)
		AND
		// Players can be set off-stage temporarily by story in some cases
		NOT DB_IsPlayer(_NPC)
		AND
		DB_TeleporterPyramid(_Pyramid)
		AND
		ItemIsInCharacterInventory(_Pyramid,_NPC,1)
		AND
		GetPosition(_NPC,_X,_Y,_Z)
		THEN
		TeleportToPosition(_Pyramid,_X,_Y,_Z,"",0);
		ItemClearOwner(_Pyramid);
		
		PROC
		Proc_CompanionLeftParty((CHARACTERGUID)_Companion,(CHARACTERGUID)_Player)
		AND
		DB_TeleporterPyramid(_Pyramid)
		AND
		ItemIsInCharacterInventory(_Pyramid,_Companion,1)
		THEN
		ItemToInventory(_Pyramid,_Player,-1);
		//END_REGION
		
		
		//REGION Pyramids using (teleportation)
		IF
		CharacterTeleportToPyramid(_Char,_Pyramid)
		AND
		PyramidEnabled(_Pyramid)
		AND
		GetPosition(_Pyramid,_X,_Y,_Z)
		THEN
		TeleportToPosition(_Char,_X,_Y,_Z,"",1);
		
		IF
		CharacterTeleportToPyramid(_Char,_Pyramid)
		AND
		NOT PyramidEnabled(_Pyramid)
		THEN
		Proc_StartDialog(1,"GEN_AD_TeleporterPyramidDisabled",_Char);
		// TODO: check if this is needed ---> DB_CustomUseItemResponse(_Char,_Pyramid,0);
		
		PROC
		ProcBlockUseOfItem(_Player,_Pyramid)
		AND
		DB_TeleporterPyramid(_Pyramid)
		AND
		DB_IsPlayer(_Player)
		AND
		NOT PyramidEnabled(_Pyramid)
		THEN
		CloseUI(_Player,"Inventory");
		ObjectSetFlag(_Player,"SourcePyramidBlocked");
		Proc_StartDialog(1,"GEN_AD_TeleporterPyramidDisabled",_Player);
		DB_CustomUseItemResponse(_Player,_Pyramid,0);
		
		PROC
		ProcBlockUseOfItem(_Player,_Pyramid)
		AND
		DB_TeleporterPyramid(_Pyramid)
		AND
		DB_IsPlayer(_Player)
		AND
		DB_PyramidBlockerTrigger(_Trigger)
		AND
		ObjectIsInTrigger(_Player,_Trigger,1)
		THEN
		CloseUI(_Player,"Inventory");
		ObjectSetFlag(_Player,"SourcePyramidBlocked");
		Proc_StartDialog(1,"GEN_AD_TeleporterPyramidDisabled",_Player);
		DB_CustomUseItemResponse(_Player,_Pyramid,0);
		//END_REGION
		
		
		IF
		ItemAddedToCharacter(_Pyramid,_Player)
		AND
		DB_TeleporterPyramid(_Pyramid)
		AND
		DB_IsPlayer(_Player)
		THEN
		PROC_CheckPlayTutWithDelay(_Player,"TUT_Pyramid",2000);
		
		
		//REGION Enable/disable
		//TEMP: needs to be a game calls
		PROC
		DisablePyramid((ITEMGUID)_Item)
		THEN
		SetTag(_Item,"PYRAMID_DISABLED");
		
		PROC
		EnablePyramid((ITEMGUID)_Item)
		THEN
		ClearTag(_Item,"PYRAMID_DISABLED");
		
		QRY
		PyramidEnabled((ITEMGUID)_Item)
		AND
		IsTagged(_Item,"PYRAMID_DISABLED",0)
		THEN
		DB_NOOP(1);
		//END_REGION
		
	}
	EXIT
	{
		
	}
}
Goal(31).Title("_GLOBAL_TutorialMessages");
Goal(31)
{
	INIT
	{
		DB_ItemOpened(0);
		
		/***********************
		* Flags field: a bit field
		* 0	: no checks
		* 1 : no combat : don't show the tutorial if the character is active in combat
		* 2 : no UI : don't show the tutorial if the character has a UI open 
		* 4 : cancel on condition fail : the tutorial is removed from the queue if the conditions don't match, it can be sent again after that
		* 8 : force enqueue (wait at least one frame)
		* 16 : newfeature : this tutorial is specific for DOS2
		***********************/
		DB_TutorialInfo("TUT_Book","TUT_CAT_Inventory","TUT_Book_Title",0,0,-1,1,3,0);
		DB_TutorialInfo("TUT_Camera","TUT_CAT_Exploring","TUT_Camera_Title",0,0,6000,1,2,0);
		DB_TutorialInfo("TUT_Combat","TUT_CAT_Combat","TUT_Combat_Title",0,0,-1,1,0,0);
		DB_TutorialInfo("TUT_Combat_Examine","TUT_CAT_Combat","TUT_Combat_Examine_Title",0,0,20000,2,0,0);
		DB_TutorialInfo("TUT_Combat_Guard","TUT_CAT_Combat","TUT_Combat_Guard_Title",0,2,-1,2,0,0);
		DB_TutorialInfo("TUT_Combat_TacticalView","TUT_CAT_Combat","TUT_Combat_TacticalView_Title",0,0,20000,2,0,0);
		DB_TutorialInfo("TUT_Combat_TargetCycle","TUT_CAT_Combat","TUT_Combat_TargetCycle_Controller_Title",2,0,-1,1,0,0);
		DB_TutorialInfo("TUT_Combat_TurnOrder","TUT_CAT_Combat","TUT_Combat_TurnOrder_Title",0,3,-1,1,0,0);
		DB_TutorialInfo("TUT_Died","TUT_CAT_Combat","TUT_Died_Title",0,0,-1,1,0,0);
		DB_TutorialInfo("TUT_Disarm","TUT_CAT_Exploring","TUT_Disarm_Title",0,0,-1,3,0,0);
		DB_TutorialInfo("TUT_DragIcon","TUT_CAT_Exploring","TUT_DragIcon_Title",1,0,-1,1,0,0);
		DB_TutorialInfo("TUT_Equipment","TUT_CAT_Inventory","TUT_Equipment_Title",0,0,20000,1,2,0);
		DB_TutorialInfo("TUT_Flee","TUT_CAT_Combat","TUT_Flee_Title",0,0,-1,3,4,0);
		DB_TutorialInfo("TUT_GasPit","TUT_CAT_Exploring","TUT_GasPit_Title",0,1,-1,3,0,0);
		DB_TutorialInfo("TUT_GenericBehaviors","TUT_CAT_Exploring","TUT_GenericBehaviors_Title",0,0,-1,3,0,0);
		DB_TutorialInfo("TUT_Hammer","TUT_CAT_Inventory","TUT_Hammer_Title",0,0,-1,1,0,0);
		DB_TutorialInfo("TUT_HotbarAssignment","TUT_CAT_Inventory","TUT_HotbarAssignment_Title",0,0,15000,2,6,0);
		DB_TutorialInfo("TUT_IdentifyingGlass","TUT_CAT_Inventory","TUT_IdentifyingGlass_Title",0,0,-1,1,0,0);
		DB_TutorialInfo("TUT_Inventory","TUT_CAT_Inventory","TUT_Inventory_Title",0,2,20000,1,2,0);
		DB_TutorialInfo("TUT_LevelUp","TUT_CAT_Inventory","TUT_LevelUp_Title",0,2,20000,2,3,0);
		DB_TutorialInfo("TUT_Locked","TUT_CAT_Exploring","TUT_Locked_Title",0,0,-1,3,0,0);
		DB_TutorialInfo("TUT_WoodenDoor","TUT_CAT_Exploring","TUT_WoodenDoor_Title",0,0,-1,3,0,0);
		DB_TutorialInfo("TUT_Lockpick","TUT_CAT_Inventory","TUT_Lockpick_Title",0,0,-1,1,0,0);
		DB_TutorialInfo("TUT_Mound","TUT_CAT_Exploring","TUT_Mound_Title",0,0,-1,3,0,0);
		DB_TutorialInfo("TUT_Movement","TUT_CAT_Exploring","TUT_Movement_Title",0,0,6000,1,0,0);
		DB_TutorialInfo("TUT_NoPetPal","TUT_CAT_Social","TUT_PetPal_Title",0,0,-1,2,0,0);
		DB_TutorialInfo("TUT_Perception","TUT_CAT_Inventory","TUT_Perception_Title",0,0,-1,1,0,0);
		DB_TutorialInfo("TUT_PetPal","TUT_CAT_Social","TUT_PetPal_Title",0,0,-1,2,0,0);
		DB_TutorialInfo("TUT_Potion","TUT_CAT_Combat","TUT_Potion_Title",0,1,-1,2,0,0);
		DB_TutorialInfo("TUT_Pyramid","TUT_CAT_Exploring","TUT_Pyramid_Title",0,0,-1,1,0,0);
		DB_TutorialInfo("TUT_Pyramid_2","TUT_CAT_Exploring","TUT_Pyramid_2_Title",0,0,-1,1,0,0);
		DB_TutorialInfo("TUT_PyramidsPickup","TUT_CAT_Exploring","TUT_PyramidsPickup_Title",0,0,-1,1,0,0);
		DB_TutorialInfo("TUT_ReflectionDialog","TUT_CAT_Social","TUT_ReflectionDialog_Title",0,0,-1,1,0,0);
		DB_TutorialInfo("TUT_SaveLoad","TUT_CAT_General","TUT_SaveLoad_Title",0,0,-1,1,0,0);
		DB_TutorialInfo("TUT_Scroll","TUT_CAT_Combat","TUT_Scroll_Title",0,0,-1,2,2,0);
		DB_TutorialInfo("TUT_Shovel","TUT_CAT_Exploring","TUT_Shovel_Title",0,0,-1,2,0,0);
		DB_TutorialInfo("TUT_Skill","TUT_CAT_Inventory","TUT_Skill_Title",0,0,-1,2,2,0);
		DB_TutorialInfo("TUT_SkillUnlock","TUT_CAT_Combat","TUT_SkillUnlock_Title",0,0,-1,2,0,0);
		DB_TutorialInfo("TUT_Stealing","TUT_CAT_Exploring","TUT_Stealing_Title",0,0,-1,3,0,0);
		DB_TutorialInfo("TUT_Waypoint","TUT_CAT_Exploring","TUT_Waypoint_Title",0,0,-1,2,0,0);
		DB_TutorialInfo("TUT_BondedAvatar","TUT_CAT_Social","TUT_BondedAvatar_Title",0,0,-1,1,16,0);
		DB_TutorialInfo("TUT_HotbarLocked","TUT_CAT_Combat","TUT_HotbarLocked_Title",0,3,-1,1,0,10);
		DB_TutorialInfo("TUT_Tooltips","TUT_CAT_Exploring","TUT_Tooltips_Title",1,0,-1,2,0,0);
		DB_TutorialInfo("TUT_Tooltips_Controller","TUT_CAT_Exploring","TUT_Tooltips_Title",2,0,-1,2,0,0);
		DB_TutorialInfo("TUT_TagVillain","TUT_CAT_Social","TUT_TagVillain_Title",0,0,-1,2,0,0);
		DB_TutorialInfo("TUT_TagHero","TUT_CAT_Social","TUT_TagHero_Title",0,0,-1,2,0,0);
		DB_TutorialInfo("TUT_Waypoint","TUT_CAT_Exploring","TUT_Waypoint_Title",0,2,3,1,0,0);
		
	}
	KB
	{
		//REGION Tutorial Message
		PROC
		ProcPlayTut((CHARACTERGUID)_Char,(STRING)_Message)
		AND 
		DB_TutorialInfo(_Message,(STRING)_Cat,(STRING)_Title,(INTEGER)_ControllerType,(INTEGER)_ModalType,(INTEGER)_Duration,(INTEGER)_Priority,(INTEGER)_Flags,(INTEGER)_MinimumPlaytime)
		THEN
		ShowTutorial(_Char,_Message,_Cat,_Title,_ControllerType,_ModalType,_Duration,_Priority,_Flags,_MinimumPlaytime);
		 
		PROC
		ProcPlayTut((CHARACTERGUID)_Char,(STRING)_Message)
		AND 
		DB_TutorialInfo_MsgBox(_Message,(STRING)_Cat,(STRING)_Title,(INTEGER)_ControllerType,(INTEGER)_ModalType,(INTEGER)_Duration,(INTEGER)_Priority,(INTEGER)_Flags,(INTEGER)_MinimumPlaytime)
		THEN
		OpenMessageBox(_Char,_Message);
		 
		PROC
		ProcPlayTut((CHARACTERGUID)_Char,(STRING)_Message)
		AND
		NOT DB_TutorialInfo(_Message,_,_,_,_,_,_,_,_)
		AND
		NOT DB_TutorialInfo_MsgBox(_Message,_,_,_,_,_,_,_,_)
		AND
		StringConcatenate("Tutorial Message without info: ",_Message,_ErrorMessage)
		THEN
		DebugBreak(_ErrorMessage);
		ShowTutorial(_Char,_Message,"","",0,0,-1,3,0,0);
		//END_REGION
		
		//REGION Tutorial From ProximityTutorial.itemscript
		IF
		CharacterItemEvent(_Character,_Item,"LaunchTutorialMessage")
		AND
		GetVarString(_Item,"TutorialMessage",_TutorialName)
		THEN
		PROC_CheckPlayTut(_Character,_TutorialName);
		//END_REGION
		
		//REGION Movement Popup
		
		// See also _GLOBAL_TutorialMessages_MovementDetection
		IF
		DB_GLO_Tutorial_StartMovementTutorial(1)
		THEN
		TimerLaunch("TUT_Movement",5000);
		
		IF
		TimerFinished("TUT_Movement")
		AND
		DB_IsPlayer(_Player)
		AND
		NOT DB_GLOBAL_TutorialMessages_MovementTutFinishedFor(_Player)
		THEN
		PROC_CheckPlayTut(_Player,"TUT_Movement");
		
		IF
		TimerFinished("TUT_Camera")
		THEN
		PROC_CheckPlayTut("TUT_Camera");
		DB_InitialTutorialsShown(1);
		//END_REGION 
		
		//REGION Inventory Popup
		IF
		ItemTemplateAddedToCharacter(_,_,_Player)
		AND
		_Player.DB_IsPlayer()
		AND
		DB_InitialTutorialsShown(1)
		THEN
		ProcCheckInventoryTutorial(_Player);
		
		PROC
		ProcCheckInventoryTutorial((GUIDSTRING)_Player)
		AND
		IsSpeakerReserved(_Player,0)
		THEN
		PROC_CheckPlayTut((CHARACTERGUID)_Player,"TUT_Inventory");
		
		PROC
		ProcCheckInventoryTutorial((GUIDSTRING)_Player)
		AND
		IsSpeakerReserved(_Player,1)
		THEN
		DB_InventoryMessageQueued(_Player);
		
		IF
		DialogEnded(_,_ID)
		AND
		DB_DialogPlayers(_ID,_Player,_)
		AND
		DB_InventoryMessageQueued(_Player)
		THEN
		NOT DB_InventoryMessageQueued(_Player);
		//force a frame delay to give Osiris a chance to run other logic, in case this dialog causes combat or another dialog
		SetStoryEvent(_Player,"GLO_CheckInventoryTutorial");
		
		IF
		StoryEvent(_Player,"GLO_CheckInventoryTutorial")
		AND
		QRY_SpeakerIsAvailable(_Player)
		THEN
		PROC_CheckPlayTut((CHARACTERGUID)_Player,"TUT_Inventory");
		
		
		//END_REGION 
		
		//REGION Combat Popup
		IF				
		ObjectTurnStarted((CHARACTERGUID)_Player)
		AND
		_Player.DB_IsPlayer()
		AND
		CharacterGetAbility(_Player, "Loremaster", _Val)
		AND
		_Val > 0
		AND
		DB_CharCountHelper(_Player,"CombatTurnCounter",_Turn)
		AND
		_Turn >= 6
		THEN
		PROC_CheckPlayTut(_Player,"TUT_Combat_Examine");
		//END_REGION 
		
		//REGION Tool Popups
		IF
		ItemTemplateAddedToCharacter(TOOL_LockPick_A_06d0eecb-4271-42a7-bd8c-4cbf24927197,_,_Player)
		AND
		_Player.DB_IsPlayer()
		THEN
		PROC_CheckPlayTut(_Player, "TUT_Lockpick");
		
		IF
		ItemTemplateAddedToCharacter(TOOL_Hammer_Repair_A_be7226da-7211-4250-be95-ca780bcdb3df,_,_Player)
		AND
		_Player.DB_IsPlayer()
		THEN
		PROC_CheckPlayTut(_Player, "TUT_Hammer");
		
		IF
		ItemTemplateAddedToCharacter(TOOL_IdentifyingGlass_A_32288ce4-3d8d-46b3-a655-598350a96201,_,_Player)
		AND
		_Player.DB_IsPlayer()
		THEN
		PROC_CheckPlayTut(_Player, "TUT_IdentifyingGlass");
		
		IF
		ItemTemplateAddedToCharacter(TOOL_Trap_DisarmToolkit_9fda335e-2220-4ae9-a4c2-2424d5ef5165,_,_Player)
		AND
		_Player.DB_IsPlayer()
		THEN
		PROC_CheckPlayTut(_Player, "TUT_Disarm");
		
		IF
		ItemTemplateAddedToCharacter(TOOL_Shovel_A_41486dd2-3fd5-464e-870e-844120cf0517,_,_Player)
		AND
		_Player.DB_IsPlayer()
		THEN
		PROC_CheckPlayTut(_Player,"TUT_Shovel");
		//END_REGION
		
		IF
		ObjectTurnStarted((CHARACTERGUID)_Player)
		AND
		_Player.DB_IsPlayer()
		AND
		CharacterGetHitpointsPercentage(_Player,_Percentage)
		AND
		_Percentage < 25
		AND
		_Percentage > 0
		AND
		DB_PotionDone(1)
		THEN
		PROC_CheckPlayTut(_Player,"TUT_Flee");
		
		IF
		ObjectTurnStarted((CHARACTERGUID)_Player)
		AND
		_Player.DB_IsPlayer()
		AND
		CharacterGetHitpointsPercentage(_Player,_Percentage)
		AND
		_Percentage < 25
		AND
		_Percentage > 0
		THEN
		PROC_CheckPlayTut(_Player,"TUT_Potion");
		DB_PotionDone(1);
		
		IF
		CharacterItemEvent(_, _Item, "WaypointDiscovered")
		AND
		DB_WaypointInfo((ITEMGUID)_Item,(TRIGGERGUID)_,(STRING)_)
		THEN
		DB_WaypointTuto(1);
		
		IF
		CharacterDied(_Player)
		AND
		_Player.DB_IsPlayer()
		THEN
		PROC_CheckPlayTutWithDelay(_Player,"TUT_Died",2000);
		
		IF
		StoryEvent((CHARACTERGUID)_Player,_Event)
		AND
		DB_Event2DisplayText(_Event,_Text) //See the goal TrapReactions for context about that DB
		AND
		_Player.DB_IsPlayer()
		THEN
		PROC_CheckPlayTutWithDelay(_Player,"TUT_Perception",2000);
		
		IF
		CharacterUsedItem(_Player,_Mound)
		AND
		DB_ShovelArea(_,_,_Mound)
		THEN
		PROC_CheckPlayTut(_Player,"TUT_Mound");
		
		IF
		TextEventSet("axeltuto")
		THEN
		DB_StartTutMessages(1);
		
		IF
		CharacterLeveledUp(_Player)
		AND
		_Player.DB_IsPlayer()
		THEN
		PROC_CheckPlayTut(_Player, "TUT_LevelUp");
		
		IF
		ItemAddedToCharacter(_Item, _Player)
		AND
		DB_InitialTutorialsShown(1)
		AND
		DB_IsPlayer(_Player)
		AND
		ItemHasOnUse(_Item,"skillbook",1)
		THEN
		PROC_CheckPlayTut(_Player,"TUT_Skill");
		
		IF
		ItemAddedToCharacter(_Item, _Player)
		AND
		DB_InitialTutorialsShown(1)
		AND
		DB_IsPlayer(_Player)
		AND
		ItemHasOnUse(_Item,"scrollarrow",1)
		AND
		IsTagged(_Item,"GRENADES",0)
		THEN
		PROC_CheckPlayTut(_Player, "TUT_Scroll");
		
		IF
		ItemAddedToCharacter(_Item, _Player)
		AND
		DB_InitialTutorialsShown(1)
		AND
		DB_IsPlayer(_Player)
		AND
		ItemHasOnUse(_Item,"book",1)
		THEN
		PROC_CheckPlayTut(_Player, "TUT_Book");
		
		IF
		DifficultyChanged(0)
		THEN
		DB_TUT_PlayOnEasy(1);
		
		IF
		DifficultyChanged(_Int)
		AND
		_Int != 0
		THEN
		NOT DB_TUT_PlayOnEasy(1);
		
		IF
		SkillAdded(_Player,_,1) 
		AND
		DB_IsPlayer(_Player)
		AND
		CharacterIsControlled(_Player,1)
		AND
		DB_InitialTutorialsShown(1)
		AND
		NOT DB_TutorialMessages_SkillUnlockDone(_Player)
		THEN
		ProcObjectTimer(_Player,"TUT_SkillUnlock",500);
		
		PROC
		ProcObjectTimerFinished(_Player,"TUT_SkillUnlock")
		THEN
		PROC_TutorialMessage_SkillUnlockAfterDialog((CHARACTERGUID)_Player);
		
		PROC
		PROC_TutorialMessage_SkillUnlockAfterDialog((CHARACTERGUID)_Player)
		AND
		NOT DB_DialogPlayers(_,_Player,_)
		THEN
		DB_TutorialMessages_SkillUnlockDone(_Player);
		PROC_CheckPlayTut(_Player, "TUT_SkillUnlock");
		
		PROC
		PROC_TutorialMessage_SkillUnlockAfterDialog((CHARACTERGUID)_Player)
		AND
		NOT DB_TutorialMessages_SkillUnlockDone(_Player)
		AND
		DB_DialogPlayers(_Inst,_Player,_)
		AND
		NOT DB_AutomatedDialog(_Inst)
		THEN
		DB_TutorialMessage_CheckEndDialog_SkillTut(_Inst,_Player);
		
		PROC
		PROC_TutorialMessage_SkillUnlockAfterDialog((CHARACTERGUID)_Player)
		AND
		NOT DB_TutorialMessages_SkillUnlockDone(_Player)
		AND
		DB_DialogPlayers(_Inst,_Player,_)
		AND
		DB_AutomatedDialog(_Inst)
		THEN
		DB_TutorialMessage_CheckEndAutomatedDialog_SkillTut(_Inst,_Player);
		
		IF
		DialogEnded(_,_Inst)
		AND
		DB_TutorialMessage_CheckEndDialog_SkillTut(_Inst,_Player)
		THEN
		NOT DB_TutorialMessage_CheckEndDialog_SkillTut(_Inst,_Player);
		DB_TutorialMessages_SkillUnlockDone(_Player);
		PROC_CheckPlayTut(_Player, "TUT_SkillUnlock");
		
		IF
		AutomatedDialogEnded(_,_Inst)
		AND
		DB_TutorialMessage_CheckEndAutomatedDialog_SkillTut(_Inst,_Player)
		THEN
		NOT DB_TutorialMessage_CheckEndAutomatedDialog_SkillTut(_Inst,_Player);
		DB_TutorialMessages_SkillUnlockDone(_Player);
		PROC_CheckPlayTut(_Player, "TUT_SkillUnlock");
		
		IF
		ItemTemplateOpening(_,_Item, _Player)
		AND
		DB_IsPlayer(_Player)
		AND
		ItemIsContainer(_Item, 1)
		AND
		DB_ItemOpened(_Nb)
		AND
		_Nb == 10
		THEN
		PROC_CheckPlayTut(_Player, "TUT_DragIcon");
		
		IF
		ItemTemplateOpening(_,_Item, _Player)
		AND
		DB_IsPlayer(_Player)
		AND
		ItemIsContainer(_Item, 1)
		AND
		DB_ItemOpened(_Nb)
		AND
		IntegerSum(_Nb,1,_NewNb)
		THEN
		NOT DB_ItemOpened(_Nb);
		DB_ItemOpened(_NewNb);
		
		IF
		DialogStarted(_,_Instance)
		AND
		DB_DialogNPCs(_Instance,_Animal,1)
		AND
		DB_DialogPlayers(_Instance,_Player,1)
		AND
		CharacterHasTalent((CHARACTERGUID)_Player,"AnimalEmpathy",0)
		AND
		IsTagged(_Animal,"ANIMAL",1)
		THEN
		PROC_CheckPlayTut(_Player,"TUT_NoPetPal");
		
		IF
		DialogStarted(_,_Instance)
		AND
		DB_DialogNPCs(_Instance,_Animal,1)
		AND
		DB_DialogPlayers(_Instance,_Player,1)
		AND
		CharacterHasTalent((CHARACTERGUID)_Player,"AnimalEmpathy",1)
		AND
		IsTagged(_Animal,"ANIMAL",1)
		THEN
		PROC_CheckPlayTut(_Player,"TUT_PetPal");
		
		IF
		ItemAddedToCharacter(_Item,_Player)
		AND
		DB_IsPlayer(_Player)
		AND
		DB_CharCountHelper(_Player,"CombatTurnCounter",_Turn)
		AND
		_Turn >= 3
		AND
		ItemHasOnUse(_Item,"scrollarrow",1)
		AND
		ItemIsEquipable(_Item,0)
		THEN
		PROC_CheckPlayTut(_Player,"TUT_HotbarAssignment");
		
		IF
		ItemAddedToCharacter(_Item,_Player)
		AND
		DB_InitialTutorialsShown(1)
		AND
		DB_IsPlayer(_Player)
		AND
		ItemIsEquipable(_Item,1)
		THEN
		PROC_CheckPlayTut(_Player,"TUT_Equipment");
		
		IF
		CharacterUsedItem(_Player,_Item)
		AND
		DB_IsPlayer(_Player)
		AND
		ObjectIsItem(_Item,1)
		AND
		ItemIsLocked(_Item,1)
		THEN
		PROC_CheckPlayTut(_Player,"TUT_Locked");
		DB_TUT_ShowedTutLocked(1);
		
		IF
		CharacterItemEvent(_Character, _,"WaypointDiscovered")
		THEN
		PROC_CheckPlayTut(_Character, "TUT_Waypoint");
		
	}
	EXIT
	{
		
	}
}
Goal(32).Title("_GLOBAL_TutorialMessages_MovementDetection");
Goal(32)
{
	INIT
	{
		// Don't show the movement tutorial for players that move before the tutorial is shown
		
		// Trigger the camera tutorial 10 seconds after all players have moved, or
		// 10 seconds after the first player closed the movement tutorial box
		
	}
	KB
	{
		// Triggers to detect that someone moved from their initial position
		IF
		DB_Tutorial_PlayerMovementDetectionTrigger((TRIGGERGUID)_Trigger)
		THEN
		TriggerRegisterForPlayers(_Trigger);
		
		// Player entered detection trigger -> won't get movement tutorial
		// + check whether everyone has moved (if so, complete this goal
		// and schedule the camera tutorial)
		IF
		CharacterEnteredTrigger(_Player,_Trigger)
		AND
		DB_Tutorial_PlayerMovementDetectionTrigger(_Trigger)
		THEN
		PROC_GLOBAL_TutorialMessages_PlayerMoved(_Player);
		
		// Player got the movement tutorial -> record so we know
		// we should only schedule the camera tutorial after a
		// a movement tutorial box has been closed
		PROC
		PROC_CheckPlayTut(_Char,"TUT_Movement")
		THEN
		DB_GlobalTutorialMessages_TUT_Movement_Shown(1);
		PROC_GLOBAL_TutorialMessages_PlayerMoved(_Char);
		
		//REGION Handle a player moving or getting the movement tutorial
		// This player has moved or got the tutorial
		PROC
		PROC_GLOBAL_TutorialMessages_PlayerMoved((CHARACTERGUID)_Player)
		THEN
		DB_GLOBAL_TutorialMessages_MovementTutFinishedFor(_Player);
		
		// Anyone left that didn't move or didn't get the tutorial?
		PROC
		PROC_GLOBAL_TutorialMessages_PlayerMoved((CHARACTERGUID)_Player)
		AND
		DB_IsPlayer(_AnyPlayer)
		AND
		NOT DB_GLOBAL_TutorialMessages_MovementTutFinishedFor(_AnyPlayer)
		THEN
		DB_GLOBAL_TutorialMessages_MovementTutUnfinished(1);
		
		// No one left -> unregister movement detection triggers
		PROC
		PROC_GLOBAL_TutorialMessages_PlayerMoved((CHARACTERGUID)_Player)
		AND
		NOT DB_GLOBAL_TutorialMessages_MovementTutUnfinished(1)
		AND
		DB_Tutorial_PlayerMovementDetectionTrigger(_Trigger)
		THEN
		ProcTriggerUnregisterForPlayers(_Trigger);
		NOT DB_Tutorial_PlayerMovementDetectionTrigger(_Trigger);
		
		// No one left -> schedule camera tutorial right away if everyone
		// skipped the movement tutorial and complete goal
		PROC
		PROC_GLOBAL_TutorialMessages_PlayerMoved((CHARACTERGUID)_Player)
		AND
		NOT DB_GLOBAL_TutorialMessages_MovementTutUnfinished(1)
		AND
		NOT DB_GlobalTutorialMessages_TUT_Movement_Shown(1)
		THEN
		TimerLaunch("TUT_Camera",10000);
		GoalCompleted;
		
		// Clean up
		PROC
		PROC_GLOBAL_TutorialMessages_PlayerMoved((CHARACTERGUID)_Player)
		THEN
		NOT DB_GLOBAL_TutorialMessages_MovementTutUnfinished(1);
		//END_REGION
		
		// At least one player got the movement tutorial and dismissed it
		// -> schedule the camera tutorial
		IF
		TutorialBoxClosed(_,_Message)
		AND
		StringContains(_Message,"TUT_Movement",1)
		AND
		NOT DB_Tutorial_PlayerCameraTutorialTimerLaunched(1)
		THEN
		// Only launch once, multiple players could have gotten this dialog
		DB_Tutorial_PlayerCameraTutorialTimerLaunched(1);
		TimerLaunch("TUT_Camera",10000);
		GoalCompleted;
		
	}
	EXIT
	{
		NOT DB_GlobalTutorialMessages_TUT_Movement_Shown(1);
		NOT DB_Tutorial_PlayerCameraTutorialTimerLaunched(1);
		
	}
}
Goal(33).Title("_Greevers_Little_Helpers");
Goal(33)
{
	INIT
	{
		DB_Singleton("InitData",0);
		
		DB_GLO_AttributeCheck_Var(1,"Name","Attribute_Check_1_Name_080aa25a-eb82-4060-a20f-93f3f0a3ec85");
		DB_GLO_AttributeCheck_Var(1,"Difficulty","Attribute_Check_1_Difficulty_6645b5b8-4c17-4678-98b2-d5d718c36829");
		DB_GLO_AttributeCheck_Var(1,"LevelOverride","Attribute_Check_1_LevelOverride_08b97107-2d16-4ff5-a2e5-a01ed50e7135");
		DB_GLO_AttributeCheck_Var(1,"Source","Attribute_Check_1_Source_dd323f37-f472-4a67-9a44-5ca9f15646bb");
		DB_GLO_AttributeCheck_Var(1,"Target","Attribute_Check_1_Target_c46387f7-f39b-46c5-b6ec-baeccc34291a");
		
		DB_GLO_AttributeCheck_Var(2,"Difficulty","Attribute_Check_2_Difficulty_eab60140-a9e3-4579-b5fa-3cb5515c2282");
		DB_GLO_AttributeCheck_Var(2,"LevelOverride","Attribute_Check_2_LevelOverride_1dc16030-ece6-4677-ae14-62e7e9d1ac0e");
		DB_GLO_AttributeCheck_Var(2,"Name","Attribute_Check_2_Name_151dfe0f-6575-4ce2-bedc-6f157abdb36e");
		DB_GLO_AttributeCheck_Var(2,"Source","Attribute_Check_2_Source_c40af148-2c37-444b-a462-4387a4c6cede");
		DB_GLO_AttributeCheck_Var(2,"Target","Attribute_Check_2_Target_b8df81e7-d122-452b-bfaa-f9bbe87fd387");
		
		DB_GLO_AttributeCheck_Var(3,"Difficulty","Attribute_Check_3_Difficulty_ff545cea-32e3-4a9a-b005-f3a6e0f0cabd");
		DB_GLO_AttributeCheck_Var(3,"LevelOverride","Attribute_Check_3_LevelOverride_6e3f0bc5-636f-48ad-ad0a-642c3146302b");
		DB_GLO_AttributeCheck_Var(3,"Name","Attribute_Check_3_Name_8281a807-0ae5-4ada-8dc5-3b859310c1f5");
		DB_GLO_AttributeCheck_Var(3,"Source","Attribute_Check_3_Source_32f31478-7329-4902-bb66-a9043819102c");
		DB_GLO_AttributeCheck_Var(3,"Target","Attribute_Check_3_Target_65312317-50da-4cce-a6e9-725a85e7fd46");
		
	}
	KB
	{
		//REGION Stacks
		
		//Stacks are a useful tool to mimic a FILO stack structure.
		//Add items using the Stack((STRING)_ID,_Value) command.
		//At any time you can query for DB_TopOfStackCharacter((STRING)_ID,_Value), DB_TopOfStackItem((STRING)_ID,_Value) or DB_TopOfStackTrigger((STRING)_ID,_Value)
		//If you wish to pop the top member of the stack, just call PopStack((STRING)_ID);
		PROC
		Stack_Internal((STRING)_ID,(STRING)_Value)
		AND
		NOT DB_StackInternalCounter(_,_ID)
		THEN
		DB_StackInternalCounter(0,_ID);
		DB_TopOfStack(_ID,_Value);
		
		PROC
		Stack_Internal((STRING)_ID,(STRING)_Value)
		AND
		DB_StackInternalCounter(_Amount,_ID)
		AND
		IntegerSum(_Amount,1,_NewAmount)
		AND
		DB_TopOfStack(_ID,_TopValue)
		THEN
		NOT DB_StackInternalCounter(_Amount,_ID);
		DB_StackInternalCounter(_NewAmount,_ID);
		DB_StackInternalMember(_NewAmount,_ID,_Value);
		NOT DB_TopOfStack(_ID,_TopValue);
		DB_TopOfStack(_ID,_Value);
		
		PROC
		PopStack((STRING)_ID)
		AND
		DB_StackInternalCounter(1,_ID)
		AND
		DB_TopOfStack(_ID,_Value)
		THEN
		NOT DB_TopOfStack(_ID,_Value);
		NOT DB_StackInternalCounter(1,_ID);
		NOT DB_StackInternalMember(1,_ID,_Value);
		ProcClearOldTopOfStack(_ID);
		
		PROC
		PopStack((STRING)_ID)
		AND
		DB_StackInternalCounter(_Amount,_ID)
		AND
		IntegerSubtract(_Amount,1,_NewAmount)
		AND
		DB_StackInternalMember(_Amount,_ID,_OldTopValue)
		AND
		DB_StackInternalMember(_NewAmount,_ID,_NewTopValue)
		THEN
		NOT DB_StackInternalCounter(_Amount,_ID);
		DB_StackInternalCounter(_NewAmount,_ID);
		NOT DB_StackInternalMember(_Amount,_ID,_OldTopValue);
		NOT DB_TopOfStack(_ID,_OldTopValue);
		DB_TopOfStack(_ID,_NewTopValue);
		
		PROC
		Stack((STRING)_ID,(GUIDSTRING)_Object)
		AND
		GetUUID(_Object,_UUID)
		THEN
		DB_Stack_UUID(_Object,_UUID);
		Stack_Internal(_ID,_UUID);
		
		IF
		DB_TopOfStack(_ID,_UUID)
		AND
		DB_Stack_UUID(_Value,_UUID)
		THEN
		ProcClearOldTopOfStack(_ID);
		DB_TopOfStackObject(_ID,_Value);
		
		PROC
		ProcClearOldTopOfStack((STRING)_ID)
		AND
		DB_TopOfStackObject(_ID,_Value)
		THEN
		NOT DB_TopOfStackObject(_ID,_Value);
		
		//END_REGION
		
		//REGION Default Parameters
		PROC
		CharacterLookAt((CHARACTERGUID)_Character1,(GUIDSTRING)_Target)
		THEN
		CharacterLookAt(_Character1,_Target,0);
		
		PROC
		PlayAnimation((GUIDSTRING)_Object,(STRING)_String)
		THEN
		PlayAnimation(_Object,_String,"");
		
		PROC
		TeleportTo((GUIDSTRING)_Object,(GUIDSTRING)_Target)
		THEN
		TeleportTo(_Object,_Target,"",1);
		
		PROC
		ApplyStatus((GUIDSTRING)_Target,(STRING)_Status,(REAL)_Duration)
		THEN
		ApplyStatus(_Target,_Status,_Duration,0);
		
		PROC
		PartySetFlag((CHARACTERGUID)_Character,(STRING)_Event)
		THEN
		PartySetFlag(_Character,_Event,0);
		
		PROC
		ObjectSetFlag((GUIDSTRING)_Object,(STRING)_Event)
		THEN
		ObjectSetFlag(_Object,_Event,0);
		
		PROC
		ObjectClearFlag((GUIDSTRING)_Object,(STRING)_Event)
		THEN
		ObjectClearFlag(_Object,_Event,0);
		
		PROC
		UserSetFlag((CHARACTERGUID)_Character,(STRING)_Event)
		THEN
		UserSetFlag(_Character,_Event,0);
		
		PROC
		CharacterUseSkill((CHARACTERGUID)_Character,(STRING)_Skill,(GUIDSTRING)_Target)
		THEN
		CharacterUseSkill(_Character,_Skill,_Target,0,0,0);
		
		PROC
		CharacterUseSkill((CHARACTERGUID)_Character,(STRING)_Skill,(GUIDSTRING)_Target,(INTEGER)_ForceResetCooldown)
		THEN
		CharacterUseSkill(_Character,_Skill,_Target,_ForceResetCooldown,0,0);
		
		PROC
		CharacterUseSkill((CHARACTERGUID)_Character,(STRING)_Skill,(GUIDSTRING)_Target,(INTEGER)_ForceResetCooldown, (INTEGER)_IgnoreHasSkill)
		THEN
		CharacterUseSkill(_Character,_Skill,_Target,_ForceResetCooldown,_IgnoreHasSkill,0);
		
		PROC
		CharacterMakePlayer((CHARACTERGUID)_Character)
		THEN
		CharacterMakePlayer((CHARACTERGUID)_Character,NULL_00000000-0000-0000-0000-000000000000);
		//END_REGION
		
		//REGION Trigger Spotter
		QRY
		Query_IsPlayerHiding((CHARACTERGUID)_Char)
		AND
		HasActiveStatus(_Char,"SNEAKING",1)
		THEN
		DB_NOOP(1);
		
		QRY
		Query_IsPlayerHiding((CHARACTERGUID)_Char)
		AND
		HasActiveStatus(_Char,"INVISIBLE",1)
		THEN
		DB_NOOP(1);
		
		IF
		DB_OneShot_DialogTrigger_NewSystem((TRIGGERGUID)_Trigger,(STRING)_,(CHARACTERGUID)_Spotter)
		THEN
		SetVarInteger(_Spotter,"IgnoreDialogChecks",0);
		DB_SneakTriggerSpotter(_Trigger,_Spotter);
		
		IF
		DB_OneShot_DialogTrigger_NewSystem((TRIGGERGUID)_Trigger,(STRING)_,(CHARACTERGUID)_Spotter1,(CHARACTERGUID)_Spotter2)
		THEN
		SetVarInteger(_Spotter1,"IgnoreDialogChecks",0);
		SetVarInteger(_Spotter2,"IgnoreDialogChecks",0);
		DB_SneakTriggerSpotter(_Trigger,_Spotter1);
		DB_SneakTriggerSpotter(_Trigger,_Spotter2);
		
		IF
		DB_OneShot_DialogTrigger_NewSystem((TRIGGERGUID)_Trigger,(STRING)_,(CHARACTERGUID)_Spotter1,(CHARACTERGUID)_Spotter2,(CHARACTERGUID)_Spotter3)
		THEN
		SetVarInteger(_Spotter1,"IgnoreDialogChecks",0);
		SetVarInteger(_Spotter2,"IgnoreDialogChecks",0);
		SetVarInteger(_Spotter3,"IgnoreDialogChecks",0);
		DB_SneakTriggerSpotter(_Trigger,_Spotter1);
		DB_SneakTriggerSpotter(_Trigger,_Spotter2);
		DB_SneakTriggerSpotter(_Trigger,_Spotter3);
		
		PROC
		ProcCharInTriggerSpotted((CHARACTERGUID)_Player,(TRIGGERGUID)_Trigger)
		AND
		DB_OneShot_DialogTrigger_NewSystem(_Trigger,_Dialog,_Spotter)
		THEN
		Proc_StartDialog(0,_Dialog,_Spotter,_Player);
		NOT DB_OneShot_DialogTrigger_NewSystem(_Trigger,_Dialog,_Spotter);
		
		PROC
		ProcCharInTriggerSpotted((CHARACTERGUID)_Player,(TRIGGERGUID)_Trigger)
		AND
		DB_OneShot_DialogTrigger_NewSystem(_Trigger,_Dialog,_Spotter1,_Spotter2)
		THEN
		Proc_StartDialog(0,_Dialog,_Spotter1,_Spotter2,_Player);
		NOT DB_OneShot_DialogTrigger_NewSystem(_Trigger,_Dialog,_Spotter1,_Spotter2);
		
		PROC
		ProcCharInTriggerSpotted((CHARACTERGUID)_Player,(TRIGGERGUID)_Trigger)
		AND
		DB_OneShot_DialogTrigger_NewSystem(_Trigger,_Dialog,_Spotter1,_Spotter2,_Spotter3)
		THEN
		Proc_StartDialog(0,_Dialog,_Spotter1,_Spotter2,_Spotter3,_Player);
		NOT DB_OneShot_DialogTrigger_NewSystem(_Trigger,_Dialog,_Spotter1,_Spotter2,_Spotter3);
		
		IF
		CharacterStatusRemoved(_Player,"SNEAKING",_)
		AND
		DB_IsPlayer(_Player)
		AND
		NOT Query_IsPlayerHiding(_Player)
		THEN
		SetStoryEvent(_Player,"BecameVisible");
		
		IF
		CharacterStatusRemoved(_Player,"INVISIBLE",_)
		AND
		DB_IsPlayer(_Player)
		AND
		NOT Query_IsPlayerHiding(_Player)
		THEN
		SetStoryEvent(_Player,"BecameVisible");
		
		IF
		CharacterStatusApplied(_Player,"SNEAKING",_)
		AND
		DB_IsPlayer(_Player)
		AND
		Query_IsPlayerHiding(_Player)
		THEN
		SetStoryEvent(_Player,"BecameInvisible");
		
		IF
		CharacterStatusApplied(_Player,"INVISIBLE",_)
		AND
		DB_IsPlayer(_Player)
		AND
		NOT Query_IsPlayerHiding(_Player)
		THEN
		SetStoryEvent(_Player,"BecameInvisible");
		
		IF
		DB_TriggerSendsSpotEvents(_Trigger)
		THEN
		ProcTriggerRegisterForPlayers(_Trigger);
		
		IF
		CharacterEnteredTrigger(_Player,_SpotTrigger)
		AND
		NOT Query_IsPlayerHiding(_Player)
		AND
		DB_TriggerSendsSpotEvents(_SpotTrigger)
		THEN
		DB_Event_CharacterAppearedInSpotTrigger(_Player,_SpotTrigger);
		NOT DB_Event_CharacterAppearedInSpotTrigger(_Player,_SpotTrigger);
		
		IF
		CharacterLeftTrigger(_Player,_SpotTrigger)
		AND
		NOT Query_IsPlayerHiding(_Player)
		AND
		DB_TriggerSendsSpotEvents(_SpotTrigger)
		THEN
		DB_Event_CharacterDisappearedInSpotTrigger(_Player,_SpotTrigger);
		NOT DB_Event_CharacterDisappearedInSpotTrigger(_Player,_SpotTrigger);
		
		IF
		StoryEvent((CHARACTERGUID)_Player,"BecameVisible")
		AND
		DB_InRegion(_Player,_SpotTrigger)
		AND
		DB_TriggerSendsSpotEvents(_SpotTrigger)
		THEN
		DB_Event_CharacterAppearedInSpotTrigger(_Player,_SpotTrigger);
		NOT DB_Event_CharacterAppearedInSpotTrigger(_Player,_SpotTrigger);
		
		IF
		StoryEvent((CHARACTERGUID)_Player,"BecameInvisible")
		AND
		DB_InRegion(_Player,_SpotTrigger)
		AND
		DB_TriggerSendsSpotEvents(_SpotTrigger)
		THEN
		DB_Event_CharacterDisappearedInSpotTrigger(_Player,_SpotTrigger);
		NOT DB_Event_CharacterDisappearedInSpotTrigger(_Player,_SpotTrigger);
		
		//END_REGION
		
		//REGION Global Event Memory
		IF
		GlobalFlagSet(_String)
		THEN
		DB_GlobalFlag(_String);
		
		IF
		GlobalFlagCleared(_String)
		THEN
		NOT DB_GlobalFlag(_String);
		//END_REGION
		
		//REGION Poof / Foop
		PROC
		Poof((GUIDSTRING)_Character)
		THEN
		Poof((GUIDSTRING)_Character,"RS3_FX_GP_ScriptedEvent_Teleport_GenericSmoke_01");
		
		PROC
		Poof((GUIDSTRING)_Character,(STRING)_Effect)
		AND
		GetRegion(_Character,_Region)
		AND
		DB_CurrentLevel(_Region)
		AND
		GetPosition(_Character,_X,_Y,_Z)
		THEN
		PlayEffectAtPosition(_Effect,_X,_Y,_Z);
		
		PROC
		Poof((GUIDSTRING)_Character,(STRING)_Effect)
		THEN
		SetOnStage(_Character,0);
		
		PROC
		Foop((GUIDSTRING)_Character)
		THEN
		Foop(_Character,"RS3_FX_GP_ScriptedEvent_Teleport_GenericSmoke_01");
		
		PROC
		Foop((GUIDSTRING)_Character,(STRING)_Effect)
		AND
		GetRegion(_Character,_Region)
		AND
		DB_CurrentLevel(_Region)
		AND
		GetPosition(_Character,_X,_Y,_Z)
		THEN
		PlayEffectAtPosition(_Effect,_X,_Y,_Z);
		
		PROC
		Foop((GUIDSTRING)_Character,(STRING)_Effect)
		THEN
		SetOnStage(_Character,1);
		
		IF
		StoryEvent(_Character,"GEN_GoOffStage")
		THEN
		SetOnStage(_Character,0);
		
		PROC
		Proc_PoofOnce((GUIDSTRING)_Character,(STRING)_OnlyOnce)
		AND
		NOT DB_OnlyOnce(_OnlyOnce)
		THEN
		Poof(_Character);
		DB_OnlyOnce(_OnlyOnce);
		//END_REGION
		
		//REGION Uniformly distributed Randoms (Fair random with memory)
		//Fair rand requires a UUID and a maxamount. The function will return [0,Maxamount-1]
		//When no previous data found, all possible numbers are added into an array.
		//Every FairRand query returns one random number from the array and removes it.
		//Only when the array is empty, is it reseeded.
		//Output: DB_FairRand_ReturnVal(INTEGER)
		
		//Clear return value
		QRY
		QRY_GetFairRand((STRING)_UUID,(INTEGER)_Amount)
		AND
		DB_FairRand_ReturnVal((INTEGER)_Number)
		THEN
		NOT DB_FairRand_ReturnVal(_Number);
		
		//If first time or all numbers used: reseed.
		QRY
		QRY_GetFairRand((STRING)_UUID,(INTEGER)_Amount)
		AND
		NOT DB_FairRand_Available(_UUID,_Amount,_)
		THEN
		Proc_SeedFairRand(_UUID,_Amount,_Amount);
		
		//Pick a random number from the available array (Put in new array with indeces, pick random index, return number)
		//Special case: Make sure that the first pick of a list is not the same as the last pick of the previous list
		QRY
		QRY_GetFairRand((STRING)_UUID,(INTEGER)_Amount)
		THEN
		DB_FairRandAmount(0);
		
		QRY
		QRY_GetFairRand((STRING)_UUID,(INTEGER)_Amount)
		AND
		_Amount > 1
		AND
		DB_FairRand_Last_Of_Previous_Seeding(_PreviousNumber)
		AND
		DB_FairRand_Available(_UUID,_Amount,_AvailableNumber)
		AND
		_PreviousNumber != _AvailableNumber
		AND
		DB_FairRandAmount(_Count)
		AND
		IntegerSum(_Count,1,_NewCount)
		THEN
		DB_FairRand_Array(_Count,_AvailableNumber);
		NOT DB_FairRandAmount(_Count);
		DB_FairRandAmount(_NewCount);
		DB_FairAmount_ListFilled(1);
		
		QRY
		QRY_GetFairRand((STRING)_UUID,(INTEGER)_Amount)
		AND
		DB_FairRand_Last_Of_Previous_Seeding(_Number)
		THEN
		NOT DB_FairRand_Last_Of_Previous_Seeding(_Number);
		
		QRY
		QRY_GetFairRand((STRING)_UUID,(INTEGER)_Amount)
		AND
		NOT DB_FairAmount_ListFilled(1)
		AND
		DB_FairRand_Available(_UUID,_Amount,_AvailableNumber)
		AND
		DB_FairRandAmount(_Count)
		AND
		IntegerSum(_Count,1,_NewCount)
		THEN
		DB_FairRand_Array(_Count,_AvailableNumber);
		NOT DB_FairRandAmount(_Count);
		DB_FairRandAmount(_NewCount);
		
		QRY
		QRY_GetFairRand((STRING)_UUID,(INTEGER)_Amount)
		AND
		DB_FairAmount_ListFilled(1)
		THEN
		NOT DB_FairAmount_ListFilled(1);
		
		QRY
		QRY_GetFairRand((STRING)_UUID,(INTEGER)_Amount)
		AND
		DB_FairRandAmount(_Count)
		AND
		_Count > 0
		AND
		Random(_Count,_Index)
		AND
		DB_FairRand_Array(_Index,_Number)
		THEN
		NOT DB_FairRand_Available(_UUID,_Amount,_Number);
		DB_FairRand_ReturnVal(_Number);
		
		//If this was the last value in the available list, remember it, so we don't pick it first in the next list.
		QRY
		QRY_GetFairRand((STRING)_UUID,(INTEGER)_Amount)
		AND
		NOT DB_FairRand_Available(_UUID,_Amount,_)
		AND
		DB_FairRand_ReturnVal(_Number)
		THEN
		DB_FairRand_Last_Of_Previous_Seeding(_Number);
		
		//Clean up temp vars
		QRY
		QRY_GetFairRand((STRING)_UUID,(INTEGER)_MaxAmount)
		AND
		DB_FairRandAmount(_Amount)
		THEN
		NOT DB_FairRandAmount(_Amount);
		
		QRY
		QRY_GetFairRand((STRING)_UUID,(INTEGER)_Amount)
		AND
		DB_FairRand_Array(_Index,_Number)
		THEN
		NOT DB_FairRand_Array(_Index,_Number);
		
		PROC
		Proc_SeedFairRand((STRING)_UUID,(INTEGER)_MaxAmount,(INTEGER)_Amount)
		AND
		_Amount > 0
		AND
		IntegerSubtract(_Amount,1,_NewAmount)
		THEN
		DB_FairRand_Available(_UUID,_MaxAmount,_NewAmount);
		Proc_SeedFairRand(_UUID,_MaxAmount,_NewAmount);
		//END_REGION
		
		//REGION Get Random position in coordinate-based area ignoring AI grid
		// Pass in two objects. Returns point within cube defined by their coordinates
		// Returns result in DB_Helper_GetAnyRandomPositionInArea_Result(_X,_Y,_Z)
		// NOTE: only tested currently with all coordinates of FirstPoint <= coordinates of _SecondPoint
		//   I don't know whether our random can handle a negative module.
		QRY
		QRY_Helper_GetAnyRandomPositionInArea((GUIDSTRING)_FirstPoint,(GUIDSTRING)_SecondPoint)
		AND
		DB_Helper_GetAnyRandomPositionInArea_Result(_X,_Y,_Z)
		THEN
		NOT DB_Helper_GetAnyRandomPositionInArea_Result(_X,_Y,_Z);
		
		QRY
		QRY_Helper_GetAnyRandomPositionInArea((GUIDSTRING)_BottomLeftBack,(GUIDSTRING)_TopRightFront)
		AND
		GetPosition(_BottomLeftBack,_X1,_Y1,_Z1)
		AND
		GetPosition(_TopRightFront,_X2,_Y2,_Z2)
		AND
		RealSubtract(_X2,_X1,_XDeltaReal)
		AND
		RealSubtract(_Y2,_Y1,_YDeltaReal)
		AND
		RealSubtract(_Z2,_Z1,_ZDeltaReal)
		AND
		RealProduct(_XDeltaReal,100.0,_XScaledDeltaReal)
		AND
		RealProduct(_YDeltaReal,100.0,_YScaledDeltaReal)
		AND
		RealProduct(_ZDeltaReal,100.0,_ZScaledDeltaReal)
		AND
		Integer(_XScaledDeltaReal,_XScaledDeltaInt)
		AND
		Integer(_YScaledDeltaReal,_YScaledDeltaInt)
		AND
		Integer(_ZScaledDeltaReal,_ZScaledDeltaInt)
		AND
		Random(_XScaledDeltaInt,_XRandScaledDeltaInt)
		AND
		Random(_YScaledDeltaInt,_YRandScaledDeltaInt)
		AND
		Random(_ZScaledDeltaInt,_ZRandScaledDeltaInt)
		AND
		Real(_XRandScaledDeltaInt,_XRandScaledDeltaReal)
		AND
		Real(_YRandScaledDeltaInt,_YRandScaledDeltaReal)
		AND
		Real(_ZRandScaledDeltaInt,_ZRandScaledDeltaReal)
		AND
		RealDivide(_XRandScaledDeltaReal,100.0,_XRandDeltaReal)
		AND
		RealDivide(_YRandScaledDeltaReal,100.0,_YRandDeltaReal)
		AND
		RealDivide(_ZRandScaledDeltaReal,100.0,_ZRandDeltaReal)
		AND
		RealSum(_X1,_XRandDeltaReal,_NewX)
		AND
		RealSum(_Y1,_YRandDeltaReal,_NewY)
		AND
		RealSum(_Z1,_ZRandDeltaReal,_NewZ)
		THEN
		DB_Helper_GetAnyRandomPositionInArea_Result(_NewX,_NewY,_NewZ);
		//END_REGION
		
		//REGION Singleton Variables //A variable which can only hold one value. All old value get overwritten.
		IF
		DB_Singleton(_VariableNam,_NewValue)
		AND
		DB_Singleton(_VariableNam,_OldValue)
		AND
		_NewValue != _OldValue
		THEN
		NOT DB_Singleton(_VariableNam,_OldValue);
		//END_REGION
		
		//REGION Only Once Rule Query
		QRY
		QueryOnlyOnce((STRING)_OnlyOnceUUID)
		AND
		NOT DB_OnlyOnce(_OnlyOnceUUID)
		THEN
		DB_OnlyOnce(_OnlyOnceUUID);
		//END_REGION
		
		//REGION Small macros
		PROC
		PROC_RemoveDialogFromCharacter((CHARACTERGUID)_NPC)
		THEN
		DialogRequestStop(_NPC);
		ProcRemoveAllDialogEntriesForSpeaker(_NPC);
		SetHasDialog(_Npc,0);
		//END_REGION
		
		//REGION Counter Helper
		PROC
		Proc_CountHelper((STRING)_ID)
		AND
		NOT DB_CountHelper(_ID,_)
		THEN
		DB_CountHelper(_ID,0);
		
		PROC
		Proc_CountHelper((STRING)_ID)
		AND
		DB_CountHelper(_ID,_OldValue)
		AND
		IntegerSum(_OldValue,1,_Value)
		THEN
		NOT DB_CountHelper(_ID,_OldValue);
		DB_CountHelper(_ID,_Value);
		
		PROC
		Proc_CharCountHelper((CHARACTERGUID)_Char,(STRING)_ID)
		THEN
		Proc_CharCountHelper(_Char,_ID,1);
		
		PROC
		Proc_CharCountHelper((CHARACTERGUID)_Char,(STRING)_ID,_)
		AND
		NOT DB_CharCountHelper(_Char,_ID,_)
		THEN
		DB_CharCountHelper(_Char,_ID,0);
		
		PROC
		Proc_CharCountHelper((CHARACTERGUID)_Char,(STRING)_ID,(INTEGER)_Count)
		AND
		DB_CharCountHelper(_Char,_ID,_OldValue)
		AND
		IntegerSum(_OldValue,_Count,_Value)
		THEN
		NOT DB_CharCountHelper(_Char,_ID,_OldValue);
		DB_CharCountHelper(_Char,_ID,_Value);
		
		PROC
		Proc_CharCountHelperReset((CHARACTERGUID)_Char,(STRING)_ID)
		AND
		DB_CharCountHelper(_Char,_ID,_Counter)
		THEN
		NOT DB_CharCountHelper(_Char,_ID,_Counter);
		//END_REGION
		
		//REGION Unregister a Trigger For a User
		// Note: this routines errs on the side of keeping the trigger unregistered.
		// E.g., if a character is assigned to a user without other characters, triggers
		// will kept be kept unregistered for that character if they had been unregistered
		// before.
		PROC 
		ProcUnregisterForUser((TRIGGERGUID)_Trigger,(CHARACTERGUID)_Player)
		AND
		CharacterGetReservedUserID(_Player,_UserID)
		AND 
		DB_IsPlayer(_OtherPlayer)
		AND
		CharacterGetReservedUserID(_OtherPlayer,_UserID)
		THEN 
		DB_TriggerUnregisteredForUserChar(_Trigger,_OtherPlayer);
		TriggerUnregisterForCharacter(_Trigger,_OtherPlayer);
		
		IF
		CharacterReservedUserIDChanged(_Player,_UserID)
		AND
		DB_IsPlayer(_Player)
		AND
		DB_IsPlayer(_OtherPlayer)
		AND
		NOT DB_UnregisterForUserIDChanged(1)
		AND
		_OtherPlayer != _Player
		AND
		CharacterGetReservedUserID(_OtherPlayer,_UserID)
		THEN
		DB_UnregisterForUserIDChanged(1);
		// Only have to call this for one character, because this logic keeps it the
		// same for all of the characters assigned to a single user
		ProcUnregisterForUserIDChanged(_OtherPlayer,_Player);
		
		PROC
		ProcUnregisterForUserIDChanged((CHARACTERGUID)_ExistingPlayer,(CHARACTERGUID)_NewPlayer)
		AND
		DB_TriggerUnregisteredForUserChar(_Trigger,_ExistingPlayer)
		AND
		NOT DB_TriggerUnregisteredForUserChar(_Trigger,_NewPlayer)
		THEN
		DB_TriggerUnregisteredForUserChar(_Trigger,_NewPlayer);
		TriggerUnregisterForCharacter(_Trigger,_NewPlayer);
		
		PROC
		ProcUnregisterForUserIDChanged((CHARACTERGUID)_ExistingPlayer,(CHARACTERGUID)_NewPlayer)
		AND
		DB_TriggerUnregisteredForUserChar(_Trigger,_NewPlayer)
		AND
		NOT DB_TriggerUnregisteredForUserChar(_Trigger,_ExistingPlayer)
		THEN
		NOT DB_TriggerUnregisteredForUserChar(_Trigger,_NewPlayer);
		TriggerRegisterForCharacter(_Trigger,_NewPlayer);
		
		IF
		CharacterReservedUserIDChanged(_Player,_UserID)
		THEN
		NOT DB_UnregisterForUserIDChanged(1);
		
		//END_REGION
		
		//REGION Turn Skipping
		//While in DB_CharacterSkipTurn(_Char), skip turn
		//
		IF
		ObjectFlagSet("GEN_EndTurn",_Char,_)
		THEN
		EndTurn(_Char);
		ObjectClearFlag(_Char,"GEN_EndTurn",0);
		
		IF
		ObjectFlagSet("GEN_SkipToTurn",_Char,_)
		AND
		DB_CombatObjects(_Char,_)
		THEN
		DB_CharacterSkipTurn(_Char);
		ObjectClearFlag(_Char,"GEN_SkipToTurn",0);
		
		IF
		ObjectTurnStarted(_Char)
		AND
		DB_CharacterSkipTurn(_Char)
		THEN
		EndTurn(_Char);
		
		PROC
		Proc_PurgeSkipTurnDB()
		AND
		DB_CharacterSkipTurn(_Char)
		THEN
		NOT DB_CharacterSkipTurn(_Char);
		
		IF
		ObjectTurnStarted(_Char)
		AND
		DB_SkipToCharactersTurn(_CharsTurn)
		AND
		DB_CombatObjects(_Char,_ID)
		AND
		DB_CombatObjects(_CharsTurn,_ID)
		AND
		_Char != _CharsTurn
		THEN
		EndTurn(_Char);
		
		IF
		ObjectTurnStarted(_Char)
		AND
		DB_SkipToCharactersTurn(_Char)
		THEN
		NOT DB_SkipToCharactersTurn(_Char);
		
		IF
		ObjectFlagSet("GEN_DisappearOutOfSight",(CHARACTERGUID)_Char,_)
		THEN
		ProcCharacterDisappearOutOfSight(_Char,0,1,"",0);
		ObjectClearFlag(_Char,"GEN_DisappearOutOfSight",0);
		
		IF
		ObjectLeftCombat((CHARACTERGUID)_Char,_)
		AND
		ObjectGetFlag(_Char,"GEN_DisappearOutOfSightWhenAvailable",1)
		AND
		QRY_SpeakerIsAvailable(_Char)
		THEN
		ProcCharacterDisappearOutOfSight(_Char,0,1,"",0);
		ObjectClearFlag(_Char,"GEN_DisappearOutOfSightWhenAvailable",0);
		
		IF
		DialogEnded(_,_ID)
		AND
		DialogGetInvolvedNPC(_ID,1,(CHARACTERGUID)_Char)
		AND
		ObjectGetFlag(_Char,"GEN_DisappearOutOfSightWhenAvailable",1)
		AND
		QRY_SpeakerIsAvailable(_Char)
		THEN
		ProcCharacterDisappearOutOfSight(_Char,0,1,"",0);
		ObjectClearFlag(_Char,"GEN_DisappearOutOfSightWhenAvailable",0);
		
		
		//END_REGION
		
		//REGION Move an item locally
		//Add to an items X, Y and Z values
		//
		PROC 
		ProcItemLocalMove((ITEMGUID)_Item,(REAL)_PlusX,(REAL)_PlusY,(REAL)_PlusZ,(REAL)_Speed,(REAL)_Acceleration)
		AND
		GetPosition(_Item,_X,_Y,_Z)
		AND
		RealSum(_X,_PlusX,_TargetX)
		AND
		RealSum(_Y,_PlusY,_TargetY)
		AND
		RealSum(_Z,_PlusZ,_TargetZ)
		THEN
		Proc_ItemMoveToPosition(_Item,_TargetX,_TargetY,_TargetZ,_Speed,_Acceleration);
		
		
		//END_REGION
		
		//REGION Force End a Dialog
		//for use in behaviour scripts 
		IF
		StoryEvent((GUIDSTRING)_Object,"ForceStopDialog")
		THEN
		ProcForceStopDialog(_Object);
		
		PROC 
		ProcForceStopDialog((GUIDSTRING)_Object)
		THEN
		DialogRequestStop(_Object);
		
		//END_REGION
		
		//REGION Generic hostile after dialog
		//NPC in the dialogue will go hostile to the Player that this event is set on at the end of the dialog
		IF
		ObjectFlagSet("FactionHostileToIndivPlayerAfterDialog",(CHARACTERGUID)_Player,_Id)
		THEN
		DB_HostileToIndivPlayerAfterDialog(_Player,_Id);
		
		IF
		DialogEnded(_,_Id)
		AND
		DB_HostileToIndivPlayerAfterDialog(_Player,_Id)
		AND
		DB_DialogNPCs(_Id,_Char,_)
		THEN
		ProcSetHostileToIndivPlayer((CHARACTERGUID)_Char,_Player);
		ObjectClearFlag(_Player,"FactionHostileToIndivPlayerAfterDialog",_Id);
		NOT DB_HostileToIndivPlayerAfterDialog(_Player,_Id);
		
		
		//Temp Hostility
		IF
		ObjectFlagSet("TemporaryHostilityAfterDialog",(CHARACTERGUID)_Player,_Id)
		THEN
		DB_TemporaryHostilityAfterDialog(_Player,_Id);
		
		IF
		DialogEnded(_,_Id)
		AND
		DB_TemporaryHostilityAfterDialog(_Player,_Id)
		AND
		DB_DialogNPCs(_Id,_Char,_)
		THEN
		ProcMakeNPCHostile((CHARACTERGUID)_Char,_Player);
		ObjectClearFlag(_Player,"TemporaryHostilityAfterDialog",_Id);
		NOT DB_TemporaryHostilityAfterDialog(_Player,_Id);
		
		//Set Attitude to -100 after dialog
		IF
		ObjectFlagSet("HostileAttitudeAfterDialog",(CHARACTERGUID)_Player,_Id)
		THEN
		DB_HostileAttitudeAfterDialog(_Player,_Id);
		
		IF
		DialogEnded(_,_Id)
		AND
		DB_HostileAttitudeAfterDialog(_Player,_Id)
		AND
		DB_DialogNPCs(_Id,_Char,_)
		THEN
		CharacterAddAttitudeTowardsPlayer((CHARACTERGUID)_Char,_Player,-100);
		ObjectClearFlag(_Player,"HostileAttitudeAfterDialog",_Id);
		NOT DB_HostileAttitudeAfterDialog(_Player,_Id);
		
		
		//Set Evil NPC after Dialog
		IF
		ObjectFlagSet("HostileAlignmentAfterDialog",(CHARACTERGUID)_Player,_Id)
		THEN
		DB_HostileAlignmentAfterDialog(_Player,_Id);
		
		IF
		DialogEnded(_,_Id)
		AND
		DB_HostileAlignmentAfterDialog(_Player,_Id)
		AND
		DialogGetInvolvedNPC(_Id,1,(CHARACTERGUID)_Char)
		THEN
		ProcSetRelationToPlayers(_Char,0);
		ObjectClearFlag(_Player,"HostileAlignmentAfterDialog",_Id);
		NOT DB_HostileAlignmentAfterDialog(_Player,_Id);
		
		
		//END_REGION
		
		//REGION Character Dies After Dialog Ends
		
		IF
		ObjectFlagSet("CharacterDieAfterDialog",(CHARACTERGUID)_Player,_Id)
		THEN
		DB_CharacterDieAfterDialog(_Player,_Id);
		
		IF
		DialogEnded(_,_Id)
		AND
		DB_CharacterDieAfterDialog(_Player,_Id)
		THEN
		CharacterDie(_Player,0,"DoT");
		ObjectClearFlag(_Player,"CharacterDieAfterDialog",_Id);
		NOT DB_CharacterDieAfterDialog(_Player,_Id);
		
		
		
		//END_REGION
		
		//REGION Res, Heal, and remove statuses from a player
		
		PROC
		Proc_CharacterFullRestore((CHARACTERGUID)_Char)
		THEN
		CharacterResurrect(_Char);
		RemoveHarmfulStatuses(_Char);
		CharacterSetHitpointsPercentage(_Char,100);
		CharacterSetArmorPercentage(_Char,100);
		CharacterSetMagicArmorPercentage(_Char,100);
		CharacterResetCooldowns(_Char);
		
		
		//END_REGION
		
		//REGION Camera Shake around Player
		
		PROC
		Proc_ShakeCameraForTime((CHARACTERGUID)_Char,(INTEGER)_Time)
		AND
		GetUUID(_Char,_UUID)
		AND
		StringConcatenate("CameraShake_",_UUID,_ID)
		THEN
		PROC_LoopEffect("RS3_FX_GP_ScriptedEvent_CameraShake_Loop_00-50",_Char,_ID,"__ANY__","");
		ProcObjectTimer(_Char,"Timer_LoopCameraShakeHelper",_Time);
		
		PROC
		ProcObjectTimerFinished(_Char,"Timer_LoopCameraShakeHelper")
		AND
		GetUUID(_Char,_UUID)
		AND
		StringConcatenate("CameraShake_",_UUID,_ID)
		THEN
		PROC_StopLoopEffect(_Char,_ID);
		
		PROC
		Proc_CameraShakeAroundCharacter((GUIDSTRING)_Object,(INTEGER)_Duration,(REAL)_Radius)
		AND
		DB_IsPlayer(_Player)
		AND
		GetDistanceTo(_Player,_Object,_Dist)
		AND
		_Dist <= _Radius
		THEN
		PlayEffect(_Player,"RS3_FX_GP_Combat_CameraShake_A");
		ProcObjectTimer(_Player,"ShakeCameraOn_",200);
		DB_CameraShakeAroundCharacter(_Object,_Duration,_Radius);
		
		
		PROC
		ProcObjectTimerFinished((CHARACTERGUID)_Player,"ShakeCameraOn_")
		AND
		DB_CameraShakeAroundCharacter(_Object,_Duration,_Radius)
		AND
		IntegerSubtract(_Duration,200,_Dif)
		AND
		_Dif >= 0
		THEN
		NOT DB_CameraShakeAroundCharacter(_Object,_Duration,_Radius);
		Proc_CameraShakeAroundCharacter(_Object,_Dif,_Radius);
		
		PROC
		ProcObjectTimerFinished((CHARACTERGUID)_Player,"ShakeCameraOn_")
		AND
		DB_CameraShakeAroundCharacter(_Object,_Duration,_Radius)
		AND
		IntegerSubtract(_Duration,200,_Dif)
		AND
		_Dif < 0.0
		THEN
		NOT DB_CameraShakeAroundCharacter(_Object,_Duration,_Radius);
		
		//END_REGION
		
		//REGION Add/Remove Source Points
		IF
		ObjectFlagSet("RemoveSourcePoints",(CHARACTERGUID)_Char,_)
		THEN
		ObjectClearFlag(_Char,"RemoveSourcePoints",0);
		Proc_RemoveSourcePoints(_Char);
		
		IF
		ObjectFlagSet("RemoveOneSourcePoint",(CHARACTERGUID)_Char,_)
		THEN
		ObjectClearFlag(_Char,"RemoveOneSourcePoint",0);
		CharacterAddSourcePoints(_Char, -1);
		
		
		IF
		ObjectFlagSet("AddSourcePoint",(CHARACTERGUID)_Char,_)
		THEN
		ObjectClearFlag(_Char,"AddSourcePoint",0);
		Proc_AddSourcePoint(_Char);
		
		IF
		ObjectFlagSet("AddTwoSourcePoints",(CHARACTERGUID)_Char,_)
		THEN
		ObjectClearFlag(_Char,"AddTwoSourcePoints",0);
		Proc_AddSourcePoint(_Char);
		Proc_AddSourcePoint(_Char);
		
		PROC
		Proc_AddSourcePoint((CHARACTERGUID)_Char)
		THEN
		CharacterAddSourcePoints(_Char,1);
		
		PROC
		Proc_RemoveSourcePoints((CHARACTERGUID)_Char)
		THEN
		CharacterAddSourcePoints(_Char,-100);
		
		//END_REGION
		
		QRY
		QRY_GLO_IsVisibleUndead((CHARACTERGUID)_Char)
		AND
		IsTagged(_Char, "UNDEAD", 1)
		AND
		IsTagged(_Char, "VEILED_UNDEAD", 0)
		AND
		IsTagged(_Char, "MASKED_UNDEAD", 0)
		THEN
		DB_NOOP(0);
		
		IF
		StoryEvent((CHARACTERGUID)_Char,"GEN_PurgeQueue")
		THEN
		CharacterPurgeQueue(_Char);
		ProcClearMovingFacts(_Char);
		
		//REGION Do Knockdown fall / getup Animation
		IF
		StoryEvent((CHARACTERGUID)_Char,"GEN_FallAndGetUp")
		THEN
		PlayAnimation(_Char,"knockdown_fall","Play_Anim_knockdown_getup");
		
		IF
		StoryEvent((CHARACTERGUID)_Char,"Play_Anim_knockdown_getup")
		THEN
		PlayAnimation(_Char,"knockdown_getup");
		
		//END_REGION
		
		//REGION Do Knockdown fall / knockdown loop Animation
		IF
		StoryEvent((CHARACTERGUID)_Char,"GEN_FallAndLie")
		THEN
		PlayAnimation(_Char,"knockdown_fall","Play_Anim_knockdown_loop");
		
		IF
		StoryEvent((CHARACTERGUID)_Char,"Play_Anim_knockdown_loop")
		THEN
		CharacterSetAnimationOverride(_Char,"knockdown_loop");
		
		//END_REGION
		
		//REGION Is Available to
		
		QRY
		QRY_IsAvailableTo((CHARACTERGUID)_Char,(CHARACTERGUID)_Target)
		AND
		QRY_SpeakerIsAvailable(_Char)
		AND
		QRY_SpeakerIsAvailable(_Target)
		AND
		CharacterCanSee(_Char,_Target,1)
		THEN
		DB_NOOP(1);
		
		//END_REGION
		
		//REGION Lookat in Dialog
		
		IF
		ObjectFlagSet("LookAtPlayer",(CHARACTERGUID)_Char,_ID)
		AND
		DialogGetInvolvedPlayer(_ID,1,(CHARACTERGUID)_Player)
		THEN
		CharacterLookAt(_Char,_Player);
		ObjectClearFlag(_Char,"LookAtPlayer",0);
		
		//END_REGION
		
		//REGION MoveTo in Dialog
		
		IF
		ObjectFlagSet("Speaker1MoveTo",(CHARACTERGUID)_Char,_ID)
		AND
		DialogGetInvolvedNPC(_ID,1,(CHARACTERGUID)_Speaker1)
		THEN
		CharacterMoveTo(_Speaker1,_Char,0,"",0);
		ObjectClearFlag(_Char,"Speaker1MoveTo",0);
		
		IF
		ObjectFlagSet("Speaker2MoveTo",(CHARACTERGUID)_Char,_ID)
		AND
		DialogGetInvolvedNPC(_ID,2,(CHARACTERGUID)_Speaker2)
		THEN
		CharacterMoveTo(_Speaker2,_Char,0,"",0);
		ObjectClearFlag(_Char,"Speaker2MoveTo",0);
		
		IF
		ObjectFlagSet("Player1MoveTo",(CHARACTERGUID)_Char,_ID)
		AND
		DialogGetInvolvedPlayer(_ID,1,(CHARACTERGUID)_Player)
		THEN
		CharacterMoveTo(_Player,_Char,0,"",0);
		ObjectClearFlag(_Char,"Player1MoveTo",0);
		
		IF
		ObjectFlagSet("Player2MoveTo",(CHARACTERGUID)_Char,_ID)
		AND
		DialogGetInvolvedPlayer(_ID,2,(CHARACTERGUID)_Player)
		THEN
		CharacterMoveTo(_Player,_Char,0,"",0);
		ObjectClearFlag(_Char,"Player2MoveTo",0);
		
		IF
		ObjectFlagSet("Speaker1RunTo",(CHARACTERGUID)_Char,_ID)
		AND
		DialogGetInvolvedNPC(_ID,1,(CHARACTERGUID)_Speaker1)
		THEN
		CharacterMoveTo(_Speaker1,_Char,1,"",0);
		ObjectClearFlag(_Char,"Speaker1MoveTo",0);
		
		IF
		ObjectFlagSet("Speaker2RunTo",(CHARACTERGUID)_Char,_ID)
		AND
		DialogGetInvolvedNPC(_ID,2,(CHARACTERGUID)_Speaker2)
		THEN
		CharacterMoveTo(_Speaker2,_Char,1,"",0);
		ObjectClearFlag(_Char,"Speaker2MoveTo",0);
		
		IF
		ObjectFlagSet("Player1RunTo",(CHARACTERGUID)_Char,_ID)
		AND
		DialogGetInvolvedPlayer(_ID,1,(CHARACTERGUID)_Player)
		THEN
		CharacterMoveTo(_Player,_Char,1,"",0);
		ObjectClearFlag(_Char,"Player1MoveTo",0);
		
		IF
		ObjectFlagSet("Player2RunTo",(CHARACTERGUID)_Char,_ID)
		AND
		DialogGetInvolvedPlayer(_ID,2,(CHARACTERGUID)_Player)
		THEN
		CharacterMoveTo(_Player,_Char,1,"",0);
		ObjectClearFlag(_Char,"Player2MoveTo",0);
		
		//END_REGION
		
		//REGION Animation testing
		IF
		TextEventSet("AnimTest")
		AND
		CharacterGetHostCharacter((CHARACTERGUID)_Player)
		AND
		GetTextEventParamInteger(1,0)
		THEN
		CharacterPurgeQueue(_Player);
		
		IF
		TextEventSet("AnimTest")
		AND
		CharacterGetHostCharacter((CHARACTERGUID)_Player)
		AND
		GetTextEventParamInteger(1,0)
		AND
		DB_AnimTestLoopingAnimation(_Player,_AnimName)
		THEN
		NOT DB_AnimTestLoopingAnimation(_Player,_AnimName);
		
		// oe animtest animation_name 
		IF
		TextEventSet("AnimTest")
		AND
		CharacterGetHostCharacter((CHARACTERGUID)_Player)
		AND
		GetTextEventParamString(1,_AnimName)
		AND
		NOT GetTextEventParamInteger(2,_)
		THEN
		PlayAnimation(_Player,_AnimName);
		
		IF
		TextEventSet("AnimTest")
		AND
		CharacterGetHostCharacter((CHARACTERGUID)_Player)
		AND
		GetTextEventParamString(1,_AnimName)
		AND
		GetTextEventParamInteger(2,1)
		THEN
		PlayAnimation(_Player,_AnimName);
		
		
		IF
		TextEventSet("AnimTest")
		AND
		CharacterGetHostCharacter((CHARACTERGUID)_Player)
		AND
		GetTextEventParamString(1,_AnimName)
		AND
		GetTextEventParamInteger(2,-1)
		THEN
		PlayAnimation(_Player,_AnimName,"AnimTest_PlayLoopingAnim");
		DB_AnimTestLoopingAnimation(_Player,_AnimName);
		
		IF
		StoryEvent((CHARACTERGUID)_Player,"AnimTest_PlayLoopingAnim")
		AND
		DB_AnimTestLoopingAnimation(_Player,_AnimName)
		THEN
		PlayAnimation(_Player,_AnimName,"AnimTest_PlayLoopingAnim");
		
		
		IF
		TextEventSet("AnimTest")
		AND
		CharacterGetHostCharacter((CHARACTERGUID)_Player)
		AND
		GetTextEventParamString(1,_AnimName)
		AND
		GetTextEventParamInteger(2,0)
		THEN
		CharacterPurgeQueue(_Player);
		
		
		
		IF
		TextEventSet("AnimTest")
		AND
		CharacterGetHostCharacter((CHARACTERGUID)_Player)
		AND
		GetTextEventParamString(1,_AnimName)
		AND
		GetTextEventParamInteger(2,0)
		AND
		DB_AnimTestLoopingAnimation(_Player,_AnimName)
		THEN
		NOT DB_AnimTestLoopingAnimation(_Player,_AnimName);
		
		
		//END_REGION
		
		//REGION FX testing
		
		// oe animtest animation_name 
		//REGION OneShot
		
		IF
		TextEventSet("FxTest")
		AND
		CharacterGetHostCharacter((CHARACTERGUID)_Player)
		AND
		GetTextEventParamString(1,_FxName)
		AND
		GetTextEventParamInteger(2,1)
		THEN
		PlayEffect(_Player,_FxName);
		//END_REGION
		
		//REGION Looping FX
		IF
		TextEventSet("FxTest")
		AND
		CharacterGetHostCharacter((CHARACTERGUID)_Player)
		AND
		GetTextEventParamString(1,_FxName)
		AND
		GetTextEventParamInteger(2,-1)
		THEN
		PROC_LoopEffect(_FxName,_Player,"FxTest","__ANY__","Dummy_FX");
		
		IF
		TextEventSet("FxTest")
		AND
		CharacterGetHostCharacter((CHARACTERGUID)_Player)
		AND
		GetTextEventParamString(1,_FxName)
		AND
		GetTextEventParamString(2,_BoneName)
		AND
		GetTextEventParamInteger(3,-1)
		THEN
		PROC_LoopEffect(_FxName,_Player,"FxTest","__ANY__",_BoneName);
		
		/////// 0 or STOP to stop looping
		
		IF
		TextEventSet("FxTest")
		AND
		CharacterGetHostCharacter((CHARACTERGUID)_Player)
		AND
		GetTextEventParamString(1,"Stop")
		THEN
		PROC_StopLoopEffect(_Player,"FxTest");
		
		IF
		TextEventSet("FxTestStop")
		AND
		CharacterGetHostCharacter((CHARACTERGUID)_Player)
		THEN
		PROC_StopLoopEffect(_Player,"FxTest");
		
		//END_REGION
		
		//END_REGION
		
		//REGION AddTag OE
		
		IF
		TextEventSet("AddTag")
		AND
		CharacterGetHostCharacter((CHARACTERGUID)_Player)
		AND
		GetTextEventParamString(1,_TagName)
		THEN
		SetTag(_Player,_TagName);
		DebugText(_Player,_TagName);
		
		//END_REGION
		
		//REGION DrawWeaponforXTime
		PROC
		proc_DrawWeaponforXTime((CHARACTERGUID)_NPC,(INTEGER)_Time)
		THEN
		CharacterSetFightMode(_NPC,1,0);
		ProcObjectTimer(_NPC,"GLO_DrawWeaponsForXTime",_Time);
		
		PROC
		ProcObjectTimerFinished(_NPC,"GLO_DrawWeaponsForXTime")
		AND
		CharacterIsInCombat((CHARACTERGUID)_NPC,0)
		THEN
		CharacterSetFightMode(_NPC,0,0);
		//END_REGION
		
		//REGION Conditional Object Flag Setter
		PROC
		Proc_SetConditionalObjectFlag((GUIDSTRING)_Object,(STRING)_Flag,(INTEGER)_Condition)
		AND
		_Condition == 0
		THEN
		ObjectClearFlag(_Object,_Flag,0);
		
		PROC
		Proc_SetConditionalObjectFlag((GUIDSTRING)_Object,(STRING)_Flag,(INTEGER)_Condition)
		AND
		_Condition != 0
		THEN
		ObjectSetFlag(_Object,_Flag,0);
		
		QRY
		QRY_IsEmptyDB((STRING)_DB,(INTEGER)_Size)
		AND
		SysCount(_DB,_Size,0)
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_IsInRange((GUIDSTRING)_Source,(GUIDSTRING)_Target,(REAL)_Range)
		AND
		GetDistanceTo(_Source,_Target,_Dist)
		AND
		_Dist <= _Range
		THEN
		DB_NOOP(1);
		
		QRY
		Query_CharacterIsAliveAndNotInCombat((CHARACTERGUID)_Char)
		AND
		CharacterIsDead(_Char,0)
		AND
		CharacterIsInCombat(_Char,0)
		THEN
		DB_NOOP(1);
		
		//END_REGION
		
		//REGION Attribute checks
		QRY
		QRY_CheckPlayerStat((CHARACTERGUID)_Player,(STRING)_Stat,(INTEGER)_Value)
		AND
		CharacterGetAttribute(_Player,_Stat,_PlayerStat)
		AND
		_PlayerStat >= _Value
		THEN
		DB_NOOP(1);
		
		IF
		DB_GLO_Attribute_Check_AgainstSpeaker((STRING)_Dialog,(INTEGER)_Index,(STRING)_Attribute,(STRING)_Difficulty,(INTEGER)_Source,(INTEGER)_Target)
		THEN
		PROC_Define_GLO_Attribute_Check_Internal(_Dialog,_Index,_Attribute,_Difficulty,_Source,_Target,0);
		
		IF
		DB_GLO_Attribute_Check_AgainstLevel((STRING)_Dialog,(INTEGER)_Index,(STRING)_Attribute,(STRING)_Difficulty,(INTEGER)_Source,(INTEGER)_Level)
		THEN
		PROC_Define_GLO_Attribute_Check_Internal(_Dialog,_Index,_Attribute,_Difficulty,_Source,1,_Level);
		
		PROC
		PROC_Define_GLO_Attribute_Check_Internal((STRING)_Dialog,(INTEGER)_Index,(STRING)_Attribute,(STRING)_Difficulty,(INTEGER)_Source,(INTEGER)_Target,(INTEGER)_Level)
		AND
		DB_GLO_Attribute_Check_Internal(_Dialog,_Index,_AnyAttribute,_AnyDifficulty,_AnySource,_AnyTarget,_AnyLevel)
		THEN
		NOT DB_GLO_Attribute_Check_Internal(_Dialog,_Index,_AnyAttribute,_AnyDifficulty,_AnySource,_AnyTarget,_AnyLevel);
		
		PROC
		PROC_Define_GLO_Attribute_Check_Internal((STRING)_Dialog,(INTEGER)_Index,(STRING)_Attribute,(STRING)_Difficulty,(INTEGER)_Source,(INTEGER)_Target,(INTEGER)_Level)
		THEN
		DB_GLO_Attribute_Check_Internal(_Dialog,_Index,_Attribute,_Difficulty,_Source,_Target,_Level);
		
		PROC
		Proc_DialogFlagSetup(_Dialog,_Speaker1)
		AND
		DB_GLO_Attribute_Check_Internal(_Dialog,_,_,_,_,_,_)
		THEN
		PROC_GLO_Attribute_Check_Setup(_Dialog);
		
		PROC
		Proc_DialogFlagSetup(_Dialog,_Speaker1,_Speaker2)
		AND
		DB_GLO_Attribute_Check_Internal(_Dialog,_,_,_,_,_,_)
		THEN
		PROC_GLO_Attribute_Check_Setup(_Dialog);
		
		PROC
		Proc_DialogFlagSetup(_Dialog,_Speaker1,_Speaker2,_Speaker3)
		AND
		DB_GLO_Attribute_Check_Internal(_Dialog,_,_,_,_,_,_)
		THEN
		PROC_GLO_Attribute_Check_Setup(_Dialog);
		
		PROC
		Proc_DialogFlagSetup(_Dialog,_Speaker1,_Speaker2,_Speaker3,_Speaker4)
		AND
		DB_GLO_Attribute_Check_Internal(_Dialog,_,_,_,_,_,_)
		THEN
		PROC_GLO_Attribute_Check_Setup(_Dialog);
		
		PROC
		Proc_DialogFlagSetup(_Dialog,_Speaker1,_Speaker2,_Speaker3,_Speaker4,_Speaker5)
		AND
		DB_GLO_Attribute_Check_Internal(_Dialog,_,_,_,_,_,_)
		THEN
		PROC_GLO_Attribute_Check_Setup(_Dialog);
		
		PROC
		Proc_DialogFlagSetup(_Dialog,_Speaker1,_Speaker2,_Speaker3,_Speaker4,_Speaker5,_Speaker6)
		AND
		DB_GLO_Attribute_Check_Internal(_Dialog,_,_,_,_,_,_)
		THEN
		PROC_GLO_Attribute_Check_Setup(_Dialog);
		
		PROC
		PROC_GLO_Attribute_Check_Setup((STRING)_Dialog)
		AND
		DB_GLO_Attribute_Check_Internal(_Dialog,_Index,_Attribute,_Difficulty,_Source,_Target,_Level)
		AND
		DB_GLO_AttributeCheck_Var(_Index,"Difficulty",_DifficultyVar)
		AND
		DB_GLO_AttributeCheck_Var(_Index,"LevelOverride",_LevelOverrideVar)
		AND
		DB_GLO_AttributeCheck_Var(_Index,"Name",_NameVar)
		AND
		DB_GLO_AttributeCheck_Var(_Index,"Source",_SourceVar)
		AND
		DB_GLO_AttributeCheck_Var(_Index,"Target",_TargetVar)
		THEN
		DialogSetVariableString(_Dialog,_DifficultyVar,_Difficulty);
		DialogSetVariableInt(_Dialog,_LevelOverrideVar,_Level);
		DialogSetVariableString(_Dialog,_NameVar,_Attribute);
		DialogSetVariableInt(_Dialog,_SourceVar,_Source);
		DialogSetVariableInt(_Dialog,_TargetVar,_Target);
		
		//END_REGION
		
		//REGION User Based Voice Bark
		
		IF
		DB_OneShotUser_VoicebarkTrigger((TRIGGERGUID)_Trigger,_)
		THEN
		ProcTriggerRegisterForPlayers(_Trigger);
		
		IF
		CharacterEnteredTrigger(_Player,_Trigger)
		AND
		DB_OneShotUser_VoicebarkTrigger((TRIGGERGUID)_Trigger,(STRING)_Bark)
		AND
		StringConcatenate("Commented_",_Bark,_Flag)
		AND
		UserGetFlag(_Player,_Flag,0)
		THEN
		UserSetFlag(_Player,_Flag);
		StartVoiceBark(_Bark,_Player);
		
		//END_REGION
		
		PROC
		Proc_TeleportSmoke((GUIDSTRING)_Object)
		AND
		GetPosition(_Object,_X,_Y,_Z)
		THEN
		PlayEffectAtPosition("RS3_FX_GP_ScriptedEvent_Teleport_GenericSmoke_01",_X,_Y,_Z);
		
		
		//REGION
		IF
		DB_HideEquippedWeapon((CHARACTERGUID)_Char)
		AND
		CharacterGetEquippedItem(_Char,"Weapon",(ITEMGUID)_Weapon)
		THEN
		CharacterUnequipItem(_Char,_Weapon);
		DB_HiddenEquippedWeapon(_Char,_Weapon);
		
		
		IF
		DB_HideEquippedShield((CHARACTERGUID)_Char)
		AND
		CharacterGetEquippedItem(_Char,"Shield",(ITEMGUID)_Shield)
		THEN
		CharacterUnequipItem(_Char,_Shield);
		DB_HideEquippedShield(_Char,_Shield);
		
		PROC
		Proc_EquipHiddenWeapon((CHARACTERGUID)_Char)
		AND
		DB_HiddenEquippedWeapon(_Char,_Weapon)
		THEN
		CharacterEquipItem(_Char,_Weapon);
		NOT DB_HiddenEquippedWeapon(_Char,_Weapon);
		//END_REGION
		
		//REGION Combat Cutscene - control whos turn it is
		
		IF
		DB_CombatCutscene_PrioritizedObject(_PrioritiedObject)
		THEN
		JumpToTurn(_PrioritiedObject);
		
		PROC
		Proc_CombatCutscene_PrioritizedObject_Purge()
		AND
		DB_CombatCutscene_PrioritizedObject(_PrioritiedObject)
		THEN
		NOT DB_CombatCutscene_PrioritizedObject(_PrioritiedObject);
		
		IF
		DB_CombatCutscene_PrioritizedObject(_PrioritiedObject)
		AND
		DB_CombatCutscene_PrioritizedObject(_OtherObject)
		AND
		_OtherObject != _PrioritiedObject
		THEN
		NOT DB_CombatCutscene_PrioritizedObject(_OtherObject);
		
		IF
		ObjectTurnStarted((CHARACTERGUID)_Combatant)
		AND
		DB_CombatCutscene_PrioritizedObject(_PrioritiedObject)
		AND
		ObjectIsCharacter(_PrioritiedObject,1)
		AND
		DB_CombatCharacters(_Combatant,_Id)
		AND
		_Combatant != _PrioritiedObject
		AND
		DB_CombatCharacters(_PrioritiedObject,_PId)
		AND
		_Id == _PId
		THEN
		JumpToTurn(_PrioritiedObject);
		
		IF
		CharacterWentOnStage(_PrioritiedObject,0) 
		AND
		ObjectIsCharacter(_PrioritiedObject,1)
		AND
		DB_CombatCutscene_PrioritizedObject(_PrioritiedObject)
		THEN
		NOT DB_CombatCutscene_PrioritizedObject(_PrioritiedObject);
		
		//END_REGION
		
		//REGION Remove Weapons
		
		PROC
		Proc_RemoveWeapons((CHARACTERGUID)_Char)
		AND
		CharacterGetEquippedItem(_Char,"Weapon",(ITEMGUID)_Weapon)
		THEN
		ItemRemove(_Weapon);
		
		PROC
		Proc_RemoveWeapons((CHARACTERGUID)_Char)
		AND
		CharacterGetEquippedItem(_Char,"Shield",(ITEMGUID)_Shield)
		THEN
		ItemRemove(_Shield);
		
		
		
		//END_REGION
		
		
		//REGION
		IF
		CharacterKilledBy(_Defender,_Attacker,_AttackerOwner)
		AND
		DB_IsPlayer(_AttackerOwner)
		AND
		DB_KilledEvent(_Defender, (STRING)_Event) 
		THEN
		UserSetFlag(_AttackerOwner,_Event,0);
		
		IF
		CharacterDying(_Killed)
		AND
		DB_KilledEvent(_Killed, _Event)
		AND
		DB_CombatCharacters(_Killed, _ID)
		AND
		DB_IsPlayer(_Killer)
		AND
		DB_CombatCharacters(_Killer, _ID)
		AND
		QRY_GLO_KilledEvent_WasEnemy((CHARACTERGUID)_Killed,(CHARACTERGUID)_Killer, _ID)
		THEN
		UserSetFlag(_Killer, _Event, 0);
		
		QRY
		QRY_GLO_KilledEvent_WasEnemy((CHARACTERGUID)_Killed, (CHARACTERGUID)_Killer, (INTEGER)_ID)
		AND
		DB_KilledEvent_HostileToTarget(_Killer, _Killed, _ID)
		THEN
		DB_NOOP(0);
		
		QRY
		QRY_GLO_KilledEvent_WasEnemy((CHARACTERGUID)_Killed, (CHARACTERGUID)_Killer, (INTEGER)_ID)
		AND
		CharacterIsEnemy(_Killed, _Killer, 1)
		THEN
		DB_NOOP(0);
		
		IF
		ObjectEnteredCombat((CHARACTERGUID)_NPC, _ID)
		AND
		DB_KilledEvent(_NPC, _)
		AND
		DB_IsPlayer(_Player)
		AND
		DB_CombatCharacters(_Player, _ID)
		AND
		CharacterIsEnemy(_Player, _NPC, 1)
		THEN
		DB_KilledEvent_HostileToTarget((CHARACTERGUID)_Player, (CHARACTERGUID)_NPC, _ID);
		
		IF
		ObjectEnteredCombat((CHARACTERGUID)_Player, _ID)
		AND
		DB_IsPlayer(_Player)
		AND
		DB_KilledEvent(_NPC, _)
		AND
		DB_CombatCharacters(_Player, _ID)
		AND
		CharacterIsEnemy(_Player,(CHARACTERGUID)_NPC,1)
		THEN
		DB_KilledEvent_HostileToTarget((CHARACTERGUID)_Player, (CHARACTERGUID)_NPC, _ID);
		
		IF
		CombatEnded(_ID)
		AND
		DB_KilledEvent_HostileToTarget(_Player, _NPC, _ID)
		THEN
		NOT DB_KilledEvent_HostileToTarget(_Player, _NPC, _ID);
		//END_REGION
		
		
		//REGION 
		//This will add characters within a trigger to the dialog
		//first int, if 1, will also add character when the enter the trigger after the dialog started
		
		IF
		DialogStarted(_Dialog,_Id)
		AND
		DB_AddCharactersInTriggerToDialog((STRING)_Dialog,(TRIGGERGUID)_Trigger,(INTEGER)_)
		THEN
		DB_AddCharactersInTriggerToDialog_ID(_Dialog,_Id);
		
		IF
		DialogStarted(_Dialog,_Id)
		AND
		DB_AddCharactersInTriggerToDialog(_Dialog,_Trigger,_)
		AND
		DB_InRegion(_Char,_Trigger)
		AND
		DB_IsPlayer(_Char)
		AND
		QRY_SpeakerIsAvailable(_Char)
		AND
		DB_AddCharactersInTriggerToDialog_ID(_Dialog,_Id)
		THEN
		DialogAddCharacter(_Id,_Char);
		
		IF
		CharacterEnteredTrigger(_Char,_Trigger)
		AND
		DB_AddCharactersInTriggerToDialog(_Dialog,_Trigger,1)
		AND
		DB_IsPlayer(_Char)
		AND
		DB_AddCharactersInTriggerToDialog_ID(_Dialog,_Id)
		THEN
		DialogAddCharacter(_Id,_Char);
		
		IF
		DialogEnded(_Dialog,_Id)
		AND
		DB_AddCharactersInTriggerToDialog_ID(_Dialog,_Id)
		THEN
		NOT DB_AddCharactersInTriggerToDialog_ID(_Dialog,_Id);
		//END_REGION
		
		//REGION Replace one-time use dialog flag into a proc call (for flags used to trigger actions)
		PROC
		Proc_OneTimeEventFlag((STRING)_Flag)
		THEN
		DB_NOOP(1);
		
		PROC
		Proc_OneTimeEventFlag((GUIDSTRING)_Object,(STRING)_Flag)
		THEN
		DB_NOOP(1);
		
		PROC
		Proc_OneTimeEventFlag((GUIDSTRING)_Object,(STRING)_Flag,(INTEGER)_DialogInst)
		THEN
		DB_NOOP(1);
		
		IF
		ObjectFlagSet(_Flag,_Object,_DlgInst)
		AND
		DB_OneTimeEventFlag(_Flag)
		THEN
		ObjectClearFlag(_Object,_Flag);
		Proc_OneTimeEventFlag(_Object,_Flag);
		Proc_OneTimeEventFlag(_Object,_Flag,_DlgInst);
		
		IF
		GlobalFlagSet(_Flag)
		AND
		DB_OneTimeEventFlag(_Flag)
		THEN
		GlobalClearFlag(_Flag);
		Proc_OneTimeEventFlag(_Flag);
		//END_REGION
		
		//REGION Generic Leave Through Portal (_Poof Variation)
		
		PROC
		Proc_CreatePortalAndLeave((CHARACTERGUID)_Char,(STRING)_Event)
		AND
		GetPosition(_Char,_X,_Y,_Z)
		AND
		RealSum(_Y,1.25,_Y2)
		AND
		RealSum(_X,2.0,_X2)
		AND
		CreateItemTemplateAtPosition("Helper_Invisible_A_835c266c-2619-41a6-9591-50fc937bf97d",_X2,_Y2,_Z,(ITEMGUID)_Portal)
		THEN
		DB_GEN_CreatePortalAndLeave(_Char,_Portal,_Event);
		CharacterLookAt(_Char,_Portal);
		PlayAnimation(_Char,"cast_target_cast","GEN_CreatePortalAndLeave_CreatePortal");
		PROC_LoopEffect("RS3_FX_Skills_Voodoo_Cast_Hand_01",_Char,"GEN_CreatePortalAndLeave_Fx","__ANY__","Dummy_R_HandFX");
		PROC_LoopEffect("RS3_FX_GP_ScriptedEvent_DarkOrb_Summoning_01",_Char,"GEN_CreatePortalAndLeave_Fx","__ANY__","");
		ProcObjectTimer(_Char,"GEN_CreatePortalAndLeave_CreatePortal_Timer",1800);
		
		PROC
		ProcObjectTimerFinished((CHARACTERGUID)_Char,"GEN_CreatePortalAndLeave_CreatePortal_Timer")
		AND
		GetRotation(_Char,_,_Yr,_)
		AND
		DB_GEN_CreatePortalAndLeave(_Char,(ITEMGUID)_Portal,_Event)
		THEN
		ItemRotateToAngleY(_Portal,_Yr,1000.0);
		PROC_LoopEffect("RS3_FX_GP_ScriptedEvent_Portal_01",_Portal,"GEN_CreatePortalAndLeave","__ANY__","");
		
		
		IF
		StoryEvent((CHARACTERGUID)_Char,"GEN_CreatePortalAndLeave_CreatePortal")
		AND
		DB_GEN_CreatePortalAndLeave(_Char,_Portal,_Event)
		THEN
		PROC_StopLoopEffect(_Char,"GEN_CreatePortalAndLeave_Fx");
		ProcObjectTimer(_Char,"GEN_CreatePortalAndLeave_MoveToDelay",800);
		
		PROC
		ProcObjectTimerFinished((CHARACTERGUID)_Char,"GEN_CreatePortalAndLeave_MoveToDelay")
		AND
		DB_GEN_CreatePortalAndLeave(_Char,(ITEMGUID)_Portal,_Event)
		THEN
		CharacterMoveTo(_Char,_Portal,0,"GEN_CreatePortalAndLeave_Offstage",0);
		
		IF
		StoryEvent((CHARACTERGUID)_Char,"GEN_CreatePortalAndLeave_Offstage")
		AND
		DB_GEN_CreatePortalAndLeave(_Char,(ITEMGUID)_Portal,_Event)
		THEN
		ProcObjectTimer(_Portal,"GEN_CreatePortalAndLeave_Offstage_PortalRemove",3500);
		PROC_StopLoopEffect(_Portal,"GEN_CreatePortalAndLeave");
		SetStoryEvent(_Char,_Event);
		NOT DB_GEN_CreatePortalAndLeave(_Char,_Portal,_Event);
		
		PROC
		ProcObjectTimerFinished((ITEMGUID)_Portal,"GEN_CreatePortalAndLeave_Offstage_PortalRemove")
		THEN
		ItemRemove(_Portal);
		
		
		IF
		TextEventSet("GEN_CreatePortalAndLeave_Offstage")
		AND
		CharacterGetHostCharacter((CHARACTERGUID)_Player)
		THEN
		Proc_CreatePortalAndLeave(_Player,"");
		
		//END_REGION
		 
		//REGION StartDialog With Visible Tagged Player 
		
		PROC
		PROC_StartDialog_WithVisibleTag((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player,(STRING)_Dialog,(STRING)_MainTag,(STRING)_FallBackTag,(INTEGER)_AddOtherPlayersToDialog)
		AND
		NOT DB_PROC_StartDialogWithVisibleTag(1)
		AND
		IsTagged(_Player,_MainTag,1)
		AND
		QRY_SpeakerIsAvailableAndInDialogRange(_NPC,_Player)
		THEN
		Proc_StartDialog(0,_Dialog,_NPC,_Player);
		DB_PROC_StartDialogWithVisibleTag(1);
		
		PROC
		PROC_StartDialog_WithVisibleTag((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player,(STRING)_Dialog,(STRING)_MainTag,(STRING)_FallBackTag,(INTEGER)_AddOtherPlayersToDialog)
		AND
		NOT DB_PROC_StartDialogWithVisibleTag(1)
		AND
		IsTagged(_Player,_MainTag,0)
		AND
		DB_IsPlayer(_OtherPlayers)
		AND
		IsTagged(_OtherPlayers,_MainTag,1)
		AND
		QRY_SpeakerIsAvailableAndInDialogRange(_NPC,_OtherPlayers)
		THEN
		Proc_StartDialog(0,_Dialog,_NPC,_OtherPlayers);
		DB_PROC_StartDialogWithVisibleTag(1);
		
		PROC
		PROC_StartDialog_WithVisibleTag((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player,(STRING)_Dialog,(STRING)_MainTag,(STRING)_FallBackTag,(INTEGER)_AddOtherPlayersToDialog)
		AND
		NOT DB_PROC_StartDialogWithVisibleTag(1)
		AND
		IsTagged(_Player,_FallBackTag,1)
		AND
		QRY_SpeakerIsAvailableAndInDialogRange(_NPC,_Player)
		THEN
		Proc_StartDialog(0,_Dialog,_NPC,_Player);
		DB_PROC_StartDialogWithVisibleTag(1);
		
		PROC
		PROC_StartDialog_WithVisibleTag((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player,(STRING)_Dialog,(STRING)_MainTag,(STRING)_FallBackTag,(INTEGER)_AddOtherPlayersToDialog)
		AND
		NOT DB_PROC_StartDialogWithVisibleTag(1)
		AND
		IsTagged(_Player,_FallBackTag,0)
		AND
		DB_IsPlayer(_OtherPlayers)
		AND
		IsTagged(_OtherPlayers,_FallBackTag,1)
		AND
		QRY_SpeakerIsAvailableAndInDialogRange(_NPC,_OtherPlayers)
		THEN
		Proc_StartDialog(0,_Dialog,_NPC,_OtherPlayers);
		DB_PROC_StartDialogWithVisibleTag(1);
		
		PROC
		PROC_StartDialog_WithVisibleTag((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player,(STRING)_Dialog,(STRING)_MainTag,(STRING)_FallBackTag,(INTEGER)_AddOtherPlayersToDialog)
		AND
		NOT DB_PROC_StartDialogWithVisibleTag(1)
		AND
		QRY_SpeakerIsAvailableAndInDialogRange(_NPC,_Player)
		THEN
		Proc_StartDialog(0,_Dialog,_NPC,_Player);
		DB_PROC_StartDialogWithVisibleTag(1);
		
		PROC
		PROC_StartDialog_WithVisibleTag((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player,(STRING)_Dialog,(STRING)_MainTag,(STRING)_FallBackTag,1)
		AND
		DB_PROC_StartDialogWithVisibleTag(1)
		THEN
		DB_PROC_StartDialog_WithVisibleTag_AddPlayers(_NPC,_Player,_Dialog);
		
		PROC
		PROC_StartDialog_WithVisibleTag((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player,(STRING)_Dialog,(STRING)_MainTag,(STRING)_FallBackTag,(INTEGER)_AddOtherPlayersToDialog)
		AND
		DB_PROC_StartDialogWithVisibleTag(1)
		THEN
		NOT DB_PROC_StartDialogWithVisibleTag(1);
		
		IF
		DialogStarted(_Dialog,_ID)
		AND
		DB_PROC_StartDialog_WithVisibleTag_AddPlayers(_NPC,_Player,_Dialog)
		AND
		DB_IsPlayer(_Players)
		AND
		NOT DB_DialogPlayers(_ID,_Players,_)
		AND
		CharacterCanSee(_NPC,_Players,1)
		AND
		QRY_SpeakerIsAvailable(_Players)
		THEN
		DialogAddCharacter(_ID,_Players);
		
		
		IF
		DialogStarted(_Dialog,_ID)
		AND
		DB_PROC_StartDialog_WithVisibleTag_AddPlayers(_NPC,_Player,_Dialog)
		THEN
		NOT DB_PROC_StartDialog_WithVisibleTag_AddPlayers(_NPC,_Player,_Dialog);
		
		//END_REGION
		
		//REGION Repair / Loremaster traders
		
		IF
		DB_LoremasterTrader((CHARACTERGUID)_Trader,(INTEGER)_Level)
		THEN
		CharacterAddAbility(_Trader,"Loremaster",_Level);
		
		IF
		DB_RepairTrader((CHARACTERGUID)_Trader,(INTEGER)_Level)
		THEN
		CharacterAddAbility(_Trader,"Repair",_Level);
		
		//END_REGION
		
		//REGION Safe teleport for characters: teleport and flush/stop existing commands
		PROC
		PROC_Helper_SafeTeleportTo((CHARACTERGUID)_Char,(GUIDSTRING)_Dest)
		THEN
		PROC_Helper_SafeTeleportTo(_Char,_Dest,"",1);
		
		PROC
		PROC_Helper_SafeTeleportTo((CHARACTERGUID)_Char,(GUIDSTRING)_Dest,(STRING)_Event,(INTEGER)_TeleportLinkedCharacters)
		THEN
		TeleportTo(_Char,_Dest,_Event,_TeleportLinkedCharacters);
		CharacterFlushQueue(_Char);
		LeaveCombat(_Char);
		SetStoryEvent(_Char,"ClearPeaceReturn");
		// Clear ongoing animations
		PlayAnimation(_Char,"");
		
		//END_REGION
		
		//REGION Teleport In/Out script helpers
		
		IF
		StoryEvent((CHARACTERGUID)_Char,"GEN_Teleport_In")
		THEN
		SetOnStage(_Char,1);
		PlayAnimation(_Char,"Teleport_In_01");
		
		
		IF
		StoryEvent((CHARACTERGUID)_Char,"GEN_Teleport_Out")
		THEN
		PlayAnimation(_Char,"Teleport_Out_01","GEN_GoOffStage");
		
		
		//END_REGION
		
		
		
		//REGION Sign function
		QRY
		QRY_IntegerSign((INTEGER)_Value)
		AND
		DB_IntegerSign(_Result)
		THEN
		NOT DB_IntegerSign(_Result);
		
		QRY
		QRY_IntegerSign((INTEGER)_Value)
		AND
		_Value < 0
		THEN
		DB_IntegerSign(-1);
		
		QRY
		QRY_IntegerSign((INTEGER)_Value)
		AND
		_Value == 0
		THEN
		DB_IntegerSign(0);
		
		QRY
		QRY_IntegerSign((INTEGER)_Value)
		AND
		_Value > 0
		THEN
		DB_IntegerSign(0);
		//END_REGION
		
	}
	EXIT
	{
		
	}
}
Goal(34).Title("_InitGoal");
Goal(34)
{
	INIT
	{
		
	}
	KB
	{
		PROC
		InitStory()
		THEN
		DB_StoryStarted(1);
		GoalCompleted;
		
	}
	EXIT
	{
		
	}
}
Goal(35).Title("_NPC_Stats");
Goal(35)
{
	INIT
	{
		
	}
	KB
	{
		
	}
	EXIT
	{
		
	}
}
Goal(36).Title("_PlayerAlignments");
Goal(36)
{
	INIT
	{
		
	}
	KB
	{
		PROC
		ProcFixPlayerAlignments()
		AND
		DB_IsPlayer(_Player)
		AND
		NOT DB_PlayerAlignments_BlockFix(_Player)
		AND
		IsInArena(_Player,0)
		AND
		CharacterIsPlayer(_Player,1)
		AND
		DB_IsPlayer(_OtherPlayer)
		AND
		NOT DB_PlayerAlignments_BlockFix(_OtherPlayer)
		AND
		_Player!=_OtherPlayer
		AND
		IsInArena(_OtherPlayer,0)
		AND
		CharacterIsPlayer(_OtherPlayer,1)
		AND
		CharacterGetReservedUserID(_Player,_User)
		AND
		CharacterGetReservedUserID(_OtherPlayer,_OtherUser)
		AND
		GetUserProfileID(_User,_UserProfileID)
		AND
		GetUserProfileID(_OtherUser,_OtherUserProfileID)
		THEN
		ProcSetPlayerAlignment(_Player,_OtherPlayer,_UserProfileID,_OtherUserProfileID);
		
		PROC
		ProcFixPlayerAlignments()
		AND
		DB_IsPlayer((CHARACTERGUID)_Player)
		AND
		NOT DB_PlayerAlignments_BlockFix(_Player)
		AND
		IsInArena(_Player,0)
		AND
		DB_IsPlayer((CHARACTERGUID)_OtherPlayer)
		AND
		NOT DB_PlayerAlignments_BlockFix(_OtherPlayer)
		AND
		_Player != _OtherPlayer
		AND
		IsInArena(_OtherPlayer,0)
		AND
		CharacterGetRelationToCharacter(_Player,_OtherPlayer,_Relation)
		THEN
		ProcLeavePartyIfRelationLow(_Player,_OtherPlayer,_Relation);
		
		PROC
		ProcSetPlayerAlignment((CHARACTERGUID)_Player,(CHARACTERGUID)_OtherPlayer,(STRING)_User,(STRING)_OtherUser)
		AND
		DB_UserAlign(_User,_OtherUser,_Result)
		THEN
		CharacterSetRelationIndivFactionToIndivFaction(_Player,_OtherPlayer,_Result);
		
		PROC
		ProcSetPlayerAlignment((CHARACTERGUID)_Player,(CHARACTERGUID)_OtherPlayer,(STRING)_User,(STRING)_OtherUser)
		AND
		NOT DB_UserAlign(_User,_OtherUser,_)
		AND
		CharacterIsInPartyWith(_Player,_OtherPlayer,1)	
		THEN
		CharacterSetRelationIndivFactionToIndivFaction(_Player,_OtherPlayer,100);
		
		PROC
		ProcSetPlayerAlignment((CHARACTERGUID)_Player,(CHARACTERGUID)_OtherPlayer,(STRING)_User,(STRING)_OtherUser)
		AND
		NOT DB_UserAlign(_User,_OtherUser,_)
		AND
		CharacterIsInPartyWith(_Player,_OtherPlayer,0)	
		THEN
		CharacterSetRelationIndivFactionToIndivFaction(_Player,_OtherPlayer,50);
		
		PROC
		ProcLeavePartyIfRelationLow((CHARACTERGUID)_Player,(CHARACTERGUID)_OtherPlayer,(INTEGER)_Relation)
		AND
		_Relation < 25
		AND
		CharacterIsInPartyWith(_Player,_OtherPlayer,1)
		AND
		CharacterGetReservedUserID(_Player,_UserID)
		AND
		CharacterGetReservedUserID(_OtherPlayer,_OtherUserID)
		AND
		_UserID != _OtherUserID
		THEN
		LeaveParty(_OtherUserID);
		
		/***************************************************************************************
			Fix alignments when swapping characters between users or creating new players.
		****************************************************************************************/
		
		IF
		CharacterReservedUserIDChanged(_,_)
		THEN
		ProcFixPlayerAlignments();
		
		IF 
		DB_IsPlayer(_)
		THEN
		ProcFixPlayerAlignments();
		
		IF 
		GlobalFlagSet("SetupUserAlignments")
		THEN
		ProcFixPlayerAlignments();
		GlobalClearFlag("SetupUserAlignments");
		
		IF
		CharacterJoinedParty(_)
		THEN
		ProcFixPlayerAlignments();
		
		/***************************************************************************************
			DB_UserAlign logic
		****************************************************************************************/
		
		IF
		GameStarted(_,_)
		THEN
		GlobalSetFlag("SetupUserAlignments");
		
		IF 
		UserDisconnected(_User,_,_UserProfileID)
		AND
		DB_UserAlign(_UserProfileID,_OtherUser,_Result)
		THEN
		NOT DB_UserAlign(_UserProfileID,_OtherUser,_Result);
		
		IF 
		UserDisconnected(_User,_,_UserProfileID)
		AND
		DB_UserAlign(_OtherUser,_UserProfileID,_Result)
		THEN
		NOT DB_UserAlign(_OtherUser,_UserProfileID,_Result);
		
		IF 
		UserMakeWar(_Source,_Target,1)
		AND
		GetUserProfileID(_Source,_SourceProfileID)
		AND
		GetUserProfileID(_Target,_TargetProfileID)
		THEN
		ProcSetUserAlign(_SourceProfileID,_TargetProfileID,0);
		ProcSetUserAlign(_TargetProfileID,_SourceProfileID,0);
		ProcFixPlayerAlignments();
		
		IF 
		UserMakeWar(_Source,_Target,0)
		AND
		GetUserProfileID(_Source,_SourceProfileID)
		AND
		GetUserProfileID(_Target,_TargetProfileID)
		THEN
		NOT DB_UserAlign(_SourceProfileID,_TargetProfileID,0);
		NOT DB_UserAlign(_TargetProfileID,_SourceProfileID,0);
		ProcFixPlayerAlignments();
		
		PROC
		ProcSetUserAlign((STRING)_SourceProfileID,(STRING)_TargetProfileID,(INTEGER)_NewResult)
		AND
		DB_UserAlign(_SourceProfileID,_TargetProfileID,_Result)
		THEN
		NOT DB_UserAlign(_SourceProfileID,_TargetProfileID,_Result);
		
		PROC
		ProcSetUserAlign((STRING)_SourceProfileID,(STRING)_TargetProfileID,(INTEGER)_NewResult)
		THEN
		DB_UserAlign(_SourceProfileID,_TargetProfileID,_NewResult);
		
		/***************************************************************************************
			DB_UserAlign Debugging
		****************************************************************************************/
		
		IF 
		TextEventSet("useralign")
		AND 
		DB_UserAlign(_User,_OtherUser,_Result)
		AND
		DB_IsPlayer(_Player)
		AND
		StringConcatenate(_User," vs ",_Res)
		AND
		StringConcatenate(_Res,_OtherUser,_Res2)
		AND
		StringConcatenate(_Res2,":  ",_Res3)
		AND
		IntegertoString(_Result,_IntStr)
		AND
		StringConcatenate(_Res3,_IntStr,_FinalResult)
		THEN
		DebugText(_Player,_FinalResult);
		
	}
	EXIT
	{
		
	}
}
Goal(37).Title("_PROC_AUDIO");
Goal(37)
{
	INIT
	{
		//MoveToTrigger Audio Events 
		DB_MoveToTrigger_Materials("STONE");
		DB_MoveToTrigger_Materials("WOOD");
		DB_MoveToTrigger_Materials("METAL");
		
		DB_CameraShakeAudioEventTrigger(800,5001);
		
		DB_DebugCameraShakerParser("500",500);
		DB_DebugCameraShakerParser("1000",1000);
		DB_DebugCameraShakerParser("3000",3000);
		DB_DebugCameraShakerParser("5000",5000);
		DB_DebugCameraShakerParser("8000",8000);
		DB_DebugCameraShakerParser("13000",13000);
		
		
		DB_DebugCameraShakerParser("2",2);
		DB_DebugCameraShakerParser("5",5);
		DB_DebugCameraShakerParser("1",1);
		DB_DebugCameraShakerParser("25",25);
		DB_DebugCameraShakerParser("60",60);
		
	}
	KB
	{
		//REGION MoveToTrigger //Audio Play Sounds according to Material
		
		PROC
		proc_ItemMoveToTrigger((ITEMGUID)_Item,(TRIGGERGUID)_Trigger,(REAL)_Speed,(REAL)_Acceleration,(INTEGER)_UseRotation)
		THEN
		ItemMoveToTrigger(_Item,_Trigger,_Speed,_Acceleration,_UseRotation);
		
		PROC
		Proc_ItemMoveToPosition((ITEMGUID)_Item,(REAL)_X,(REAL)_Y,(REAL)_Z,(REAL)_Speed,(REAL)_Acceleration)
		THEN
		ItemMoveToPosition(_Item,_X,_Y,_Z,_Speed,_Acceleration);
		
		PROC
		Proc_ItemMoveToPosition((ITEMGUID)_Item,(REAL)_PlusX,(REAL)_PlusY,(REAL)_PlusZ,(REAL)_Speed,(REAL)_Acceleration)
		AND
		NOT DB_MovingItem(_Item,_)
		AND
		DB_MoveToTrigger_Materials(_Tag)
		AND
		IsTagged(_Item,_Tag,1)
		AND
		StringConcatenate("Items_Puzzles_MovingObjects_",_Tag,_SoundEventPre)
		AND
		StringConcatenate(_SoundEventPre,"_Start",_SoundEvent)
		THEN
		DB_MovingItem(_Item,_Tag);
		PlaySound(_Item,_SoundEvent);
		DebugText(_Item,"PlayEvent_Move_Start");
		
		
		PROC
		proc_ItemMoveToTrigger((ITEMGUID)_Item,(TRIGGERGUID)_Trigger,(REAL)_Speed,(REAL)_Acceleration,(INTEGER)_UseRotation)
		AND
		NOT DB_MovingItem(_Item,_)
		AND
		DB_MoveToTrigger_Materials(_Tag)
		AND
		IsTagged(_Item,_Tag,1)
		AND
		StringConcatenate("Items_Puzzles_MovingObjects_",_Tag,_SoundEventPre)
		AND
		StringConcatenate(_SoundEventPre,"_Start",_SoundEvent)
		THEN
		DB_MovingItem(_Item,_Tag);
		PlaySound(_Item,_SoundEvent);
		DebugText(_Item,"PlayEvent_Move_Start");
		
		
		IF
		StoryEvent(_Item,"GEN_ItemMoved")
		AND
		NOT DB_MovingItem((ITEMGUID)_Item,_)
		AND
		DB_MoveToTrigger_Materials(_Tag)
		AND
		IsTagged(_Item,_Tag,1)
		AND
		StringConcatenate("Items_Puzzles_MovingObjects_",_Tag,_SoundEventPre)
		AND
		StringConcatenate(_SoundEventPre,"_Start",_SoundEvent)
		THEN
		DB_MovingItem(_Item,_Tag);
		PlaySound(_Item,_SoundEvent);
		DebugText(_Item,"PlayEvent_Move_Start");
		
		
		IF
		ItemMoved(_Item)
		AND
		DB_MovingItem(_Item,_Tag)
		AND
		StringConcatenate("Items_Puzzles_MovingObjects_",_Tag,_SoundEventPre)
		AND
		StringConcatenate(_SoundEventPre,"_Stop",_SoundEvent)
		THEN
		NOT DB_MovingItem(_Item,_Tag);
		PlaySound(_Item,_SoundEvent);
		DebugText(_Item,"PlayEvent_Move_END");
		//END_REGION
		
		//REGION ScreenShake Audio Logic
		
		PROC
		ProcObjectTimer(_Char,"Timer_LoopCameraShakeHelper",_Time)
		AND
		DB_CameraShakeAudioEventTrigger(_MinDuration,_)
		AND
		_Time > _MinDuration
		THEN
		PlaySound(_Char,"SE_GP_ScriptedEvent_CameraShake_Earth");
		
		PROC
		ProcObjectTimer(_Char,"Timer_LoopCameraShakeHelper",_Time)
		AND
		DB_CameraShakeAudioEventTrigger(_MinDuration,_MaxDurationToCallStop)
		AND
		_Time > _MinDuration
		AND
		_Time < _MaxDurationToCallStop
		THEN
		DB_Timer_LoopCameraShakeHelper_StopSound(_Char);
		
		PROC
		ProcObjectTimerFinished(_Char,"Timer_LoopCameraShakeHelper")
		AND
		DB_Timer_LoopCameraShakeHelper_StopSound(_Char)
		THEN
		NOT DB_Timer_LoopCameraShakeHelper_StopSound(_Char);
		PlaySound(_Char,"SE_GP_ScriptedEvent_CameraShake_Earth_Stop");
		
		
		IF
		TextEventSet("TestCameraShakeAudio")
		AND
		GetTextEventParamString(1,_TimeString)
		AND
		DB_DebugCameraShakerParser(_TimeString,_TimerInt)
		AND
		DB_IsPlayer(_Player)
		THEN
		Proc_ShakeCameraForTime((CHARACTERGUID)_Player,_TimerInt);
		
		
		IF
		TextEventSet("TestCameraShake_AroundChar_Audio")
		AND
		GetTextEventParamString(1,_TimeString)
		AND
		DB_DebugCameraShakerParser(_TimeString,_TimerInt)
		AND
		DB_IsPlayer(_Player)
		THEN
		Proc_CameraShakeAroundCharacter(_Player,_TimerInt,6.0);
		//END_REGION
		
	}
	EXIT
	{
		
	}
}
Goal(38).Title("_Sandbox");
Goal(38)
{
	INIT
	{
		DB_Dialogs(CHARACTERGUID_Sandbox_Ship_Captain_dc36935c-4452-47af-8bab-f34c48754e13, CHARACTERGUID_Sandbox_Ship_Elisabeth_Fendrish_a7b94f10-865f-4ffd-8770-fce3973366ff, "Sandbox_Quest");
		
		DB_QuestDef_State("SandboxQuest","Accept", 1);
		DB_QuestDef_State("SandboxQuest","GoBack");
		DB_QuestDef_State("SandboxQuest","Finish", -1);
		
		ProcTriggerRegisterForPlayers(TRIGGERGUID_CaveQuestTrigger_fb308de8-145b-4749-8b92-db51ea2bc019);
		
		DB_QuestDef_QuestReward("SandboxQuest","Finish","QuestUpdate_SandboxQuest_Finish");
		
	}
	KB
	{
		IF
		CharacterEnteredTrigger(_Player, TRIGGERGUID_CaveQuestTrigger_fb308de8-145b-4749-8b92-db51ea2bc019)
		THEN
		ObjectSetFlag(_Player, "QuestUpdate_SandboxQuest_GoBack");
		
	}
	EXIT
	{
		
	}
}
Goal(39).Title("_Shroud");
Goal(39)
{
	INIT
	{
		
	}
	KB
	{
		PROC
		ProcDisableShroud()
		AND
		NOT DB_ShroudDisabled(1)
		THEN
		DB_ShroudDisabled(1);
		ShroudRender(0);
		
		PROC
		ProcEnableShroud()
		AND
		DB_ShroudDisabled(1)
		THEN
		NOT DB_ShroudDisabled(1);
		ShroudRender(1);
		
	}
	EXIT
	{
		
	}
}
Goal(40).Title("_Story Npcs");
Goal(40)
{
	INIT
	{
		
	}
	KB
	{
		PROC
		SetStoryNpc((CHARACTERGUID)_Npc,(INTEGER)_State)
		THEN
		CharacterMakeStoryNpc(_Npc,_State);	
		
		PROC	
		SetStoryNpc((CHARACTERGUID)_Npc,0)
		THEN	
		NOT DB_IsStoryNpc(_Npc);
		
		PROC	
		SetStoryNpc((CHARACTERGUID)_Npc,1)
		THEN	
		DB_IsStoryNpc(_Npc);
		
		PROC	
		MakeAttackable((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc)
		THEN
		SetStoryNpc(_Npc,0);
		CharacterSetTemporaryHostileRelation(_Npc,_Player);
		CharacterAddAttitudeTowardsPlayer(_Npc,_Player,-100);
			
		// Default arg:
		PROC	
		SetStoryNpc((CHARACTERGUID)_Npc)
		THEN	
		SetStoryNpc(_Npc,1);
		
		PROC	
		SetStoryNpcStatus((CHARACTERGUID)_Npc) 
		AND
		DB_IsStoryNpc(_Npc)
		THEN
		CharacterMakeStoryNpc(_Npc,1);
		
		PROC
		SetStoryNpcStatus((CHARACTERGUID)_Npc) 
		AND 
		NOT DB_IsStoryNpc(_Npc)
		THEN
		CharacterMakeStoryNpc(_Npc,0);
		
	}
	EXIT
	{
		
	}
}
Goal(41).Title("_Trade");
Goal(41)
{
	INIT
	{
		DB_DoubleAttitudePrice(1, 2);
		DB_DoubleAttitudePrice(2, 2);
		DB_DoubleAttitudePrice(3, 3);
		DB_DoubleAttitudePrice(4, 3);
		DB_DoubleAttitudePrice(5, 4);
		DB_DoubleAttitudePrice(6, 5);
		DB_DoubleAttitudePrice(7, 6);
		DB_DoubleAttitudePrice(8, 7);
		DB_DoubleAttitudePrice(9, 12);
		DB_DoubleAttitudePrice(10, 15);
		DB_DoubleAttitudePrice(11, 20);
		DB_DoubleAttitudePrice(12, 25);
		DB_DoubleAttitudePrice(13, 30);
		DB_DoubleAttitudePrice(14, 35);
		DB_DoubleAttitudePrice(15, 40);
		DB_DoubleAttitudePrice(16, 60);
		DB_DoubleAttitudePrice(17, 65);
		DB_DoubleAttitudePrice(18, 75);
		DB_DoubleAttitudePrice(19, 85);
		DB_DoubleAttitudePrice(20, 95);
		DB_DoubleAttitudePriceOverTwenty(100);
		
	}
	KB
	{
		//REGION Creating and resetting TraderTreasure
		PROC
		GenTradeItems((CHARACTERGUID)_Player,(CHARACTERGUID)_Trader)
		AND
		NOT DB_TraderGeneratedTreasureForLevel(_Trader,_)
		THEN
		DB_TraderGeneratedTreasureForLevel(_Trader,0);
		
		PROC
		GenTradeItems((CHARACTERGUID)_Player,(CHARACTERGUID)_Trader)
		AND
		DB_TraderGeneratedTreasureForLevel(_Trader,_OldLevel)
		AND
		CharacterGetLevel(_Player,_NewLevel)
		AND
		_NewLevel > _OldLevel
		THEN
		NOT DB_TraderGeneratedTreasureForLevel(_Trader,_OldLevel);
		DB_TraderGeneratedTreasureForLevel(_Trader,_NewLevel);
		DoGenTradeItems(_Player,_Trader);
		
		PROC
		ProcClearTradeFacts((CHARACTERGUID)_Trader)
		AND
		DB_TraderGeneratedTreasureForLevel(_Trader,_OldLevel)
		THEN
		NOT DB_TraderGeneratedTreasureForLevel(_Trader,_OldLevel);
		
		PROC	
		GenTradeItems((CHARACTERGUID)_Player,(CHARACTERGUID)_Trader) 
		AND
		DB_LastTradeItemGeneration(_Trader,(INTEGER)_THLastGen) 
		AND 
		_THLastGen != 0 
		AND		// check if last generation was long enough ago:
		DB_Time(_,_,_TH) 
		AND
		IntegerSubtract(_TH,_THLastGen,_Delta) 
		AND
		_Delta >= 12
		THEN	
		DoGenTradeItems(_Player,_Trader);
		
		// If not yet an inventory generated for this npc, do it:
		PROC	
		GenTradeItems((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc) 
		AND
		DB_LastTradeItemGeneration(_Npc,0)		// not yet generated
		THEN	
		DoGenTradeItems(_Player,_Npc);
		
		//
		PROC	
		DoGenTradeItems((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc) 
		AND 
		DB_LastTradeItemGeneration(_Npc,_THLastGen)
		THEN	
		NOT DB_LastTradeItemGeneration(_Npc,_THLastGen);
		
		//
		PROC	
		DoGenTradeItems((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc) 
		AND 
		DB_Time(_,_,_TH)
		THEN	
		ProcGenerateTradeTreasure(_Player,_Npc);
		DB_LastTradeItemGeneration(_Npc,_TH);
		
		PROC
		ProcClearGeneratedItems((CHARACTERGUID)_Npc)
		AND
		NOT DB_ItemsCleared(_Npc)
		THEN
		DB_ItemsCleared(_Npc);
		CharacterClearTradeGeneratedItems(_Npc);
		
		IF
		DB_CustomTradeTreasure(_Npc,_Treasure)
		THEN
		ProcClearLastTradeTime(_Npc);
		
		PROC
		ProcClearLastTradeTime((CHARACTERGUID)_Trader)
		AND
		DB_LastTradeItemGeneration(_Trader,(INTEGER)_THLastGen) 
		THEN
		NOT DB_LastTradeItemGeneration(_Trader,_THLastGen);
		DB_LastTradeItemGeneration(_Trader,0);
		
		PROC
		ProcGenerateTradeTreasure((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc) 
		AND
		DB_CustomTradeTreasure((CHARACTERGUID)_Npc,(STRING)_Treasure)
		THEN
		ProcClearGeneratedItems(_Npc);
		DB_CharacterGenerateCustomTradeTreasure(_Player,_Npc,_Treasure);
		DB_TreasureGenerated(1);
		
		PROC
		ProcGenerateTradeTreasure((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc) 
		AND
		NOT DB_TreasureGenerated(1)
		THEN
		GenerateItems(_Player,_Npc);
		
		PROC
		ProcGenerateTradeTreasure((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc) 
		THEN
		NOT DB_TreasureGenerated(1);
		NOT DB_ItemsCleared(_Npc);
		//END_REGION
		
		//REGION Start Trade
		//
		// StartTrade: set all facts and startup the trade window:
		//
		PROC	
		StartTrade((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc)
		THEN	
		GenTradeItems(_Player,_Npc);					// regenerate items (clear if _Npc.DB_IsHostile())
		ResetInsults(_Player,_Npc);
		
		PROC	
		StartTrade((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc) 
		THEN	
		DoStartTrade_1(_Player,_Npc);
		
		PROC	
		DoStartTrade_1((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc) 
		AND
		DB_NoRepair(_Npc) 
		AND
		DB_NoIdentify(_Npc)
		THEN	
		ActivateTrade(_Player,_Npc,0,0,1);
		
		PROC	
		DoStartTrade_1((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc) 
		AND
		NOT DB_NoRepair(_Npc) 
		AND
		DB_NoIdentify(_Npc)
		THEN	
		ActivateTrade(_Player,_Npc,1,0,1);
		
		PROC	
		DoStartTrade_1((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc) 
		AND
		DB_NoRepair(_Npc) 
		AND
		NOT DB_NoIdentify(_Npc)
		THEN	
		ActivateTrade(_Player,_Npc,0,1,1);
		
		PROC	
		DoStartTrade_1((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc) 
		AND
		NOT DB_NoRepair(_Npc) 
		AND
		NOT DB_NoIdentify(_Npc)
		THEN	
		ActivateTrade(_Player,_Npc,1,1,1);
		
		IF		
		RequestTrade(_Player,_Npc)
		THEN
		StartTrade(_Player,_Npc);
		
		PROC 
		ResetInsults((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc)
		AND
		DB_InsultCounter(_Player, _Npc, _Counter)
		THEN
		NOT DB_InsultCounter(_Player, _Npc, _Counter);
		DB_InsultCounter(_Player, _Npc, 0);
		
		PROC 
		ResetInsults((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc)
		AND
		NOT DB_InsultCounter(_Player, _Npc, _)
		THEN
		DB_InsultCounter(_Player, _Npc, 0);
		
		//END_REGION
		
		//REGION Finish trade and adjust attitude if necessary
		IF		
		HappyWithDeal(_Player,_Npc,_ValuePlayer,_ValueNpc)
		AND
		QRY_GetAttitudeChangeForTrade(_Player,_Npc,_ValuePlayer,_ValueNpc)
		AND
		DB_AttitudeAdjustMent(_Player,_Npc,_Att)
		AND
		_Att != 0
		THEN
		CharacterAddAttitudeTowardsPlayer(_Npc,_Player,_Att);
		
		IF		
		HappyWithDeal(_Player,_Npc,_ValuePlayer,_ValueNpc) 
		AND
		_ValuePlayer >= _ValueNpc
		AND
		DB_AttitudeAdjustMent(_Player,_Npc,_Att)
		THEN	
		ExecuteDeal(_Player,1,_Att);
		
		IF		
		HappyWithDeal(_Player,_Npc,_ValuePlayer,_ValueNpc) 
		AND
		_ValuePlayer < _ValueNpc
		AND
		DB_AttitudeAdjustMent(_Player,_Npc,_Att)
		AND
		DB_InsultCounter(_Player,_Npc,_Counter)
		AND
		IntegerSum(_Counter,1,_NewCounter)
		THEN	
		ExecuteDeal(_Player,0,_Att);
		NOT DB_InsultCounter(_Player,_Npc,_Counter);
		DB_InsultCounter(_Player,_Npc,_NewCounter);
		
		QRY
		QRY_GetAttitudeChangeForTrade((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc,(INTEGER)_ValuePlayer,(INTEGER)_ValueNpc)
		AND
		NOT DB_TempTradeBalance(_Player,_Npc,_)
		THEN
		DB_TempTradeBalance(_Player,_Npc,0);
		
		QRY
		QRY_GetAttitudeChangeForTrade((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc,(INTEGER)_ValuePlayer,(INTEGER)_ValueNpc)
		AND
		DB_AttitudeAdjustMent(_Player,_Npc,_Att)
		THEN
		NOT DB_AttitudeAdjustMent(_Player,_Npc,_Att);
		
		QRY
		QRY_GetAttitudeChangeForTrade((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc,(INTEGER)_ValuePlayer,(INTEGER)_ValueNpc)
		AND
		IntegerSubtract(_ValuePlayer,_ValueNPC,_Delta)
		AND
		DB_TempTradeBalance(_Player,_Npc,_OldBalance)
		AND
		IntegerSum(_Delta,_OldBalance,_NewBalance)
		AND
		CharacterGetLevel(_Npc,_NpcLevel)
		AND
		_NpcLevel <= 20
		AND
		DB_DoubleAttitudePrice(_NpcLevel,_DoublePrice)// Working with doubles to allow us to work with halves in integer envirnoment
		AND
		IntegerSum(_NewBalance,_NewBalance,_DoubleBalance)
		AND
		IntegerDivide(_DoubleBalance,_DoublePrice,_Q) // 1 Attitude point costs (L+1)/2
		AND
		IntegerProduct(_Q,_DoublePrice,_DoubleSubtracted)
		AND
		IntegerSum(_DoubleSubtracted,1,_DoubleSubtractedIncremented)
		AND
		IntegerDivide(_DoubleSubtractedIncremented,2,_TotalSubtracted)
		AND
		IntegerSubtract(_NewBalance,_TotalSubtracted,_Remainder)
		THEN
		NOT DB_TempTradeBalance(_Player,_Npc,_OldBalance);
		DB_TempTradeBalance(_Player,_Npc,_Remainder);
		DB_AttitudeAdjustMent(_Player,_Npc,_Q);
		
		QRY
		QRY_GetAttitudeChangeForTrade((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc,(INTEGER)_ValuePlayer,(INTEGER)_ValueNpc)
		AND
		IntegerSubtract(_ValuePlayer,_ValueNPC,_Delta)
		AND
		DB_TempTradeBalance(_Player,_Npc,_OldBalance)
		AND
		IntegerSum(_Delta,_OldBalance,_NewBalance)
		AND
		CharacterGetLevel(_Npc,_NpcLevel)
		AND
		_NpcLevel > 20
		AND
		DB_DoubleAttitudePriceOverTwenty(_DoublePrice)// Working with doubles to allow us to work with halves in integer envirnoment
		AND
		IntegerSum(_NewBalance,_NewBalance,_DoubleBalance)
		AND
		IntegerDivide(_DoubleBalance,_DoublePrice,_Q) // 1 Attitude point costs (L+1)/2
		AND
		IntegerProduct(_Q,_DoublePrice,_DoubleSubtracted)
		AND
		IntegerSum(_DoubleSubtracted,1,_DoubleSubtractedIncremented)
		AND
		IntegerDivide(_DoubleSubtractedIncremented,2,_TotalSubtracted)
		AND
		IntegerSubtract(_NewBalance,_TotalSubtracted,_Remainder)
		THEN
		NOT DB_TempTradeBalance(_Player,_Npc,_OldBalance);
		DB_TempTradeBalance(_Player,_Npc,_Remainder);
		DB_AttitudeAdjustMent(_Player,_Npc,_Q);
		
		
		IF
		DB_AttitudeAdjustMent(_Player,_Npc,_Q)
		AND
		_Q < 0
		AND
		DB_InsultCounter(_Player, _Npc, _InsultCount)
		AND
		_InsultCount < 2 // Player can insult trader with the offer 2 times before Attitude reduction kicks in
		AND
		IntegerSum(_InsultCount, 1, _NewInsultCount)
		THEN
		NOT DB_AttitudeAdjustMent(_Player,_Npc,_Q);
		DB_AttitudeAdjustMent(_Player,_Npc,0);
		
		IF
		DB_AttitudeAdjustMent(_Player,_Npc,_Q)
		AND
		_Q < 0
		AND
		DB_InsultCounter(_Player, _Npc, _InsultCount)
		AND
		_InsultCount >= 2
		AND
		_Q != -15
		AND
		CharacterGetAttitudeTowardsPlayer(_Npc,_Player,_OldAtt)
		AND
		IntegerSum(_OldAtt,_Q,_NewAtt)
		AND
		_NewAtt != -45
		THEN
		NOT DB_AttitudeAdjustMent(_Player,_Npc,_Q);
		DB_AttitudeAdjustMent(_Player,_Npc,-15);
		
		QRY
		QRY_GetAttitudeChangeForTrade((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc,(INTEGER)_ValuePlayer,(INTEGER)_ValueNpc)
		AND
		CharacterGetAttitudeTowardsPlayer(_Npc,_Player,_OldAtt)
		AND
		DB_AttitudeAdjustMent(_Player,_Npc,_OldDelta)
		AND
		IntegerSum(_OldAtt,_OldDelta,_NewAtt)
		AND
		_NewAtt < -45
		AND
		IntegerSubtract(-45,_OldAtt,_NewDelta)
		THEN
		NOT DB_AttitudeAdjustMent(_Player,_Npc,_OldDelta);
		DB_AttitudeAdjustMent(_Player,_Npc,_NewDelta);
		//END_REGION
		
		//Start Trade via Event (instead of button click in dialog)
		IF
		ObjectFlagSet("StartTrade",(CHARACTERGUID)_Player,_Instance)
		AND
		DB_DialogNPCs(_Instance,_Npc,1)
		THEN
		StartTrade((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc);
		ObjectClearFlag(_Player,"StartTrade",_Instance);
		
		//REGION Manual Trade Toggling Per Player
		
		PROC
		Proc_DialogFlagSetup(_,(GUIDSTRING)_NPC,(GUIDSTRING)_Player)
		AND
		DB_ManualTradeNPC(_NPC)
		AND
		DB_PreventTradeBetween(_NPC,_Player)
		THEN
		CharacterSetCanTrade((CHARACTERGUID)_NPC,0);
		
		PROC
		Proc_DialogFlagSetup(_,(GUIDSTRING)_NPC,(GUIDSTRING)_Player)
		AND
		IsTagged(_NPC,"GHOST",1)
		THEN
		CharacterSetCanTrade((CHARACTERGUID)_NPC,0);
		
		IF
		ObjectFlagSet("PreventTradeWithPlayer",(GUIDSTRING)_NPC,_ID)
		AND
		DialogGetInvolvedPlayer(_ID,1,(CHARACTERGUID)_Player)
		THEN
		DB_ManualTradeNPC(_NPC);
		DB_PreventTradeBetween(_NPC,_Player);
		ObjectClearFlag(_NPC,"PreventTradeWithPlayer",_ID);
		
		PROC
		Proc_DialogFlagSetup(_,(GUIDSTRING)_NPC,(GUIDSTRING)_Player)
		AND
		DB_ManualTradeNPC(_NPC)
		AND
		NOT DB_PreventTradeBetween(_NPC,_Player)
		THEN
		CharacterSetCanTrade((CHARACTERGUID)_NPC,1);
		//END_REGION
		
	}
	EXIT
	{
		
	}
}
Goal(42).Title("_TrapReactions");
Goal(42)
{
	INIT
	{
		DB_Event2DisplayText("HiddenPerceptionReveal","GEN_AD_HiddenPerceptionReveal");
		DB_Event2DisplayText("HiddenTrapReveal","GEN_AD_HiddenTrapReveal");
		DB_Event2DisplayText("FakePerceptionReveal","GEN_AD_FakePerceptionReveal");
		DB_Event2DisplayText("AmbushReveal","GLO_AD_AmbushDetected");
		
	}
	KB
	{
		IF
		StoryEvent((CHARACTERGUID)_Player,_Event)
		AND
		NOT DB_BlockTextSpam(_Player)
		AND
		_Player.DB_IsPlayer()
		AND
		DB_CustomEvent2DisplayText((CHARACTERGUID)_Player,(STRING)_Event,(STRING)_Text)
		AND
		QRY_SpeakerIsAvailable(_Player)
		THEN
		Proc_StartDialog(1,_Text, _Player);
		DB_BlockTextSpam(_Player);
		ProcObjectTimer(_Player,"BlockTextSpam",5000);
		
		IF
		StoryEvent((CHARACTERGUID)_Player,_Event)
		AND
		NOT DB_BlockTextSpam(_Player)
		AND
		_Player.DB_IsPlayer()
		AND
		DB_Event2DisplayText(_Event,_Text)
		AND
		QRY_SpeakerIsAvailable(_Player)
		THEN
		Proc_StartDialog(1,_Text, _Player);
		DB_BlockTextSpam(_Player);
		ProcObjectTimer(_Player,"BlockTextSpam",5000);
		
		PROC
		ProcObjectTimerFinished(_Player,"BlockTextSpam")
		THEN
		NOT DB_BlockTextSpam((CHARACTERGUID)_Player);
		
		
		
	}
	EXIT
	{
		
	}
}
Goal(43).Title("_Waypoints");
Goal(43)
{
	INIT
	{
		
	}
	KB
	{
		IF
		DB_WaypointInfo(_Item,_Trigger,_CurrentWP)
		THEN
		RegisterWaypoint(_CurrentWP,_Item);
		
		IF
		CharacterItemEvent(_Player,(ITEMGUID)_Item,"WaypointDiscovered")
		AND
		DB_WaypointInfo(_Item,_,_)
		THEN
		ProcDoWaypointUnlock(_Item, _Player);
		
		IF
		CharacterItemEvent(_, (ITEMGUID)_Item,"WaypointDiscovered")
		THEN
		ShowNotification("GLO_WaypointDiscovered");
		
		IF
		CharacterUsedItem(_Player,_Item)
		AND
		DB_WaypointInfo(_Item,_Trigger,_CurrentWP)
		AND
		NOT DB_BlockWaypointUsage(_Player)
		THEN
		ProcDoWaypointUnlock(_Item,_Player);
		
		//Check for UI blocker
		IF
		CharacterUsedItem(_Player,_Item)
		AND
		DB_WaypointInfo(_Item,_Trigger,_CurrentWP)
		AND
		NOT DB_BlockWaypointUsage(_Player)
		AND
		NOT DB_WaypointBlockUI(_Item)
		AND
		NOT DB_Dialogs(_Item,_)
		AND
		NOT DB_IsSign(_Item,(STRING)_,(STRING)_)
		THEN
		OpenWaypointUI(_Player,_CurrentWP,_Item);
		
		IF
		TextEventSet("wp")
		THEN
		PROC_UnlockAllWP();
		ProcTestOpenWaypointUI();
		
		PROC
		ProcTestOpenWaypointUI()
		AND
		_Player.DB_IsPlayer()
		AND
		NOT DB_OnlyOnce("openedWPUI")
		THEN
		DB_OnlyOnce("openedWPUI");
		OpenWaypointUI(_Player,"",NULL_00000000-0000-0000-0000-000000000000);
		
		
		PROC
		ProcTestOpenWaypointUI()
		THEN
		NOT DB_OnlyOnce("openedWPUI");
		
		PROC
		PROC_UnlockAllWP()
		AND
		DB_WaypointInfo(_,_Trigger,_CurrentWP)
		THEN
		UnlockWaypoint(_CurrentWP,_Trigger,NULL_00000000-0000-0000-0000-000000000000);
		
		PROC
		ProcDoWaypointUnlock((ITEMGUID)_Item,(CHARACTERGUID)_Player)
		AND
		DB_WaypointInfo(_Item,_Trigger,_CurrentWP)
		THEN
		UnlockWaypoint(_CurrentWP,_Trigger,_Player);
		
		PROC
		ProcDoWaypointUnlock(_,_)
		AND
		DB_IsPlayer(_OtherPlayer)
		AND
		NOT DB_NumUnlockedWaypoints(_OtherPlayer,_)
		THEN
		DB_NumUnlockedWaypoints(_OtherPlayer,0);
		
		PROC
		ProcDoWaypointUnlock((ITEMGUID)_Item,(CHARACTERGUID)_Player)
		AND
		DB_IsPlayer(_OtherPlayer)
		AND
		NOT DB_UnlockedWaypoint(_Item,_OtherPlayer)
		AND
		CharacterIsInPartyWith(_OtherPlayer,_Player,1)
		AND
		DB_NumUnlockedWaypoints(_OtherPlayer,_OldCount)
		AND
		IntegerSum(_OldCount,1,_NewCount)
		THEN
		DB_UnlockedWaypoint(_Item,_OtherPlayer);
		NOT DB_NumUnlockedWaypoints(_OtherPlayer,_OldCount);
		DB_NumUnlockedWaypoints(_OtherPlayer,_NewCount);
		
		
		IF
		ObjectFlagSet("OpenWaypointUI",_Player,_ID)
		AND
		DB_DialogNPCs(_ID,_Item,1)
		AND
		DB_WaypointInfo((ITEMGUID)_Item,_Trigger,_CurrentWP)
		THEN
		OpenWaypointUI((CHARACTERGUID)_Player,_CurrentWP,_Item);
		ObjectClearFlag(_Player,"OpenWaypointUI",_ID);
		PROC_CheckPlayTut(_Player,"TUT_Waypoint");
		
	}
	EXIT
	{
		
	}
}
Goal(44).Title("EMDG_Goblin");
Goal(44)
{
	INIT
	{
		//DB_EMDG_GoblinTrader(_DialogVar, _GoldAmount, _TransferFlag)
		DB_EMDG_GoblinTrader("EMDG_CheckPlayerGold_Small_f304a8f4-27cc-4175-8e80-2c8c94a1da71", 55, "EMDG_TransferGold_Small");
		DB_EMDG_GoblinTrader("EMDG_CheckPlayerGold_Medium_e747e1d9-c47d-4c84-bcf9-55bc111192dc", 201, "EMDG_TransferGold_Medium");
		DB_EMDG_GoblinTrader("EMDG_CheckPlayerGold_Large_35619ab7-7010-4b49-ab20-1011f31b413d", 577, "EMDG_TransferGold_Large");
		
		EMDG_SetDialogVariables();
		
	}
	KB
	{
		//REGION INIT
		//Set the dialog variable amounts to the values in our database.
		PROC
		EMDG_SetDialogVariables()
		AND
		DB_EMDG_GoblinTrader(_DialogVar, _GoldAmount, _TransferFlag)
		THEN
		DialogSetVariableInt("EMDG_GoblinTrader", _DialogVar, _GoldAmount);
		//END_REGION
		
		//REGION HELPERS
		//Re-usable call for displaying a color-formatted status text for a gold amount.
		PROC
		EMDG_WriteGoldMessage((CHARACTERGUID)_Character, (INTEGER)_GoldAmount, (STRING)_Message, (STRING)_Color)
		AND
		IntegertoString(_GoldAmount, _GoldStr)
		AND
		StringConcatenate(_GoldStr, _Message, _CombinedMessage)
		AND
		StringConcatenate("<font color='#", _Color, _HTMLPrefix1)
		AND
		StringConcatenate(_HTMLPrefix1, "'>", _HTMLPrefix2)
		AND
		StringConcatenate(_HTMLPrefix2, _CombinedMessage, _FormattedMessage)
		AND
		StringConcatenate(_FormattedMessage, "</font>", _StatusText)
		THEN
		CharacterStatusText(_Character, _StatusText);
		
		QRY
		EMDG_QRY_ClearObjectFlag((CHARACTERGUID)_Character, (STRING)_Flag)
		THEN
		ObjectClearFlag(_Character, _Flag);
		//END_REGION
		
		//REGION FLAG_EVENTS
		IF
		ObjectFlagSet(_TransferFlag, (CHARACTERGUID)_Player, _Instance)
		AND
		DB_EMDG_GoblinTrader(_DialogVar, _GoldAmount, _TransferFlag)
		AND
		EMDG_QRY_ClearObjectFlag(_Player, _TransferFlag)
		AND
		DialogGetInvolvedNPC(_Instance, 1, (CHARACTERGUID)_Goblin)
		AND
		IntegerProduct(_GoldAmount, -1, _RemoveAmount)
		THEN
		CharacterAddGold(_Goblin, _GoldAmount);
		CharacterAddGold(_Player, _RemoveAmount);
		EMDG_WriteGoldMessage(_Goblin, _GoldAmount, " gold added.", "FFD700");
		EMDG_WriteGoldMessage(_Player, _RemoveAmount, " gold removed.", "FF0000");
		
		IF
		ObjectFlagSet("EMDG_RollGoldAmount", (CHARACTERGUID)_Goblin, _Instance)
		AND
		EMDG_QRY_ClearObjectFlag(_Goblin, "EMDG_RollGoldAmount")
		AND
		Random(5, _RanResult)
		AND
		IntegerSum(_RanResult, 1, _Multiplier)
		AND
		IntegerProduct(25, _Multiplier, _RandomGoldAmount)
		THEN
		DialogSetVariableIntForInstance(_Instance, "EMDG_RandomGoblinGold_c5b27d49-cc84-47f1-9ba0-fdd10523943b", _RandomGoldAmount);
		DB_EMDG_GoblinRandomGoldAmount(_Instance, _RandomGoldAmount);
		
		IF
		ObjectFlagSet("EMDG_GivePlayerGold", (CHARACTERGUID)_Goblin, _Instance)
		AND
		EMDG_QRY_ClearObjectFlag(_Goblin, "EMDG_GivePlayerGold")
		AND
		DialogGetInvolvedPlayer(_Instance, 1, (CHARACTERGUID)_Player)
		AND
		DB_EMDG_GoblinRandomGoldAmount(_Instance, _RandomGoldAmount)
		THEN
		CharacterAddGold(_Player, _RandomGoldAmount);
		EMDG_WriteGoldMessage(_Player, _RandomGoldAmount, " gold added.", "FFD700");
		NOT DB_EMDG_GoblinRandomGoldAmount(_Instance, _RandomGoldAmount);
		//END_REGION
		
		//REGION DEBUG
		IF
		CharacterUsedItem(_Player, ITEMGUID_EMDG_Test_Lever_BigGold_ceafbcc2-45c7-410e-b1c7-3aa8f348afd7)
		AND
		DB_CurrentLevel("EMDG_TestLevel")
		THEN
		CharacterAddGold(_Player, 1000);
		EMDG_WriteGoldMessage(_Player, 1000, " gold added.", "FFD700");
		
		IF
		CharacterUsedItem(_Player, ITEMGUID_EMDG_Test_Lever_MinGold_2861d9c1-bd15-4052-8404-3fc8460810b0)
		AND
		DB_CurrentLevel("EMDG_TestLevel")
		THEN
		CharacterAddGold(_Player, 55);
		EMDG_WriteGoldMessage(_Player, 55, " gold added.", "FFD700");
		//END_REGION
		
	}
	EXIT
	{
		
	}
}
Goal(45).Title("ExampleMod_DialogGold");
Goal(45)
{
	INIT
	{
		
	}
	KB
	{
		IF
		GameStarted(_,_)
		THEN
		GoalCompleted;
		
	}
	EXIT
	{
		
	}
}
Goal(46).Title("GLO_BidirShovelTunnel");
Goal(46)
{
	INIT
	{
		// Support for a bidirectional tunnel that can be opened up from either side by shovelling
		// Usage:
		//  DB_BidirShovelPileTunnel(IDString,Side1ShovelTrigger,Side1ShovelPileObject,Side1TunnelEntranceObject,Side2ShovelTrigger,Side2ShovelPileObject,Side2TunnelEntranceObject);
		//
		// As soon as one side is opened up, so is the other side. Can't easily use simply two shovel
		// piles with the same ID, because then the dirt pile on the other side won't be removed. Also
		// avoids conflicts in case people shovel on both sides at the same time.
		//
		// When the tunnel is opened on side 1/2, ProcBidirShovelTunnelOpenedOnSide(1/2) is called
		// (only one of these will be called per tunnel)
		
	}
	KB
	{
		//REGION Convert tunnel into two shovel areas
		IF
		DB_BidirShovelPileTunnel((STRING)_IDString,(TRIGGERGUID)_Side1ShovelTrigger,(ITEMGUID)_Side1ShovelPileObject,(ITEMGUID)_Side1TunnelEntranceObject,(TRIGGERGUID)_Side2ShovelTrigger,(ITEMGUID)_Side2ShovelPileObject,(ITEMGUID)_Side2TunnelEntranceObject)
		AND
		StringConcatenate(_IDString,"___side1",_Side1IDString)
		AND
		StringConcatenate(_IDString,"___side2",_Side2IDString)
		THEN
		DB_BidirShovelTunnelExit(_IDString,_Side1IDString);
		DB_BidirShovelTunnelExit(_IDString,_Side2IDString);
		DB_ShovelArea((TRIGGERGUID)_Side1ShovelTrigger,(STRING)_Side1IDString,(ITEMGUID)_Side1ShovelPileObject);
		DB_ShovelArea((TRIGGERGUID)_Side2ShovelTrigger,(STRING)_Side2IDString,(ITEMGUID)_Side2ShovelPileObject);
		DB_ShovelRewardItemSpawn((STRING)_Side1IDString,(ITEMGUID)_Side1TunnelEntranceObject);
		DB_ShovelRewardItemSpawn((STRING)_Side2IDString,(ITEMGUID)_Side2TunnelEntranceObject);
		//END_REGION
		
		//REGION User hooks
		PROC
		ProcBidirShovelTunnelOpenedOnSide((CHARACTERGUID)_,(STRING)_,(INTEGER)_)
		THEN
		DB_NOOP(1);
		
		PROC
		ProcShovelRewards(_Player,_ThisSideIDString)
		AND
		DB_BidirShovelTunnelExit(_IDString,_ThisSideIDString)
		AND
		StringContains(_ThisSideIDString,"__side1",1)
		THEN
		ProcBidirShovelTunnelOpenedOnSide(_Player,_IDString,1);
		
		PROC
		ProcShovelRewards(_Player,_ThisSideIDString)
		AND
		DB_BidirShovelTunnelExit(_IDString,_ThisSideIDString)
		AND
		StringContains(_ThisSideIDString,"__side2",1)
		THEN
		ProcBidirShovelTunnelOpenedOnSide(_Player,_IDString,2);
		//END_REGION
		
		//REGION If one side is opened up, open the other one too
		PROC
		PROC_ShovelTunnelOpenUpOtherSide((CHARACTERGUID)_Player, (STRING)_IDString)
		AND
		DB_BidirShovelTunnelExit(_IDString,_OtherSideIDString)
		AND
		DB_ShovelArea(_OtherTrigger,_OtherSideIDString,_OtherPileObject)
		AND
		// avoid issues if someone is digging up the other side at the same time
		NOT DB_Shovelling_Mound(_,_OtherPileObject)
		THEN
		NOT DB_BidirShovelTunnelExit(_IDString,_OtherSideIDString);
		SetOnStage(_OtherPileObject,0);
		NOT DB_ShovelArea(_OtherTrigger,_OtherSideIDString,_OtherPileObject);
		// Won't trigger code below again, because all DB_BidirShovelTunnelExit() for this _IDString have been cleared
		ProcShovelRewards(_Player,_OtherSideIDString);
		
		PROC
		ProcShovelRewards(_Player,_ThisSideIDString)
		AND
		DB_BidirShovelTunnelExit(_IDString,_ThisSideIDString)
		AND
		DB_BidirShovelPileTunnel(_IDString,_Side1ShovelTrigger,_Side1ShovelPileObject,_Side1TunnelEntranceObject,_Side2ShovelTrigger,_Side2ShovelPileObject,_Side2TunnelEntranceObject)
		THEN
		NOT DB_BidirShovelTunnelExit(_IDString,_ThisSideIDString);
		// Only DB_BidirShovelTunnelExit(_IDString,_) definition left now is for the other side
		PROC_ShovelTunnelOpenUpOtherSide(_Player,_IDString);
		NOT DB_BidirShovelPileTunnel(_IDString,_Side1ShovelTrigger,_Side1ShovelPileObject,_Side1TunnelEntranceObject,_Side2ShovelTrigger,_Side2ShovelPileObject,_Side2TunnelEntranceObject);
		
		//END_REGION
		
	}
	EXIT
	{
		
	}
}
Goal(47).Title("GLO_Resting");
Goal(47)
{
	INIT
	{
		DB_RestTemplates("FUR_Humans_Camping_Sleepingbag_B_4d7216c9-c21e-4ab0-b98e-97d744798912","STORY_PartyRest",10.0,17.0);
		
	}
	KB
	{
		IF
		CharacterUsedItemTemplate(_Character,_Temp,_)
		AND
		DB_RestTemplates(_Temp,_Consume,_PartyRadius,_SafeRadius)
		THEN
		UserRest(_Character,_Consume,_PartyRadius,_SafeRadius);
		
	}
	EXIT
	{
		
	}
}
Goal(48).Title("GLO_SavegamePatchHelpers");
Goal(48)
{
	INIT
	{
		
	}
	KB
	{
		QRY
		QRY_VersionIsOlderThan((INTEGER)_Major,(INTEGER)_Minor,(INTEGER)_Rev,(INTEGER)_Build,(INTEGER)_CompMajor,(INTEGER)_CompMinor,(INTEGER)_CompRev,(INTEGER)_CompBuild)
		AND
		_Major < _CompMajor
		THEN
		DB_Noop(1);
		
		QRY
		QRY_VersionIsOlderThan((INTEGER)_Major,(INTEGER)_Minor,(INTEGER)_Rev,(INTEGER)_Build,(INTEGER)_CompMajor,(INTEGER)_CompMinor,(INTEGER)_CompRev,(INTEGER)_CompBuild)
		AND
		_Major == _CompMajor
		AND
		_Minor < _CompMinor
		THEN
		DB_Noop(1);
		
		QRY
		QRY_VersionIsOlderThan((INTEGER)_Major,(INTEGER)_Minor,(INTEGER)_Rev,(INTEGER)_Build,(INTEGER)_CompMajor,(INTEGER)_CompMinor,(INTEGER)_CompRev,(INTEGER)_CompBuild)
		AND
		_Major == _CompMajor
		AND
		_Minor == _CompMinor
		AND
		_Rev < _CompRev
		THEN
		DB_Noop(1);
		
		QRY
		QRY_VersionIsOlderThan((INTEGER)_Major,(INTEGER)_Minor,(INTEGER)_Rev,(INTEGER)_Build,(INTEGER)_CompMajor,(INTEGER)_CompMinor,(INTEGER)_CompRev,(INTEGER)_CompBuild)
		AND
		_Major == _CompMajor
		AND
		_Minor == _CompMinor
		AND
		_Rev == _CompRev
		AND
		_Build < _CompBuild
		THEN
		DB_Noop(1);
		
	}
	EXIT
	{
		
	}
}
Goal(49).Title("QRY_Characters");
Goal(49)
{
	INIT
	{
		
	}
	KB
	{
		QRY
		QRY_SpeakerBlockedBycombat((GUIDSTRING)_Char,(INTEGER)_Ignore)
		AND
		ObjectIsCharacter(_Char,1)
		AND
		_Ignore == 0
		AND
		CharacterIsInCombat((CHARACTERGUID)_Char,1)
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_SpeakerIsAvailable((GUIDSTRING)_Item)
		AND
		ObjectExists(_Item,1)
		AND
		ObjectIsItem(_Item,1)
		AND
		QRY_SpeakerIsAvailable(_Item,0)
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_SpeakerIsAvailable((GUIDSTRING)_Char)
		AND
		ObjectIsCharacter(_Char,1)
		AND
		QRY_SpeakerIsAvailable((GUIDSTRING)_Char, 0)
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_SpeakerIsDead((GUIDSTRING)_Char)
		AND
		ObjectIsCharacter(_Char,1)
		AND
		CharacterIsDeadOrFeign((CHARACTERGUID)_Char,1)
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_SpeakerIsDead((GUIDSTRING)_Item)
		AND
		ObjectIsItem(_Item,1)
		AND
		ItemIsDestroyed((ITEMGUID)_Item,1)
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_HasInteractionDisabled((GUIDSTRING)_Char)
		AND
		ObjectIsCharacter(_Char,1)
		AND
		CharacterIsPolymorphInteractionDisabled((CHARACTERGUID)_Char,1)
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_SpeakerIsAvailable((GUIDSTRING)_Char, (INTEGER)_IgnoreCombat)
		AND
		NOT QRY_SpeakerIsDead(_Char)
		AND
		IsSpeakerReserved(_Char,0)
		AND
		NOT QRY_HasInteractionDisabled(_Char)
		AND
		NOT QRY_SpeakerBlockedBycombat(_Char,_IgnoreCombat)
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_SpeakerIsAvailable(NULL_00000000-0000-0000-0000-000000000000)
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_CharacterIsNotDisabled((CHARACTERGUID)_Character)
		AND
		HasActiveStatus(_Character,"FROZEN",0)
		AND
		HasActiveStatus(_Character,"STUNNED",0)
		AND
		HasActiveStatus(_Character,"FEAR",0)
		AND
		HasActiveStatus(_Character,"PETRIFIED",0)
		AND
		HasActiveStatus(_Character,"KNOCKED_DOWN",0)
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_SpeakerIsAvailableForCombat((CHARACTERGUID)_Char)
		AND
		CharacterIsDeadOrFeign(_Char,0)
		AND
		IsSpeakerReserved(_Char,0)
		THEN
		DB_NOOP(1);
		
		
		QRY
		QRY_SpeakerIsAvailableAndInDialogRange((CHARACTERGUID)_Char,(CHARACTERGUID)_SourceCharacter)
		AND
		CharacterIsDeadOrFeign(_Char,0)
		AND
		IsSpeakerReserved(_Char,0)
		AND
		CharacterIsInCombat(_Char,0)
		AND
		GetDistanceTo(_Char,_SourceCharacter,_Distance)
		AND
		_Distance < 10.0
		THEN
		DB_NOOP(1);
		
		QRY
		Query_IsPlayerHiding((CHARACTERGUID)_Char)
		AND
		HasActiveStatus(_Char,"SNEAKING",1)
		THEN
		DB_NOOP(1);
		
		QRY
		Query_IsPlayerHiding((CHARACTERGUID)_Char)
		AND
		HasActiveStatus(_Char,"INVISIBLE",1)
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_CharacterIsNull((CHARACTERGUID)_Char)
		AND
		_Char == NULL_00000000-0000-0000-0000-000000000000
		THEN
		DB_NOOP(1);
		
	}
	EXIT
	{
		
	}
}
Goal(50).Title("Sandbox");
Goal(50)
{
	INIT
	{
		DB_CheckLevelStart("_TMPL_Sandbox");
		
	}
	KB
	{
		IF
		RegionStarted("_TMPL_Sandbox")
		THEN
		GoalCompleted;
		
		IF
		DB_CheckLevelStart("_TMPL_Sandbox")
		AND
		DB_CurrentLevel("_TMPL_Sandbox")
		THEN
		GoalCompleted;
		
	}
	EXIT
	{
		NOT DB_CheckLevelStart("_TMPL_Sandbox");
		
	}
}
Goal(51).Title("ZZZ_LastGoal");
Goal(51)
{
	INIT
	{
		
	}
	KB
	{
		PROC
		ProcClearAutomatedDialog((INTEGER)_Inst)
		THEN
		ProcClearDialogPlayers(_Inst);
		ProcClearDialogNPCs(_Inst);
		ProcClearDialogCounts(_Inst);
		NOT DB_AutomatedDialog(_Inst);
		
		IF
		VoiceBarkEnded(_,_Inst)
		THEN
		NOT DB_AutomatedDialogIsVB(_Inst);
		ProcClearAutomatedDialog(_Inst);
		
		IF
		AutomatedDialogEnded(_,_Inst)
		AND
		NOT DB_AutomatedDialogIsVB(_Inst)
		THEN
		ProcClearAutomatedDialog(_Inst);
		
		IF
		AutomatedDialogEnded(_Dialog,_Inst)
		THEN
		NOT DB_DialogName(_Dialog,_Inst);
		
		IF
		DialogEnded(_Dialog,_Inst)
		THEN
		ProcClearDialogPlayers(_Inst);
		ProcClearDialogNPCs(_Inst);
		ProcClearDialogCounts(_Inst);
		NOT DB_DialogName(_Dialog,_Inst);
		NOT DB_MarkedForDelete(_Inst);
		
		IF
		DialogActorLeft(_Dialog,_Inst,_Actor)
		AND
		DB_DialogPlayers(_Inst,_Actor,_Index)
		THEN
		NOT DB_DialogPlayers(_Inst,_Actor,_Index);
		ProcClearPlayerIfNotInOtherDialog(_Inst,_Actor);
		
		IF
		DialogActorLeft(_Dialog,_Inst,_Actor)
		AND
		DB_DialogNPCs(_Inst,_Actor,_Index)
		THEN
		NOT DB_DialogNPCs(_Inst,_Actor,_Index);
		ProcClearNPCIfNotInOtherDialog(_Inst,_Actor);
		
		IF
		DialogActorLeft(_Dialog,_Inst,_Actor)
		THEN
		ProcSetNumberOfInvolvedActors(_Inst);
		
		PROC
		ProcClearDialogPlayers((INTEGER)_Inst)
		AND
		DB_DialogPlayers(_Inst,_Player,_Index)
		THEN
		NOT DB_DialogPlayers(_Inst,_Player,_Index);
		
		PROC
		ProcClearDialogNPCs((INTEGER)_Inst)
		AND
		DB_DialogNPCs(_Inst,_Player,_Index)
		THEN
		NOT DB_DialogNPCs(_Inst,_Player,_Index);
		
		PROC
		ProcClearDialogCounts((INTEGER)_Inst)
		AND
		DB_DialogNumPlayers(_Inst,_NumPlayers)
		AND
		DB_DialogNumNPCs(_Inst,_NumNPCs)
		THEN
		NOT DB_DialogNumPlayers(_Inst,_NumPlayers);
		NOT DB_DialogNumNPCs(_Inst,_NumNPCs);
		
		IF
		CharacterCreationFinished(_)
		THEN
		NOT DB_InCharacterCreation(1);
		NotifyCharacterCreationFinished();
		
	}
	EXIT
	{
		
	}
}
Goal(10).SubGoal(2);
Goal(10).SubGoal(4);
Goal(10).SubGoal(8);
Goal(10).SubGoal(9);
Goal(10).SubGoal(14);
Goal(10).SubGoal(15);
Goal(10).SubGoal(19);
Goal(10).SubGoal(29);
Goal(10).SubGoal(30);
Goal(10).SubGoal(37);
Goal(10).SubGoal(39);
Goal(10).SubGoal(43);
Goal(10).SubGoal(50);
Goal(2).SubGoals(AND);
Goal(4).SubGoals(AND);
Goal(8).SubGoals(AND);
Goal(9).SubGoals(AND);
Goal(14).SubGoals(AND);
Goal(15).SubGoals(AND);
Goal(19).SubGoals(AND);
Goal(29).SubGoals(AND);
Goal(30).SubGoals(AND);
Goal(37).SubGoals(AND);
Goal(39).SubGoals(AND);
Goal(43).SubGoals(AND);
Goal(50).SubGoals(AND);
Goal(45).SubGoal(44);
Goal(44).SubGoals(AND);
Goal(50).SubGoal(38);
Goal(38).SubGoals(AND);
